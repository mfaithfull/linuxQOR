// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//A documented minimal outline application using the QOR SDK

/*Include the QOR framweork for structural elements
like the Application class

NOTE: Using this SDK level include effectively dumps everything
from the qor and qor::framework namespaces into the global 
namespace so be more specific with your includes for a 
'real' application */

#include "sdk/using_framework.h"
#include "src/qor/module/moduleregistry.h"  //exceptional include not provided by the SDK, inernal header for module introspection only.
#include "src/framework/host/host.h"        //exceptional include not provided by the SDK, inernal header for module introspection only.

/*For conveniece we provide one global and immutable
definition of the application name*/
const char* appName = "Outline";

/*Our application is a module in the QOR ecosystem
The qor_pp_implement_module macro gives us a named, versioned module object
Every QOR executable must:
1. Link the qor_module static library to become a module
2. Link the qor_host module to become the host for other modules
3. #define QOR_PP_EXECUTABLE for it's build (This requirement may get removed)
4. provide an executable module instance equivalent to this macro.
Optionally #define qor_pp_ver_major, qor_pp_ver_minor & qor_pp_ver_patch
at compilation time to encode that version into the module object.*/
qor_pp_implement_module(appName)

void AccessLibraries();

/*A QOR application is just a C++ application
An empty int main(){return 0;} would work but isn't very interesting*/
int main()
{
    AccessLibraries();

    /*Build an Application*/
    auto outlineApp = AppBuilder().Build(appName);

    /*We'll skip configuraing the application in this simple case*/

    /*The QOR Application class is a context for running 
    Workflows and anything else that meets the 
    requirements for a runable object
    Our Application instance is a shared global resource so
    we access it with synchronisation even though this app
    is safely single threaded.*/
    return outlineApp(qor_shared).Run
    (
        /*Here we make a runable object from a simple
        lamda with the make_runnable utility function.
        Why is this needed?
        This bakes in exception handling
        and allows many other good things later.*/
        make_runable(

            /*A minimal lambda that is runnable
            i.e. it takes no parameters and returns
            an integer*/
            []()->int
            {
                /*The traditional C++ Hello world*/
                std::cout << "Hello from the QOR Outline application." << std::endl;

                /*This is the integer that the runnable lambda
                and then the main function will return*/
                return EXIT_SUCCESS;
            }
        )
    );
}

/*This (for science only) function can be used to access 
every loaded QOR library.
This is intentionally not thread safe so use only when
single threaded at startup.
Diagnostically something like this can be useful for tracking
down dependency issues.*/
void AccessLibraries()
{
    /*Visit all the QOR modules loaded into this process*/
    TheHost()->Modules()->VisitModules(
        [](Module* module)
        {
            std::cout << "Module: " << module->Name() << " : " << module->Version() << std::endl;
            /*Visit all the static libraries linked into the module.*/
            module->VisitLibraries(
                [](Library* library)
                {
                    std::cout << "-Library: " << library->Name() << " : " << library->Version() << std::endl;
                }
            );
        }
    );
    /*The last module on the list will be this executable itself*/
}
