// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//A documented application with a Pipeline using the QOR SDK

/*For a more basic documented example of the flow of a QOR application
see the roller example*/

#include "sdk/using_framework.h"
#include "sdk/using_platform.h"
#include "sdk/components/framework.h"

const char* appName = "Plumbing";
qor_pp_implement_module(appName)

bool requiresCurrentThread = ImplementsICurrentThread();
bool requiresFileSystem = ImplementsIFileSystem();

void TraditionalFileRead(FileSystem::ref filesystem, FileIndex& index);
void PipelineFileProcessor(FileSystem::ref filesystem, FileIndex& index);

int main()
{
    /*To use facilities from the operating system, first we add them
    to the Platform object. This works just like adding features
    to the Application Role*/
    ThePlatform(qor_shared)->AddSubsystem<FileSystem>();

    return AppBuilder().Build(appName)->SetRole<Role>().Run(
    make_runable(
        []()->int
        {
            /*Retrieve the file system singleton from the platform.
            The platform is a shared object so synchronisation is required*/
            auto fileSystem = ThePlatform()(qor_shared).GetSubsystem<FileSystem>();
            
            /*All the functions on the fileSystem object are const so 
            once we have it, it's safe to use without synchronisation*/

            /*A FileIndex is how we refer to a specific file without opening it.
            Internally it's a directory entry, which is just the index of a file*/
            FileIndex index(fileSystem->CurrentPath(), "alice.txt");

            if(!index.Exists())
            {
                std::cout << "Please place a file called alice.txt in the folder " << index.GetPath().ToString() << " to make this example work. The file contents will be encoded into output.txt" << std::endl;
                return 0;
            }

            /*If we want to do simple step by step processing
            we can use the traditional way of dealing with files.*/
            TraditionalFileRead(fileSystem, index);

            /*However what if we want to transcode the whole file
            to base64 encoding and write it out to another file?*/
            PipelineFileProcessor(fileSystem, index);
        
            return 0;
        }
    ));
}

void TraditionalFileRead(FileSystem::ref fileSystem, FileIndex& index)
{
    /*Obtain a file object from the file system*/
    auto file = fileSystem->Open(index, OpenFor::ReadOnly);

    /*Initialise a reader for the file*/
    FileReader reader(file);

    /*Read a line from the file*/
    std::string line = reader.ReadLine();

    /*process the data*/
    std::cout << line << std::endl;

    /*RAII ensures the file is closed here as the file object is destroyed

    This could of course be compressed to the single statement:
    std::cout << (FileReader(index, OpenFor::ReadOnly).ReadLine()) << std::endl;
    */
}

void PipelineFileProcessor(FileSystem::ref fileSystem, FileIndex& input)
{
    /*An output file to go with the input file*/
    FileIndex output(fileSystem->CurrentPath(), "output.txt");

    if(output.Exists())
    {
        fileSystem->Delete(output);
    }

    /*Set up a base 64 encoder with 8K of buffer space*/
    Base64EncodeFilter encode(8192);

    /*We use File connectors to connect to the input and output files
    These encapsulate everything file related for the pipeline. If we used
    Socket connectors or Pipe connectors or DBus connectors the rest of
    the pipeline would be identical and oblivious*/
    FileConnector inputConnector(input, WithFlags::None, ShareMode::Owner_Read, OpenFor::ReadOnly);
    FileConnector outputConnector(output, WithFlags::CreateNew, ShareMode::Owner_Read, OpenFor::ReadWrite);

    /*Create a pipeline with the connectors at each end*/
    Pipeline fileProcessor(inputConnector, outputConnector, Element::Push);

    /*Insert the base 64 encoder as a filter*/
    fileProcessor.InsertInlineFilter(encode);

    /*Connect to the sink and the source
    This opens the files at both ends*/
    fileProcessor.Connect();

    /*Pump all the available data
    This will read, encode and write all the data in the inputfile*/
    fileProcessor.PumpAll();

    /*Everything we've created here is on the stack so it's all cleaned up and the files closed automatically.*/

    /*This could also be done as a single statement
    Pipeline(
        FileConnector(input,WithFlags::None,ShareMode::Owner_Read,OpenFor::ReadOnly),
        FileConnector(output,WithFlags::CreateNew,ShareMode::Owner_Write,OpenFor::ReadWrite),
        Element::Push).
        InsertInlineFilter(Base64EncodeFilter(8192)).
        Connect().
        PumpAll();
    */
}


