// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_HTTPCLIENT
#define QOR_PP_H_HTTPCLIENT

#include <string>
#include <regex>

#include "src/components/network/client/netclient.h"
#include "src/components/protocols/http/client/requestsource/source.h"
#include "src/components/protocols/http/client/responsesink/sink.h"
#include "src/components/protocols/http/protocol.h"
#include "src/components/protocols/http/response/response.h"

using ResponseHandler = std::function<bool(const qor::components::protocols::http::HTTPResponse &aresponse)>;

class HTTPClient
{
public:

    HTTPClient();
    explicit HTTPClient(const std::string &host, int port);
    explicit HTTPClient(const std::string &host, int port, const std::string &client_cert_path, const std::string &client_key_path);

    virtual ~HTTPClient() = default;

    bool Send(qor::ref_of<qor::components::protocols::http::HTTPRequest>::type req/*, protocols::http::Response &res, Error &error*/);

    qor::components::protocols::http::HTTPResponse Receive();

    inline qor::components::protocols::http::HTTPResponse Get(const std::string &path, DownloadProgress progress = nullptr)
    {
        return Get(path, qor::components::protocols::http::Headers(), std::move(progress));
    }

    inline qor::components::protocols::http::HTTPResponse Get(const std::string &path, const qor::components::protocols::http::Params &params, const qor::components::protocols::http::Headers &headers, DownloadProgress progress = nullptr)
    {
        if (params.empty()) { return Get(path, headers); }

        std::string path_with_query = qor::components::protocols::http::HTTPRequest::AppendQueryParams(path, params);
        return Get(path_with_query, headers, std::move(progress));
    }

    inline qor::components::protocols::http::HTTPResponse Get(const std::string &path, qor::components::protocols::http::ContentReceiver content_receiver, DownloadProgress progress = nullptr)
    {
        return Get(path, qor::components::protocols::http::Headers(), nullptr, std::move(content_receiver), std::move(progress));
    }

    inline qor::components::protocols::http::HTTPResponse Get(const std::string &path, ResponseHandler response_handler, qor::components::protocols::http::ContentReceiver content_receiver, DownloadProgress progress = nullptr)
    {
        return Get(path, qor::components::protocols::http::Headers(), std::move(response_handler), std::move(content_receiver), std::move(progress));        
    }

    inline qor::components::protocols::http::HTTPResponse Get(const std::string &path, const qor::components::protocols::http::Headers &headers, qor::components::protocols::http::ContentReceiver content_receiver, DownloadProgress progress = nullptr)
    {
        return Get(path, headers, nullptr, std::move(content_receiver), std::move(progress));
    }

    qor::components::protocols::http::HTTPResponse Get(const std::string &path, const qor::components::protocols::http::Headers &headers, ResponseHandler response_handler, qor::components::protocols::http::ContentReceiver content_receiver, DownloadProgress progress = nullptr)
    {
        qor::ref_of<qor::components::protocols::http::HTTPRequest>::type req = qor::new_ref<qor::components::protocols::http::HTTPRequest>();
        req->SetMethod("GET");
        req->SetPath(path);
        req->SetHeaders(headers);
        /*        
        req.response_handler = std::move(response_handler);
        req.content_receiver =
        [content_receiver](const char *data, size_t data_length,
        size_t offset, size_t total_length) 
        {
            return content_receiver(data, data_length);
        };
        req.download_progress = std::move(progress);
        if (max_timeout_msec_ > 0) {
            req.start_time_ = std::chrono::steady_clock::now();
        }
        */
        if(Send(std::move(req)))
        {
            return Receive();
        }
        //TODO: return a stock failure to send packaged as a Response
        qor::components::protocols::http::HTTPResponse failure;
        failure.SetValue("Failed to Send");
        return failure;
    }

    inline qor::components::protocols::http::HTTPResponse Get(const std::string &path, const qor::components::protocols::http::Params &params, const qor::components::protocols::http::Headers &headers, qor::components::protocols::http::ContentReceiver content_receiver, DownloadProgress progress = nullptr)
    {
        return Get(path, params, headers, nullptr, std::move(content_receiver), std::move(progress));
    }

    inline qor::components::protocols::http::HTTPResponse Get(const std::string &path, const qor::components::protocols::http::Params &params, const qor::components::protocols::http::Headers &headers, ResponseHandler response_handler, qor::components::protocols::http::ContentReceiver content_receiver, DownloadProgress progress = nullptr)
    {
        if (params.empty()) 
        {
            return Get(path, headers, std::move(response_handler),
            std::move(content_receiver), std::move(progress));
        }

        std::string path_with_query = qor::components::protocols::http::HTTPRequest::AppendQueryParams(path, params);
        return Get(path_with_query, headers, std::move(response_handler), std::move(content_receiver), std::move(progress));
    }

    qor::components::protocols::http::HTTPResponse Get(const std::string &path, const qor::components::protocols::http::Headers &headers, DownloadProgress progress = nullptr)
    {
        qor::ref_of<qor::components::protocols::http::HTTPRequest>::type req = qor::new_ref<qor::components::protocols::http::HTTPRequest>();
        req->SetMethod("GET");
        req->SetPath(path);
        req->SetHeaders(headers);
        /*        
        req.download_progress = std::move(progress);
        if (max_timeout_msec_ > 0) 
        {
            req.start_time_ = std::chrono::steady_clock::now();
        }
        */
        if(Send(std::move(req)))
        {
            return Receive();            
        }
        //TODO: return a stock failure to send packaged as a Response
        qor::components::protocols::http::HTTPResponse failure;
        failure.SetValue("Failed to Send");
        return failure;
    }


    void Configure(const std::string &host, int port, const std::string &ip = "", qor::network::sockets::eAddressFamily address_family = qor::network::sockets::eAddressFamily::AF_INet, qor::network::addrinfo_flags socket_flags = 0, bool tcp_nodelay = false, bool ipv6_v6only = false, time_t timeout_sec = 0)
    {
        m_client.Configure(host, port, ip, address_family, socket_flags, tcp_nodelay, ipv6_v6only, timeout_sec);
    }

    bool Connect(const std::string &host, int port, const std::string &ip, qor::network::sockets::eAddressFamily address_family, qor::network::addrinfo_flags socket_flags, bool tcp_nodelay, bool ipv6_v6only, time_t timeout_sec)
    {
        qor_pp_ofcontext;
        m_client.Configure(host, port, ip, address_family, socket_flags, tcp_nodelay, ipv6_v6only, timeout_sec);
        return Connect();
    }

protected:

    bool Connect()
    {
        return m_client.Connect();
    }

    void Disconnect()
    {
        m_client.Disconnect();
    }

private:

    std::string m_host;
    int m_port;

    qor::components::NetworkClient m_client;
    qor::pipeline::ByteBuffer m_requestBuffer;
    qor::pipeline::ByteBuffer m_responseBuffer;
    qor::components::protocols::http::HTTPSource m_source;
    qor::components::protocols::http::HTTPSink m_sink;

};

#endif//QOR_PP_H_HTTPCLIENT
