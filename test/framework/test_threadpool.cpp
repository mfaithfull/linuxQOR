// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "../../src/configuration/configuration.h"
#include "../../src/qor/test/test.h"
#include "../../src/qor/assert/assert.h"
#include "../../src/qor/module/moduleregistry.h"
#include "../../src/qor/injection/typeidentity.h"
#include "../../src/qor/objectcontext/anyobject.h"
#include "../../src/framework/thread/currentthread.h"
#include "../../src/framework/thread/thread.h"
#include "../../src/framework/thread/threadpool.h"
#include "../../src/framework/thread/currentprocess.h"
#include "../../src/qor/reference/newref.h"
#include <random>

using namespace qor;
using namespace qor::test;
using namespace qor::framework;

struct ThreadPoolTestSuite{};
bool requiresICurrentThread = qor::ImplementsICurrentThread();
bool requiresICurrentProcess = qor::ImplementsICurrentProcess();

std::vector<std::thread::id> obtain_unique_threads(ThreadPool& pool)
{
    const std::size_t num_tasks = pool.GetThreadCount() * 2;
    std::vector<std::thread::id> thread_ids(num_tasks);
    std::atomic<std::size_t> total_count = 0;
    counting_semaphore sem(0);
    for (std::thread::id& tid : thread_ids)
    {
        pool.PostTask(
            [&total_count, &tid, &sem, thread_count = pool.GetThreadCount(), num_tasks]
            {
                tid = std::this_thread::get_id();
                if (++total_count == thread_count)
                    sem.release(static_cast<std::ptrdiff_t>(num_tasks));
                sem.acquire();
            });
    }
    pool.Wait();
    std::sort(thread_ids.begin(), thread_ids.end());
    const std::vector<std::thread::id>::iterator last = std::unique(thread_ids.begin(), thread_ids.end());
    thread_ids.erase(last, thread_ids.end());
    return thread_ids;
}

qor_pp_test_suite_case(ThreadPoolTestSuite, canConstructThreadPool)
{
    ThreadPool pool(std::thread::hardware_concurrency());
    ////sync_out.println("Checking that the thread pool reports a number of threads equal to the hardware concurrency...");
    qor_pp_assert_that(pool.GetThreadCount()).isEqualTo(std::thread::hardware_concurrency());
    ////sync_out.println("Checking that the manually counted number of unique thread IDs is equal to the reported number of threads...");
    const std::vector<std::thread::id> unique_threads = obtain_unique_threads(pool);
    qor_pp_assert_that(unique_threads.size()).isEqualTo(pool.GetThreadCount());;
    ////sync_out.println("Checking that the unique thread IDs obtained are the same as those reported by GetThreadIds()...");
    std::vector<std::thread::id> threads_from_pool = pool.GetThreadIds();
    std::sort(threads_from_pool.begin(), threads_from_pool.end());
    qor_pp_assert_that(threads_from_pool == unique_threads).isTrue();

}

qor_pp_test_suite_case(ThreadPoolTestSuite, confirmResetWorks)
{
    ThreadPool pool;
    pool.Reset(static_cast<std::size_t>(std::thread::hardware_concurrency()) * 2);
    ////sync_out.println("Checking that after reset() the thread pool reports a number of threads equal to double the hardware concurrency...");
    qor_pp_assert_that(std::thread::hardware_concurrency() * 2 == pool.GetThreadCount()).isTrue();
    ////sync_out.println("Checking that after reset() the manually counted number of unique thread IDs is equal to the reported number of threads...");
    qor_pp_assert_that(pool.GetThreadCount() == obtain_unique_threads(pool).size()).isTrue();
    pool.Reset(std::thread::hardware_concurrency());
    ////sync_out.println("Checking that after a second reset() the thread pool reports a number of threads equal to the hardware concurrency...");
    qor_pp_assert_that(std::thread::hardware_concurrency() == pool.GetThreadCount()).isTrue();
    ////sync_out.println("Checking that after a second reset() the manually counted number of unique thread IDs is equal to the reported number of threads...");
    qor_pp_assert_that(pool.GetThreadCount() == obtain_unique_threads(pool).size()).isTrue();
}

//Check if the expected result has been obtained, report the result, and keep count of the total number of successes and failures.
template <typename T1, typename T2>
void check(const T1& expected, const T2& obtained)
{
    //sync_out.print("- Expected: ", expected, ", obtained: ", obtained, ' ');
    qor_pp_assert_that(expected == static_cast<T1>(obtained)).isTrue();
}

//Check if all of the flags in a container are equal to the desired value.
template <typename T, typename V>
bool all_flags_equal(const T& flags, const V& value)
{
    return std::all_of(flags.begin(), flags.end(),
        [&value](const auto& flag)
        {
            return flag == value;
        });
}

//Check if all of the flags in a container are set.
template <typename T>
bool all_flags_set(const T& flags)
{
    return std::all_of(flags.begin(), flags.end(),
        [](const bool flag)
        {
            return flag;
        });
}

//Check if none of the flags in a container are set.
template <typename T>
bool no_flags_set(const T& flags)
{
    return std::none_of(flags.begin(), flags.end(),
        [](const bool flag)
        {
            return flag;
        });
}

// =======================================
// Functions for generating random numbers
// =======================================

//Obtain a random number in a specified range.
template <typename T>
T random(const T min, const T max)
{
    static std::random_device rand_device;
    static std::mt19937_64 twister(rand_device());
    std::uniform_int_distribution<T> dist(min, max);
    return dist(twister);
}

//Obtain an ordered pair of two distinct random numbers in a specified range.
template <typename T>
std::pair<T, T> random_pair(const T min, const T max)
{
    static std::random_device rand_device;
    static std::mt19937_64 twister(rand_device());
    std::uniform_int_distribution<T> dist(min, max);
    T first = dist(twister);
    T second;
    do
        second = dist(twister);
    while (second == first);
    if (second < first)
        return {second, first};
    return {first, second};
}

// =======================================
// Functions to verify submission of tasks
// =======================================

class [[nodiscard]] detect_copy_move
{
public:
    detect_copy_move() = default;

    detect_copy_move(const detect_copy_move& /*other*/) : copied(true) {}

    detect_copy_move(detect_copy_move&& /*other*/) noexcept : moved(true) {}

    detect_copy_move& operator=(const detect_copy_move&) = delete;
    detect_copy_move& operator=(detect_copy_move&&) = delete;
    ~detect_copy_move() = default;

    [[nodiscard]] bool get_copied() const
    {
        return copied;
    };

    [[nodiscard]] bool get_moved() const
    {
        return moved;
    };

private:
    bool copied = false;
    bool moved = false;
}; 

//Check that PostTask() or SubmitTask() work.
void check_task(const std::string_view which_func)
{
    ThreadPool pool;
    //sync_out.println("Checking that ", which_func, " works for a function with no arguments or return value...");
    {
        bool flag = false;
        const auto func = [&flag]
        {
            flag = true;
        };
        if (which_func == "PostTask()")
        {
            pool.PostTask(func);
            pool.Wait();
        }
        else
        {
            pool.SubmitTask(func).wait();
        }
        check(flag);
    }
    //sync_out.println("Checking that ", which_func, " works for a function with one argument and no return value...");
    {
        bool flag = false;
        const auto func = [](bool& flag_)
        {
            flag_ = true;
        };
        if (which_func == "PostTask()")
        {
            pool.PostTask(
                [&func, &flag]
                {
                    func(flag);
                });
            pool.Wait();
        }
        else
        {
            pool.SubmitTask(
                    [&func, &flag]
                    {
                        func(flag);
                    })
                .wait();
        }
        check(flag);
    }
    //sync_out.println("Checking that ", which_func, " works for a function with two arguments and no return value...");
    {
        bool flag1 = false;
        bool flag2 = false;
        const auto func = [](bool& flag1_, bool& flag2_)
        {
            flag1_ = flag2_ = true;
        };
        if (which_func == "PostTask()")
        {
            pool.PostTask(
                [&func, &flag1, &flag2]
                {
                    func(flag1, flag2);
                });
            pool.Wait();
        }
        else
        {
            pool.SubmitTask(
                    [&func, &flag1, &flag2]
                    {
                        func(flag1, flag2);
                    })
                .wait();
        }
        check(flag1 && flag2);
    }
    if (which_func == "SubmitTask()")
    {
        //sync_out.println("Checking that SubmitTask() works for a function with no arguments and a return value...");
        {
            bool flag = false;
            const auto func = [&flag]
            {
                return (flag = true);
            };
            std::future<bool> flag_future = pool.SubmitTask(func);
            check(flag_future.get() && flag);
        }
        //sync_out.println("Checking that SubmitTask() works for a function with one argument and a return value...");
        {
            bool flag = false;
            const auto func = [](bool& flag_)
            {
                return (flag_ = true);
            };
            std::future<bool> flag_future = pool.SubmitTask(
                [&func, &flag]
                {
                    return func(flag);
                });
            check(flag_future.get() && flag);
        }
        //sync_out.println("Checking that SubmitTask() works for a function with two arguments and a return value...");
        {
            bool flag1 = false;
            bool flag2 = false;
            const auto func = [](bool& flag1_, bool& flag2_)
            {
                return (flag1_ = flag2_ = true);
            };
            std::future<bool> flag_future = pool.SubmitTask(
                [&func, &flag1, &flag2]
                {
                    return func(flag1, flag2);
                });
            check(flag_future.get() && flag1 && flag2);
        }
    }
    //sync_out.println("Checking that ", which_func, " does not create unnecessary copies of the function object...");
    {
        bool copied = false;
        bool moved = false;
        auto test_copy = [detect = detect_copy_move(), &copied, &moved]
        {
            copied = detect.get_copied();
            moved = detect.get_moved();
        };
        if (which_func == "PostTask()")
        {
            pool.PostTask(std::move(test_copy));
            pool.Wait();
        }
        else
        {
            pool.SubmitTask(std::move(test_copy)).wait();
        }
        check(!copied && moved);
    }
    //sync_out.println("Checking that ", which_func, " correctly accepts arguments passed by value, reference, and constant reference...");
    {
        {
            //sync_out.println("Value:");
            const std::int64_t pass_me_by_value = 0;
            const auto func_value = [](std::int64_t passed_by_value)
            {
                if (++passed_by_value != 1)
                    static_cast<void>(0);
            };
            if (which_func == "PostTask()")
            {
                pool.PostTask(
                    [&func_value, pbv = pass_me_by_value]
                    {
                        func_value(pbv);
                    });
                pool.Wait();
            }
            else
            {
                pool.SubmitTask(
                        [&func_value, pbv = pass_me_by_value]
                        {
                            func_value(pbv);
                        })
                    .wait();
            }
            check(pass_me_by_value == 0);
        }
        {
            //sync_out.println("Reference:");
            std::int64_t pass_me_by_ref = 0;
            const auto func_ref = [](std::int64_t& passed_by_ref)
            {
                ++passed_by_ref;
            };
            if (which_func == "PostTask()")
            {
                pool.PostTask(
                    [&func_ref, &pass_me_by_ref]
                    {
                        func_ref(pass_me_by_ref);
                    });
                pool.Wait();
            }
            else
            {
                pool.SubmitTask(
                        [&func_ref, &pass_me_by_ref]
                        {
                            func_ref(pass_me_by_ref);
                        })
                    .wait();
            }
            check(pass_me_by_ref == 1);
        }
        {
            //sync_out.println("Constant reference:");
            std::int64_t pass_me_by_cref = 0;
            binary_semaphore sem(0);
            const auto func_cref = [&sem](const std::int64_t& passed_by_cref)
            {
                sem.acquire();
                check(passed_by_cref == 1);
            };
            if (which_func == "PostTask()")
            {
                pool.PostTask(
                    [&func_cref, &pass_me_by_cref = std::as_const(pass_me_by_cref)]
                    {
                        func_cref(pass_me_by_cref);
                    });
                ++pass_me_by_cref;
                sem.release();
                pool.Wait();
            }
            else
            {
                const std::future<void> future = pool.SubmitTask(
                    [&func_cref, &pass_me_by_cref = std::as_const(pass_me_by_cref)]
                    {
                        func_cref(pass_me_by_cref);
                    });
                ++pass_me_by_cref;
                sem.release();
                future.wait();
            }
        }
    }
}

//A class to facilitate checking that member functions of different types have been successfully submitted.

class [[nodiscard]] flag_class
{
public:
    explicit flag_class(ThreadPool& pool_) : pool(&pool_) {}

    void set_flag_no_args()
    {
        flag = true;
    }

    void set_flag_one_arg(const bool arg)
    {
        flag = arg;
    }

    [[nodiscard]] bool set_flag_no_args_return()
    {
        return (flag = true);
    }

    [[nodiscard]] bool set_flag_one_arg_return(const bool arg)
    {
        return (flag = arg);
    }

    [[nodiscard]] bool get_flag() const
    {
        return flag;
    }

    void detach_test_flag_no_args()
    {
        pool->PostTask(
            [this]
            {
                set_flag_no_args();
            });
        pool->Wait();
        check(get_flag());
    }

    void detach_test_flag_one_arg()
    {
        pool->PostTask(
            [this]
            {
                set_flag_one_arg(true);
            });
        pool->Wait();
        check(get_flag());
    }

    void submit_test_flag_no_args()
    {
        pool->SubmitTask(
                [this]
                {
                    set_flag_no_args();
                })
            .wait();
        check(get_flag());
    }

    void submit_test_flag_one_arg()
    {
        pool->SubmitTask(
                [this]
                {
                    set_flag_one_arg(true);
                })
            .wait();
        check(get_flag());
    }

    void submit_test_flag_no_args_return()
    {
        std::future<bool> flag_future = pool->SubmitTask(
            [this]
            {
                return set_flag_no_args_return();
            });
        check(flag_future.get() && get_flag());
    }

    void submit_test_flag_one_arg_return()
    {
        std::future<bool> flag_future = pool->SubmitTask(
            [this]
            {
                return set_flag_one_arg_return(true);
            });
        check(flag_future.get() && get_flag());
    }

private:
    bool flag = false;
    ThreadPool* pool;
};

qor_pp_test_suite_case(ThreadPoolTestSuite, canSubmitMemerFunctions)
{
    ThreadPool pool;
    //sync_out.println("Checking that PostTask() works for a member function with no arguments or return value...");
    {
        flag_class flag(pool);
        pool.PostTask(
            [&flag]
            {
                flag.set_flag_no_args();
            });
        pool.Wait();
        check(flag.get_flag());
    }
    //sync_out.println("Checking that PostTask() works for a member function with one argument and no return value...");
    {
        flag_class flag(pool);
        pool.PostTask(
            [&flag]
            {
                flag.set_flag_one_arg(true);
            });
        pool.Wait();
        check(flag.get_flag());
    }
    //sync_out.println("Checking that SubmitTask() works for a member function with no arguments or return value...");
    {
        flag_class flag(pool);
        pool.SubmitTask(
                [&flag]
                {
                    flag.set_flag_no_args();
                })
            .wait();
        check(flag.get_flag());
    }
    //sync_out.println("Checking that SubmitTask() works for a member function with one argument and no return value...");
    {
        flag_class flag(pool);
        pool.SubmitTask(
                [&flag]
                {
                    flag.set_flag_one_arg(true);
                })
            .wait();
        check(flag.get_flag());
    }
    //sync_out.println("Checking that SubmitTask() works for a member function with no arguments and a return value...");
    {
        flag_class flag(pool);
        std::future<bool> flag_future = pool.SubmitTask(
            [&flag]
            {
                return flag.set_flag_no_args_return();
            });
        check(flag_future.get() && flag.get_flag());
    }
    //sync_out.println("Checking that SubmitTask() works for a member function with one argument and a return value...");
    {
        flag_class flag(pool);
        std::future<bool> flag_future = pool.SubmitTask(
            [&flag]
            {
                return flag.set_flag_one_arg_return(true);
            });
        check(flag_future.get() && flag.get_flag());
    }
}

qor_pp_test_suite_case(ThreadPoolTestSuite, canSubmitMemerFunctionsOnInstance)
{
    ThreadPool pool;
    //sync_out.println("Checking that PostTask() works within an object for a member function with no arguments or return value...");
    {
        flag_class flag(pool);
        flag.detach_test_flag_no_args();
    }
    //sync_out.println("Checking that PostTask() works within an object for a member function with one argument and no return value...");
    {
        flag_class flag(pool);
        flag.detach_test_flag_one_arg();
    }
    //sync_out.println("Checking that SubmitTask() works within an object for a member function with no arguments or return value...");
    {
        flag_class flag(pool);
        flag.submit_test_flag_no_args();
    }
    //sync_out.println("Checking that SubmitTask() works within an object for a member function with one argument and no return value...");
    {
        flag_class flag(pool);
        flag.submit_test_flag_one_arg();
    }
    //sync_out.println("Checking that SubmitTask() works within an object for a member function with no arguments and a return value...");
    {
        flag_class flag(pool);
        flag.submit_test_flag_no_args_return();
    }
    //sync_out.println("Checking that SubmitTask() works within an object for a member function with one argument and a return value...");
    {
        flag_class flag(pool);
        flag.submit_test_flag_one_arg_return();
    }
}

std::atomic<bool> check_callables_flag = false;

void normal_func()
{
    check_callables_flag = true;
}

struct functor
{
    void operator()()
    {
        check_callables_flag = true;
    }
};

struct has_member_function
{
    static void member_function()
    {
        check_callables_flag = true;
    }
};

qor_pp_test_suite_case(ThreadPoolTestSuite, callableTypesAreExecuted)
{
    ThreadPool pool;

    //sync_out.println("Checking normal function...");
    pool.SubmitTask(normal_func).wait();
    check(check_callables_flag);

    //sync_out.println("Checking function pointer...");
    check_callables_flag = false;
    void (*const func_ptr)() = normal_func;
    pool.SubmitTask(func_ptr).wait();
    check(check_callables_flag);

    //sync_out.println("Checking pointer to static member function...");
    check_callables_flag = false;
    auto member_func_ptr = has_member_function::member_function;
    pool.SubmitTask(member_func_ptr).wait();
    check(check_callables_flag);

    //sync_out.println("Checking lambda expression...");
    check_callables_flag = false;
    const auto lambda = []
    {
        check_callables_flag = true;
    };
    pool.SubmitTask(lambda).wait();
    check(check_callables_flag);

    //sync_out.println("Checking std::function...");
    check_callables_flag = false;
    const std::function<void()> function = []
    {
        check_callables_flag = true;
    };
    pool.SubmitTask(function).wait();
    check(check_callables_flag);

#ifdef __cpp_lib_move_only_function
    //sync_out.println("Checking std::move_only_function...");
    check_callables_flag = false;
    std::move_only_function<void()> move_only_function = []
    {
        check_callables_flag = true;
    };
    pool.SubmitTask(std::move(move_only_function)).wait();
    check(check_callables_flag);
#else
    //sync_out.println("Note: std::move_only_function not available, skipping the corresponding test.");
#endif

    //sync_out.println("Checking std::bind...");
    check_callables_flag = false;
    const auto lambda_for_bind = [](std::atomic<bool>& flag)
    {
        flag = true;
    };
    pool.SubmitTask(std::bind(lambda_for_bind, std::ref(check_callables_flag))).wait();
    check(check_callables_flag);

    //sync_out.println("Checking functor...");
    check_callables_flag = false;
    const functor functor_instance;
    pool.SubmitTask(functor_instance).wait();
    check(check_callables_flag);
}

// =====================================
// Functions to verify waiting for tasks
// =====================================

//Check that wait() works.

qor_pp_test_suite_case(ThreadPoolTestSuite, waitWorks)
{
    constexpr std::chrono::milliseconds sleep_time(10);
    ThreadPool pool;
    const std::size_t num_tasks = pool.GetThreadCount() * 10;
    std::vector<std::atomic<bool>> flags(num_tasks);
    for (std::size_t i = 0; i < num_tasks; ++i)
    {
        pool.PostTask(
            [&flags, i, sleep_time]
            {
                std::this_thread::sleep_for(sleep_time);
                flags[i] = true;
            });
    }
    //sync_out.println("Waiting for tasks...");
    pool.Wait();
    check(all_flags_set(flags));
}

//Check that wait() correctly blocks all external threads that call it.
qor_pp_test_suite_case(ThreadPoolTestSuite, waitBlocks)
{
    constexpr std::chrono::milliseconds sleep_time(100);
    constexpr std::size_t num_waiting_tasks = 4;
    ThreadPool pool;
    binary_semaphore sem(0);
    //sync_out.println("Checking that wait() correctly blocks all external threads that call it...");
    pool.PostTask(
        [&sem]
        {
            //sync_out.println("Task submitted to pool 1 and waiting to be released...");
            sem.acquire();
            //sync_out.println("Task released.");
        });
    ThreadPool temp_pool(num_waiting_tasks);
    std::vector<std::atomic<bool>> flags(num_waiting_tasks);
    const auto waiting_task = [&flags, &pool](const std::size_t task_num)
    {
        //sync_out.println("Task ", task_num, " submitted to pool 2 and waiting for pool 1's task to finish...");
        pool.Wait();
        //sync_out.println("Task ", task_num, " finished waiting.");
        flags[task_num] = true;
    };
    for (std::size_t i = 0; i < num_waiting_tasks; ++i)
    {
        temp_pool.PostTask(
            [&waiting_task, i]
            {
                waiting_task(i);
            });
    }
    std::this_thread::sleep_for(sleep_time);
    check(no_flags_set(flags));
    sem.release();
    temp_pool.Wait();
    check(all_flags_set(flags));
}

qor_pp_test_suite_case(ThreadPoolTestSuite, wait_forWorks)
{
    constexpr std::chrono::milliseconds long_sleep_time(250);
    constexpr std::chrono::milliseconds short_sleep_time(10);
    ThreadPool pool;
    //sync_out.println("Checking that WaitFor() works...");
    std::atomic<bool> done = false;
    pool.PostTask(
        [&done, long_sleep_time]
        {
            std::this_thread::sleep_for(long_sleep_time);
            done = true;
        });
    //sync_out.println("Task that lasts ", long_sleep_time.count(), "ms submitted. Waiting for ", short_sleep_time.count(), "ms...");
    pool.WaitFor(short_sleep_time);
    check(!done);
    //sync_out.println("Waiting for ", long_sleep_time.count() * 2, "ms...");
    pool.WaitFor(long_sleep_time * 2);
    check(done);
}

qor_pp_test_suite_case(ThreadPoolTestSuite, wait_untilWorks)
{
    constexpr std::chrono::milliseconds long_sleep_time(250);
    constexpr std::chrono::milliseconds short_sleep_time(10);
    ThreadPool pool;
    //sync_out.println("Checking that WaitUntil() works...");
    std::atomic<bool> done = false;
    pool.PostTask(
        [&done, long_sleep_time]
        {
            std::this_thread::sleep_for(long_sleep_time);
            done = true;
        });
    const std::chrono::system_clock::time_point now = std::chrono::system_clock::now();
    //sync_out.println("Task that lasts ", long_sleep_time.count(), "ms submitted. Waiting until ", short_sleep_time.count(), "ms from submission time...");
    pool.WaitUntil(now + short_sleep_time);
    check(!done);
    //sync_out.println("Waiting until ", long_sleep_time.count() * 2, "ms from submission time...");
    pool.WaitUntil(now + long_sleep_time * 2);
    check(done);
}

// An auxiliary thread pool used by check_wait_multiple_deadlock(). It's a global variable so that the program will not get stuck upon destruction of this pool if a deadlock actually occurs.
ThreadPool check_wait_multiple_deadlock_pool;

//Check that calling wait() more than once doesn't create a deadlock.
qor_pp_test_suite_case(ThreadPoolTestSuite, waitMultipleCallDoesntDeadlock)
{
    constexpr std::chrono::milliseconds sleep_time(500);
    constexpr std::size_t n_waiting_tasks = 1000;
    //sync_out.println("Checking for deadlocks when waiting for tasks...");
    ThreadPool pool(1);
    pool.PostTask(
        [sleep_time]
        {
            std::this_thread::sleep_for(sleep_time);
        });
    std::atomic<std::size_t> count = 0;
    for (std::size_t j = 0; j < n_waiting_tasks; ++j)
    {
        check_wait_multiple_deadlock_pool.PostTask(
            [&pool, &count]
            {
                pool.Wait();
                ++count;
            });
    }
    bool passed = false;
    while (true)
    {
        const std::size_t old_count = count;
        check_wait_multiple_deadlock_pool.WaitFor(sleep_time * 2);
        if (count == n_waiting_tasks)
        {
            //sync_out.println("All waiting tasks successfully finished!");
            passed = true;
            break;
        }
        if (count == old_count)
        {
            //sync_out.println("Error: deadlock detected!");
            passed = false;
            break;
        }
        //sync_out.println(count, " tasks out of ", n_waiting_tasks, " finished waiting...");
    }
    check(passed);
}

#ifdef __cpp_exceptions
// An auxiliary thread pool used by check_wait_self_deadlock(). It's a global variable so that the program will not get stuck upon destruction of this pool if a deadlock actually occurs.
ThreadPool check_wait_self_deadlock_pool;

//Check that calling wait() from within a thread of the same pool throws an exception instead of creating a deadlock.
qor_pp_test_suite_case(ThreadPoolTestSuite, waitOnSelfTriggerDeadlockException)
{
    constexpr std::chrono::milliseconds sleep_time(100);
    //sync_out.println("Checking for deadlocks when waiting from within a thread of the same pool...");
    std::atomic<bool> passed = false;
    check_wait_self_deadlock_pool.PostTask(
        [&passed]
        {
            try
            {
                check_wait_self_deadlock_pool.Wait();
            }
            catch (const wait_deadlock&)
            {
                passed = true;
            }
        });
    check_wait_self_deadlock_pool.WaitFor(sleep_time);
    check(passed);
}
#endif

// ========================================
// Functions to verify loop parallelization
// ========================================

//Check that PostLoop() or SubmitLoop() work for a specific range of indices split over a specific number of tasks, with no return value.
bool check_loop_no_return(ThreadPool& pool, const std::int64_t random_start, const std::int64_t random_end, const std::size_t num_tasks, const std::string_view which_func)
{
    //sync_out.println("Verifying that ", which_func, " from ", random_start, " to ", random_end, " with ", num_tasks, num_tasks == 1 ? " task" : " tasks", " modifies all indices exactly once...");
    const std::size_t num_indices = static_cast<std::size_t>(random_end - random_start);
    std::vector<std::atomic<std::int64_t>> flags(num_indices);
    std::atomic<bool> indices_out_of_range = false;
    const auto loop = [&flags, random_start, random_end, &indices_out_of_range](const std::int64_t idx)
    {
        if (idx < random_start || idx > random_end)
            indices_out_of_range = true;
        else
            ++flags[static_cast<std::size_t>(idx - random_start)];
    };
    if (which_func == "PostLoop()")
    {
        pool.PostLoop(random_start, random_end, loop, num_tasks);
        pool.Wait();
    }
    else
    {
        pool.SubmitLoop(random_start, random_end, loop, num_tasks).wait();
    }
    if (indices_out_of_range)
    {
        //sync_out.println("Error: Loop indices out of range!");
        return false;
    }
    return all_flags_equal(flags, 1);
}

//Check that PostLoop() and SubmitLoop() work using several different random values for the range of indices and number of tasks.
qor_pp_test_suite_case(ThreadPoolTestSuite, loopWorks)
{
    constexpr std::int64_t range = 1000000;
    constexpr std::size_t repeats = 10;
    ThreadPool pool;
    for (std::size_t i = 0; i < repeats; ++i)
    {
        const std::pair<std::int64_t, std::int64_t> indices = random_pair(-range, range);
        check(check_loop_no_return(pool, indices.first, indices.second, random<std::size_t>(1, pool.GetThreadCount()), "PostLoop()"));
    }
    for (std::size_t i = 0; i < repeats; ++i)
    {
        const std::pair<std::int64_t, std::int64_t> indices = random_pair(-range, range);
        check(check_loop_no_return(pool, indices.first, indices.second, random<std::size_t>(1, pool.GetThreadCount()), "SubmitLoop()"));
    }
    //sync_out.println("Verifying that PostLoop() with identical start and end indices does nothing...");
    {
        std::atomic<std::size_t> count = 0;
        const std::int64_t index = random(-range, range);
        //sync_out.println("Range: ", index, " to ", index);
        pool.PostLoop(index, index,
            [&count](const std::int64_t)
            {
                ++count;
            });
        pool.Wait();
        check(count == 0);
    }
    //sync_out.println("Verifying that SubmitLoop() with identical start and end indices does nothing...");
    {
        std::atomic<std::size_t> count = 0;
        const std::int64_t index = random(-range, range);
        //sync_out.println("Range: ", index, " to ", index);
        pool.SubmitLoop(index, index,
                [&count](const std::int64_t)
                {
                    ++count;
                })
            .wait();
        check(count == 0);
    }
    //sync_out.println("Verifying that PostLoop() with end index smaller than the start index does nothing...");
    {
        std::atomic<std::size_t> count = 0;
        const std::pair<std::int64_t, std::int64_t> indices = random_pair(-range, range);
        //sync_out.println("Range: ", indices.second, " to ", indices.first);
        pool.PostLoop(indices.second, indices.first,
            [&count](const std::int64_t)
            {
                ++count;
            });
        pool.Wait();
        check(count == 0);
    }
    //sync_out.println("Verifying that SubmitLoop() with end index smaller than the start index does nothing...");
    {
        std::atomic<std::size_t> count = 0;
        const std::pair<std::int64_t, std::int64_t> indices = random_pair(-range, range);
        //sync_out.println("Range: ", indices.second, " to ", indices.first);
        pool.SubmitLoop(indices.second, indices.first,
                [&count](const std::int64_t)
                {
                    ++count;
                })
            .wait();
        check(count == 0);
    }
    //sync_out.println("Trying PostLoop() with a number of tasks larger than the number of indices:");
    {
        const std::int64_t start = random(-range, range);
        check(check_loop_no_return(pool, start, start + random<std::int64_t>(0, static_cast<std::int64_t>(pool.GetThreadCount() * 2)), random<std::size_t>(pool.GetThreadCount() * 2, pool.GetThreadCount() * 4), "PostLoop()"));
    }
    //sync_out.println("Trying SubmitLoop() with a number of tasks larger than the number of indices:");
    {
        const std::int64_t start = random(-range, range);
        check(check_loop_no_return(pool, start, start + random<std::int64_t>(0, static_cast<std::int64_t>(pool.GetThreadCount() * 2)), random<std::size_t>(pool.GetThreadCount() * 2, pool.GetThreadCount() * 4), "SubmitLoop()"));
    }
}

//Check that PostBlocks() or SubmitBlocks() work for a specific range of indices split over a specific number of tasks, with no return value.
bool check_blocks_no_return(ThreadPool& pool, const std::int64_t random_start, const std::int64_t random_end, const std::size_t num_tasks, const std::string_view which_func)
{
    //sync_out.println("Verifying that ", which_func, " from ", random_start, " to ", random_end, " with ", num_tasks, num_tasks == 1 ? " task" : " tasks", " modifies all indices exactly once...");
    const std::size_t num_indices = static_cast<std::size_t>(random_end - random_start);
    std::vector<std::atomic<std::int64_t>> flags(num_indices);
    std::atomic<bool> indices_out_of_range = false;
    const auto loop = [&flags, random_start, random_end, &indices_out_of_range](const std::int64_t start, const std::int64_t end)
    {
        if (start < random_start || end > random_end)
        {
            indices_out_of_range = true;
        }
        else
        {
            for (std::int64_t i = start; i < end; ++i)
                ++flags[static_cast<std::size_t>(i - random_start)];
        }
    };
    if (which_func == "PostBlocks()")
    {
        pool.PostBlocks(random_start, random_end, loop, num_tasks);
        pool.Wait();
    }
    else
    {
        pool.SubmitBlocks(random_start, random_end, loop, num_tasks).wait();
    }
    if (indices_out_of_range)
    {
        //sync_out.println("Error: Block indices out of range!");
        return false;
    }
    return all_flags_equal(flags, 1);
}

//Check that SubmitBlocks() works for a specific range of indices split over a specific number of tasks, with a return value.
void check_blocks_return(ThreadPool& pool, const std::int64_t random_start, const std::int64_t random_end, const std::size_t num_tasks)
{
    //sync_out.println("Verifying that SubmitBlocks() from ", random_start, " to ", random_end, " with ", num_tasks, num_tasks == 1 ? " task" : " tasks", " correctly sums all indices...");
    const auto loop = [](const std::int64_t start, const std::int64_t end)
    {
        std::int64_t total = 0;
        for (std::int64_t i = start; i < end; ++i)
            total += i;
        return total;
    };
    const std::vector<std::int64_t> sums_vector = pool.SubmitBlocks(random_start, random_end, loop, num_tasks).get();
    std::int64_t sum = 0;
    for (const std::int64_t partial_sum : sums_vector)
        sum += partial_sum;
    check(std::abs(random_start - random_end) * (random_start + random_end - 1) / 2, sum);
}

//Check that PostBlocks() and SubmitBlocks() work using several different random values for the range of indices and number of tasks.
qor_pp_test_suite_case(ThreadPoolTestSuite, blocksWorks)
{
    constexpr std::int64_t range = 1000000;
    constexpr std::size_t repeats = 10;
    ThreadPool pool;
    for (std::size_t i = 0; i < repeats; ++i)
    {
        const std::pair<std::int64_t, std::int64_t> indices = random_pair(-range, range);
        check(check_blocks_no_return(pool, indices.first, indices.second, random<std::size_t>(1, pool.GetThreadCount()), "PostBlocks()"));
    }
    for (std::size_t i = 0; i < repeats; ++i)
    {
        const std::pair<std::int64_t, std::int64_t> indices = random_pair(-range, range);
        check(check_blocks_no_return(pool, indices.first, indices.second, random<std::size_t>(1, pool.GetThreadCount()), "SubmitBlocks()"));
    }
    for (std::size_t i = 0; i < repeats; ++i)
    {
        const std::pair<std::int64_t, std::int64_t> indices = random_pair(-range, range);
        check_blocks_return(pool, indices.first, indices.second, random<std::size_t>(1, pool.GetThreadCount()));
    }
    //sync_out.println("Verifying that PostBlocks() with identical start and end indices does nothing...");
    {
        std::atomic<std::size_t> count = 0;
        const std::int64_t index = random(-range, range);
        //sync_out.println("Range: ", index, " to ", index);
        pool.PostBlocks(index, index,
            [&count](const std::int64_t, const std::int64_t)
            {
                ++count;
            });
        pool.Wait();
        check(count == 0);
    }
    //sync_out.println("Verifying that SubmitBlocks() with identical start and end indices does nothing...");
    {
        std::atomic<std::size_t> count = 0;
        const std::int64_t index = random(-range, range);
        //sync_out.println("Range: ", index, " to ", index);
        pool.SubmitBlocks(index, index,
                [&count](const std::int64_t, const std::int64_t)
                {
                    ++count;
                })
            .wait();
        check(count == 0);
    }
    //sync_out.println("Verifying that PostBlocks() with end index smaller than the start index does nothing...");
    {
        std::atomic<std::size_t> count = 0;
        const std::pair<std::int64_t, std::int64_t> indices = random_pair(-range, range);
        //sync_out.println("Range: ", indices.second, " to ", indices.first);
        pool.PostBlocks(indices.second, indices.first,
            [&count](const std::int64_t, const std::int64_t)
            {
                ++count;
            });
        pool.Wait();
        check(count == 0);
    }
    //sync_out.println("Verifying that SubmitBlocks() with end index smaller than the start index does nothing...");
    {
        std::atomic<std::size_t> count = 0;
        const std::pair<std::int64_t, std::int64_t> indices = random_pair(-range, range);
        //sync_out.println("Range: ", indices.second, " to ", indices.first);
        pool.SubmitBlocks(indices.second, indices.first,
                [&count](const std::int64_t, const std::int64_t)
                {
                    ++count;
                })
            .wait();
        check(count == 0);
    }
    //sync_out.println("Trying PostBlocks() with a number of tasks larger than the number of indices:");
    {
        const std::int64_t start = random(-range, range);
        check(check_blocks_no_return(pool, start, start + random<std::int64_t>(0, static_cast<std::int64_t>(pool.GetThreadCount() * 2)), random<std::size_t>(pool.GetThreadCount() * 2, pool.GetThreadCount() * 4), "PostBlocks()"));
    }
    //sync_out.println("Trying SubmitBlocks() with a number of tasks larger than the number of indices:");
    {
        const std::int64_t start = random(-range, range);
        check(check_blocks_no_return(pool, start, start + random<std::int64_t>(0, static_cast<std::int64_t>(pool.GetThreadCount() * 2)), random<std::size_t>(pool.GetThreadCount() * 2, pool.GetThreadCount() * 4), "SubmitBlocks()"));
    }
}

// ============================================
// Functions to verify sequence parallelization
// ============================================

//Check that PostSequence() or SubmitSequence() work for a specific range of indices, with no return value.
bool check_sequence_no_return(ThreadPool& pool, const std::int64_t random_start, const std::int64_t random_end, const std::string_view which_func)
{
    //sync_out.println("Verifying that ", which_func, " from ", random_start, " to ", random_end, " modifies all indices exactly once...");
    const std::size_t num_indices = static_cast<std::size_t>(random_end - random_start);
    std::vector<std::atomic<std::int64_t>> flags(num_indices);
    std::atomic<bool> indices_out_of_range = false;
    const auto sequence = [&flags, random_start, random_end, &indices_out_of_range](const std::int64_t index)
    {
        if (index < random_start || index > random_end)
            indices_out_of_range = true;
        else
            ++flags[static_cast<std::size_t>(index - random_start)];
    };
    if (which_func == "PostSequence()")
    {
        pool.PostSequence(random_start, random_end, sequence);
        pool.Wait();
    }
    else
    {
        pool.SubmitSequence(random_start, random_end, sequence).wait();
    }
    if (indices_out_of_range)
    {
        //sync_out.println("Error: Sequence indices out of range!");
        return false;
    }
    return all_flags_equal(flags, 1);
}

//Check that SubmitSequence() works for a specific range of indices, with a return value.
void check_sequence_return(ThreadPool& pool, const std::int64_t random_start, const std::int64_t random_end)
{
    //sync_out.println("Verifying that SubmitSequence() from ", random_start, " to ", random_end, " correctly sums all squares of indices...");
    const auto sequence = [](const std::int64_t index)
    {
        return index * index;
    };
    const std::vector<std::int64_t> sums_vector = pool.SubmitSequence(random_start, random_end, sequence).get();
    std::int64_t sum = 0;
    for (const std::int64_t partial_sum : sums_vector)
        sum += partial_sum;
    std::int64_t correct_sum = 0;
    for (std::int64_t i = random_start; i < random_end; i++)
        correct_sum += i * i;
    check(correct_sum, sum);
}

//Check that PostSequence() and SubmitSequence() work using several different random values for the range of indices.
qor_pp_test_suite_case(ThreadPoolTestSuite, sequenceWorks)
{
    constexpr std::int64_t range = 1000;
    constexpr std::size_t repeats = 10;
    ThreadPool pool;
    for (std::size_t i = 0; i < repeats; ++i)
    {
        const std::pair<std::int64_t, std::int64_t> indices = random_pair(-range, range);
        check(check_sequence_no_return(pool, indices.first, indices.second, "PostSequence()"));
    }
    for (std::size_t i = 0; i < repeats; ++i)
    {
        const std::pair<std::int64_t, std::int64_t> indices = random_pair(-range, range);
        check(check_sequence_no_return(pool, indices.first, indices.second, "SubmitSequence()"));
    }
    for (std::size_t i = 0; i < repeats; ++i)
    {
        const std::pair<std::int64_t, std::int64_t> indices = random_pair(-range, range);
        check_sequence_return(pool, indices.first, indices.second);
    }
    //sync_out.println("Verifying that PostSequence() with identical start and end indices does nothing...");
    {
        std::atomic<std::size_t> count = 0;
        const std::int64_t index = random(-range, range);
        //sync_out.println("Range: ", index, " to ", index);
        pool.PostSequence(index, index,
            [&count](const std::int64_t)
            {
                ++count;
            });
        pool.Wait();
        check(count == 0);
    }
    //sync_out.println("Verifying that SubmitSequence() with identical start and end indices does nothing...");
    {
        std::atomic<std::size_t> count = 0;
        const std::int64_t index = random(-range, range);
        //sync_out.println("Range: ", index, " to ", index);
        pool.SubmitSequence(index, index,
                [&count](const std::int64_t)
                {
                    ++count;
                })
            .wait();
        check(count == 0);
    }
    //sync_out.println("Verifying that PostSequence() with end index smaller than the start index does nothing...");
    {
        std::atomic<std::size_t> count = 0;
        const std::pair<std::int64_t, std::int64_t> indices = random_pair(-range, range);
        //sync_out.println("Range: ", indices.second, " to ", indices.first);
        pool.PostSequence(indices.second, indices.first,
            [&count](const std::int64_t)
            {
                ++count;
            });
        pool.Wait();
        check(count == 0);
    }
    //sync_out.println("Verifying that SubmitSequence() with end index smaller than the start index does nothing...");
    {
        std::atomic<std::size_t> count = 0;
        const std::pair<std::int64_t, std::int64_t> indices = random_pair(-range, range);
        //sync_out.println("Range: ", indices.second, " to ", indices.first);
        pool.SubmitSequence(indices.second, indices.first,
                [&count](const std::int64_t)
                {
                    ++count;
                })
            .wait();
        check(count == 0);
    }
}

// ===============================================
// Functions to verify task monitoring and control
// ===============================================

//Check that task monitoring works.
qor_pp_test_suite_case(ThreadPoolTestSuite, monitoringWorks)
{
    constexpr std::chrono::milliseconds sleep_time(300);
    const std::size_t num_threads = std::min<std::size_t>(std::thread::hardware_concurrency(), 4);
    //sync_out.println("Creating pool with ", num_threads, " threads.");
    ThreadPool pool(num_threads);
    //sync_out.println("Submitting ", num_threads * 3, " tasks.");
    counting_semaphore sem(0);
    for (std::size_t i = 0; i < num_threads * 3; ++i)
    {
        pool.PostTask(
            [i, &sem]
            {
                sem.acquire();
                //sync_out.println("Task ", i, " released.");
            });
    }
    std::this_thread::sleep_for(sleep_time);
    //sync_out.println("After submission, should have: ", num_threads * 3, " tasks total, ", num_threads, " tasks running, ", num_threads * 2, " tasks queued...");
    //sync_out.print("Result: ", pool.GetTotalCountOfTasks(), " tasks total, ", pool.GetCountOfTasksRunning(), " tasks running, ", pool.GetCountOfTasksQueued(), " tasks queued ");
    check(pool.GetTotalCountOfTasks() == num_threads * 3 && pool.GetCountOfTasksRunning() == num_threads && pool.GetCountOfTasksQueued() == num_threads * 2);
    sem.release(static_cast<std::ptrdiff_t>(num_threads));
    std::this_thread::sleep_for(sleep_time);
    //sync_out.println("After releasing ", num_threads, " tasks, should have: ", num_threads * 2, " tasks total, ", num_threads, " tasks running, ", num_threads, " tasks queued...");
    //sync_out.print("Result: ", pool.GetTotalCountOfTasks(), " tasks total, ", pool.GetCountOfTasksRunning(), " tasks running, ", pool.GetCountOfTasksQueued(), " tasks queued ");
    check(pool.GetTotalCountOfTasks() == num_threads * 2 && pool.GetCountOfTasksRunning() == num_threads && pool.GetCountOfTasksQueued() == num_threads);
    sem.release(static_cast<std::ptrdiff_t>(num_threads));
    std::this_thread::sleep_for(sleep_time);
    //sync_out.println("After releasing ", num_threads, " more tasks, should have: ", num_threads, " tasks total, ", num_threads, " tasks running, ", 0, " tasks queued...");
    //sync_out.print("Result: ", pool.GetTotalCountOfTasks(), " tasks total, ", pool.GetCountOfTasksRunning(), " tasks running, ", pool.GetCountOfTasksQueued(), " tasks queued ");
    check(pool.GetTotalCountOfTasks() == num_threads && pool.GetCountOfTasksRunning() == num_threads && pool.GetCountOfTasksQueued() == 0);
    sem.release(static_cast<std::ptrdiff_t>(num_threads));
    std::this_thread::sleep_for(sleep_time);
    //sync_out.println("After releasing the final ", num_threads, " tasks, should have: ", 0, " tasks total, ", 0, " tasks running, ", 0, " tasks queued...");
    //sync_out.print("Result: ", pool.GetTotalCountOfTasks(), " tasks total, ", pool.GetCountOfTasksRunning(), " tasks running, ", pool.GetCountOfTasksQueued(), " tasks queued ");
    check(pool.GetTotalCountOfTasks() == 0 && pool.GetCountOfTasksRunning() == 0 && pool.GetCountOfTasksQueued() == 0);
}

//Check that pausing works.
qor_pp_test_suite_case(ThreadPoolTestSuite, pausingWorks)
{
    constexpr std::chrono::milliseconds sleep_time(200);
    ThreadPool pool;
    //sync_out.println("Checking that the pool correctly reports that it is not paused after construction...");
    check(!pool.IsPaused());
    //sync_out.println("Pausing pool.");
    pool.Pause();
    //sync_out.println("Checking that the pool correctly reports that it is paused...");
    check(pool.IsPaused());
    //sync_out.println("Submitting task and waiting.");
    std::atomic<bool> flag = false;
    pool.PostTask(
        [&flag]
        {
            flag = true;
            //sync_out.println("Task executed.");
        });
    std::this_thread::sleep_for(sleep_time);
    //sync_out.println("Verifying that the task has not been executed...");
    check(!flag);
    //sync_out.println("Unpausing pool and waiting.");
    pool.Unpause();
    std::this_thread::sleep_for(sleep_time);
    //sync_out.println("Verifying that the task has been executed...");
    check(flag);
    //sync_out.println("Checking that the pool correctly reports that it is not paused...");
    check(!pool.IsPaused());
}

//Check that Purge() works.
qor_pp_test_suite_case(ThreadPoolTestSuite, purgingWorks)
{
    constexpr std::chrono::milliseconds long_sleep_time(200);
    constexpr std::chrono::milliseconds short_sleep_time(100);
    constexpr std::size_t num_tasks = 10;
    ThreadPool pool(1);
    //sync_out.println("Submitting ", num_tasks, " tasks to the pool.");
    std::vector<std::atomic<bool>> flags(num_tasks);
    for (std::size_t i = 0; i < num_tasks; ++i)
    {
        pool.PostTask(
            [&flags, i, long_sleep_time]
            {
                std::this_thread::sleep_for(long_sleep_time);
                //sync_out.println("Task ", i, " done.");
                flags[i] = true;
            });
    }
    std::this_thread::sleep_for(short_sleep_time);
    //sync_out.println("Purging the pool and waiting for tasks...");
    pool.Purge();
    pool.Wait();
    //sync_out.println("Checking that only the first task was executed...");
    flags[0] = !flags[0];
    check(no_flags_set(flags));
}

#ifdef __cpp_exceptions
// ======================================
// Functions to verify exception handling
// ======================================

//An exception class to be thrown when testing exception handling.
struct test_exception : public std::runtime_error
{
    test_exception() : std::runtime_error("Exception thrown!") {};
};

//A function that throws a `test_exception`.
void throws()
{
    //sync_out.println("Throwing exception...");
    throw test_exception();
};

//Check that exceptions are forwarded correctly by SubmitTask().
qor_pp_test_suite_case(ThreadPoolTestSuite, checkExceptionsAreForwardedCorrectly)
{
    ThreadPool pool;
    //sync_out.println("Checking that exceptions are forwarded correctly by SubmitTask()...");
    bool caught = false;
    std::future<void> future = pool.SubmitTask(throws);
    try
    {
        future.get();
    }
    catch (const test_exception&)
    {
        caught = true;
    }
    check(caught);
}

//Check that exceptions are forwarded correctly by `multi_future`.
qor_pp_test_suite_case(ThreadPoolTestSuite, checkExceptionsAreForwardedCorrectlyByMultiFuture)
{
    ThreadPool pool;
    //sync_out.println("Checking that exceptions are forwarded correctly by multi_future...");
    bool caught = false;
    multi_future<void> future;
    future.push_back(pool.SubmitTask(throws));
    future.push_back(pool.SubmitTask(throws));
    try
    {
        future.get();
    }
    catch (const test_exception&)
    {
        caught = true;
    }
    check(caught);
}
#endif

// =====================================
// Functions to verify vector operations
// =====================================

//Check that parallelized vector operations work as expected by calculating the sum of two randomized vectors of a specific size in two ways, single-threaded and multithreaded, and comparing the results.
bool check_vector_of_size(ThreadPool& pool, const std::size_t vector_size, const std::size_t num_tasks)
{
    constexpr std::int64_t value_range = 1000000;
    std::vector<std::int64_t> vector_1(vector_size);
    std::vector<std::int64_t> vector_2(vector_size);
    for (std::size_t i = 0; i < vector_size; ++i)
    {
        vector_1[i] = random(-value_range, value_range);
        vector_2[i] = random(-value_range, value_range);
    }
    //sync_out.println("Adding two vectors with ", vector_size, " elements using ", num_tasks, " tasks...");
    std::vector<std::int64_t> sum_single(vector_size);
    for (std::size_t i = 0; i < vector_size; ++i)
        sum_single[i] = vector_1[i] + vector_2[i];
    std::vector<std::int64_t> sum_multi(vector_size);
    pool.SubmitBlocks(
            0, vector_size,
            [&sum_multi, &vector_1, &vector_2](const std::size_t start, const std::size_t end)
            {
                for (std::size_t i = start; i < end; ++i)
                    sum_multi[i] = vector_1[i] + vector_2[i];
            },
            num_tasks)
        .wait();
    for (std::size_t i = 0; i < vector_size; ++i)
    {
        if (sum_single[i] != sum_multi[i])
            return false;
    }
    return true;
}

//Check that parallelized vector operations work as expected.
qor_pp_test_suite_case(ThreadPoolTestSuite, vectorsWork)
{
    constexpr std::size_t size_range = 1000000;
    constexpr std::size_t repeats = 10;
    ThreadPool pool;
    for (std::size_t i = 0; i < repeats; ++i)
        check(check_vector_of_size(pool, random<std::size_t>(0, size_range), random<std::size_t>(1, pool.GetThreadCount())));
}

// =================================
// Functions to verify task priority
// =================================

// Priorities are 8-bit integers, but `std::uniform_int_distribution` needs at least a 16-bit integer.
using rand_priority_t = std::int16_t;

//Check that task priority works as expected with all task submission methods.
qor_pp_test_suite_case(ThreadPoolTestSuite, priorityWorks)
{
    constexpr std::chrono::milliseconds sleep_time(200);
    constexpr std::size_t num_tasks = 10;
    // Set the pool to have only 1 thread, so it can only run 1 task at a time. This will ensure the tasks will be executed in priority order.
    ThreadPool pool(1);
    pool.Pause();

    // Create a shuffled lists of priorities.
    std::vector<priority_t> priorities;
    priorities.reserve(num_tasks - 1);
    for (std::size_t i = 0; i < num_tasks - 1; ++i)
        priorities.push_back(static_cast<priority_t>((i % 2 == 0) ? random<rand_priority_t>(0, pr::highest) : random<rand_priority_t>(pr::lowest, 0)));
    priorities.push_back(pr::lowest);
    priorities.push_back(0);
    priorities.push_back(pr::highest);
    std::shuffle(priorities.begin(), priorities.end(), std::mt19937_64(std::random_device()()));

    // Submit tasks using various methods in random priority order.
    std::vector<priority_t> execution_order;
    std::mutex exec_mutex;
    const auto execute_task_priority = [&execution_order, &exec_mutex](const priority_t priority)
    {
        const std::scoped_lock lock(exec_mutex);
        std::cout << "Task with priority " << static_cast<rand_priority_t>(priority) << " executed.\n" ;
        execution_order.push_back(priority);
    };
    const std::vector<std::string_view> functions = {"PostTask", "SubmitTask", "PostSequence", "SubmitSequence", "PostLoop", "SubmitLoop", "PostBlocks", "SubmitBlocks"};
    for (const priority_t priority : priorities)
    {
        const std::string_view func = functions[random<std::size_t>(0, functions.size() - 1)];
        //sync_out.println("Launching ", func, "() with priority ", static_cast<rand_priority_t>(priority), "...");
        if (func == "PostTask")
        {
            pool.PostTask(
                [priority, &execute_task_priority]
                {
                    execute_task_priority(priority);
                },
                priority);
        }
        else if (func == "SubmitTask")
        {
            std::ignore = pool.SubmitTask(
                [priority, &execute_task_priority]
                {
                    execute_task_priority(priority);
                },
                priority);
        }
        else if (func == "PostSequence")
        {
            pool.PostSequence(
                0, 1,
                [priority, &execute_task_priority](std::int64_t)
                {
                    execute_task_priority(priority);
                },
                priority);
        }
        else if (func == "SubmitSequence")
        {
            std::ignore = pool.SubmitSequence(
                0, 1,
                [priority, &execute_task_priority](std::int64_t)
                {
                    execute_task_priority(priority);
                },
                priority);
        }
        else if (func == "PostLoop")
        {
            pool.PostLoop(
                0, 1,
                [priority, &execute_task_priority](std::int64_t)
                {
                    execute_task_priority(priority);
                },
                0, priority);
        }
        else if (func == "SubmitLoop")
        {
            std::ignore = pool.SubmitLoop(
                0, 1,
                [priority, &execute_task_priority](std::int64_t)
                {
                    execute_task_priority(priority);
                },
                0, priority);
        }
        else if (func == "PostBlocks")
        {
            pool.PostBlocks(
                0, 1,
                [priority, &execute_task_priority](std::int64_t, std::int64_t)
                {
                    execute_task_priority(priority);
                },
                0, priority);
        }
        else if (func == "SubmitBlocks")
        {
            std::ignore = pool.SubmitBlocks(
                0, 1,
                [priority, &execute_task_priority](std::int64_t, std::int64_t)
                {
                    execute_task_priority(priority);
                },
                0, priority);
        }
    }

    // Unpause the pool so the tasks can be executed, then check that they were executed in the correct order.
    //sync_out.println("Checking execution order...");
    std::this_thread::sleep_for(sleep_time);
    pool.Unpause();
    pool.Wait();
    std::sort(priorities.rbegin(), priorities.rend());
    check(execution_order == priorities);
}

// =======================================================================
// Functions to verify thread initialization, cleanup, and this_thread
// =======================================================================

//Check that thread initialization functions and get_index() work.
qor_pp_test_suite_case(ThreadPoolTestSuite, initAndIndexWork)
{
    //sync_out.println("Comparing thread indices reported by get_index() using an initialization function passed to reset():");
    std::vector<std::atomic<std::size_t>> thread_indices(std::max(1u,std::thread::hardware_concurrency() - 1));
    std::atomic<bool> correct = true;
    ThreadPool pool(std::max(1u,std::thread::hardware_concurrency() - 1));
    pool.Reset(
        [&thread_indices, &correct](std::size_t idx)
        {
            const std::optional<std::size_t> reported_idx = CurrentThread::GetCurrent().GetPoolIndex();
            if (reported_idx.has_value())
                thread_indices[idx] = reported_idx.value();
            else
                correct = false;
        });
    pool.Wait();
    //sync_out.println("Checking that all reported indices have values...");
    check(correct);
    correct = true;
    for (std::size_t i = 0; i < thread_indices.size(); ++i)
    {
        if (thread_indices[i] != i)
        {
            correct = false;
            break;
        }
    }
    //sync_out.println("Checking that all reported indices are correct...");
    check(correct);

    //sync_out.println("Verifying that the index of the main thread has no value...");
    const std::optional<std::size_t> main_idx = CurrentThread::GetCurrent().GetPoolIndex();
    check(!main_idx.has_value());

    //sync_out.println("Verifying that the index of an independent thread has no value...");
    std::thread test_thread(
        []
        {
            const std::optional<std::size_t> ind_idx = CurrentThread::GetCurrent().GetPoolIndex();
            check(!ind_idx.has_value());
        });
    test_thread.join();
}

//Check that thread cleanup functions work.
qor_pp_test_suite_case(ThreadPoolTestSuite, cleanupWorks)
{
    //sync_out.println("Comparing thread indices reported by get_index() using a cleanup function passed to SetCleanupFunction():");
    std::vector<std::atomic<std::size_t>> thread_indices(std::thread::hardware_concurrency()/2);
    std::atomic<bool> correct = true;
    {
        ThreadPool pool(std::thread::hardware_concurrency()/2);
        pool.SetCleanupFunction(
            [&thread_indices, &correct](std::size_t idx)
            {
                const std::optional<std::size_t> reported_idx = CurrentThread::GetCurrent().GetPoolIndex();
                if (reported_idx.has_value())
                    thread_indices[idx] = reported_idx.value();
                else
                    correct = false;
            });
    }
    //sync_out.println("Checking that all reported indices have values...");
    check(correct);
    correct = true;
    for (std::size_t i = 0; i < thread_indices.size(); ++i)
    {
        if (thread_indices[i] != i)
        {
            correct = false;
            break;
        }
    }
    //sync_out.println("Checking that all reported indices are correct...");
    check(correct);
}

//Check that get_pool() works.
qor_pp_test_suite_case(ThreadPoolTestSuite, GetPoolWorks)
{
    //sync_out.println("Checking that all threads report the correct pool...");
    std::vector<std::atomic<void*>> thread_pool_ptrs1(std::thread::hardware_concurrency()/2);
    std::vector<std::atomic<void*>> thread_pool_ptrs2(std::thread::hardware_concurrency()/2);
    const auto store_pointers = [](std::vector<std::atomic<void*>>& ptrs)
    {
        const auto ptr = CurrentThread::GetCurrent().GetPool();
        if (ptr.has_value())
            ptrs[*CurrentThread::GetCurrent().GetPoolIndex()] = *ptr;
        else
            check(false);
    };
    ThreadPool pool1( std::thread::hardware_concurrency()/2,
        [&thread_pool_ptrs1, &store_pointers]
        {
            store_pointers(thread_pool_ptrs1);
        });
    ThreadPool pool2( std::thread::hardware_concurrency()/2,
        [&thread_pool_ptrs2, &store_pointers]
        {
            store_pointers(thread_pool_ptrs2);
        });
    pool1.Wait();
    pool2.Wait();
    const auto check_pointers = [](const std::vector<std::atomic<void*>>& ptrs, const ThreadPool& pool)
    {
        check(all_flags_equal(ptrs, (void*)&pool));
    };
    check_pointers(thread_pool_ptrs1, pool1);
    check_pointers(thread_pool_ptrs2, pool2);
    {
        //sync_out.println("Verifying that the pool pointer of the main thread has no value...");
        const auto ptr = CurrentThread::GetCurrent().GetPool();
        check(!ptr.has_value());
    }
    {
        //sync_out.println("Verifying that the pool pointer of an independent thread has no value...");
        std::thread test_thread(
            []
            {
                const auto ptr = CurrentThread::GetCurrent().GetPool();
                check(!ptr.has_value());
            });
        test_thread.join();
    }
}

// =========================================================
// Functions to verify proper handling of parallelized tasks
// =========================================================

// A class used to count how many times the copy and move constructors have been invoked since the creation of the initial object.
class [[nodiscard]] count_copy_move
{
public:
    count_copy_move(std::atomic<std::size_t>* copied_, std::atomic<std::size_t>* moved_) : copied(copied_), moved(moved_) {}

    count_copy_move(const count_copy_move& other) : copied(other.copied), moved(other.moved)
    {
        ++(*copied);
    }

    count_copy_move(count_copy_move&& other) noexcept : copied(other.copied), moved(other.moved)
    {
        ++(*moved);
    }

    count_copy_move& operator=(const count_copy_move&) = delete;
    count_copy_move& operator=(count_copy_move&&) = delete;
    ~count_copy_move() = default;

private:
    std::atomic<std::size_t>* copied = nullptr;
    std::atomic<std::size_t>* moved = nullptr;
}; 

//Check, for a specific member function which parallelizes loops or sequences of tasks, that the callable object does not get copied in the process.
void check_copy(const std::string_view which_func)
{
    ThreadPool pool;
    const std::size_t num_tasks = pool.GetThreadCount() * 10;
    //sync_out.println("Checking ", which_func, "...");
    std::atomic<std::size_t> copied = 0;
    std::atomic<std::size_t> moved = 0;
    auto task = [detect = count_copy_move(&copied, &moved)](auto&&...) {};
    if (which_func == "PostBlocks()")
        pool.PostBlocks(0, num_tasks, std::move(task), num_tasks);
    else if (which_func == "PostLoop()")
        pool.PostLoop(0, num_tasks, std::move(task));
    else if (which_func == "PostSequence()")
        pool.PostSequence(0, num_tasks, std::move(task));
    else if (which_func == "SubmitBlocks()")
        std::ignore = pool.SubmitBlocks(0, num_tasks, std::move(task), num_tasks);
    else if (which_func == "SubmitLoop()")
        std::ignore = pool.SubmitLoop(0, num_tasks, std::move(task));
    else if (which_func == "SubmitSequence()")
        std::ignore = pool.SubmitSequence(0, num_tasks, std::move(task));
    pool.Wait();
    //sync_out.println("Copy count: ");
    check(0, copied.load()); // Note: Move count will be unpredictable if priority is on, so we don't check it.
}

// Check, for all member functions which parallelize loops or sequences of tasks, that the callable object does not get copied in the process.
qor_pp_test_suite_case(ThreadPoolTestSuite, CopyAllWorks)
{
    check_copy("PostBlocks()");
    check_copy("PostLoop()");
    check_copy("PostSequence()");
    check_copy("SubmitBlocks()");
    check_copy("SubmitLoop()");
    check_copy("SubmitSequence()");
}

// A class used to detect if an object was destructed prematurely.
class detect_destruct
{
public:
    explicit detect_destruct(std::atomic<bool>* object_exists_) : object_exists(object_exists_)
    {
        *object_exists = true;
    };

    detect_destruct(const detect_destruct&) = delete;
    detect_destruct(detect_destruct&&) noexcept = delete;
    detect_destruct& operator=(const detect_destruct&) = delete;
    detect_destruct& operator=(detect_destruct&&) = delete;

    ~detect_destruct()
    {
        *object_exists = false;
    };

private:
    std::atomic<bool>* object_exists = nullptr;
};

//Check, for a specific member function which parallelizes loops or sequences of tasks, that if a task that captures a shared pointer is submitted, the pointer is correctly shared between all the iterations of the task.
void check_shared_ptr(const std::string_view which_func)
{
    ThreadPool pool;
    constexpr std::chrono::milliseconds sleep_time(10);
    const std::size_t num_tasks = pool.GetThreadCount() * 10;
    std::atomic<bool> object_exists = false;
    std::atomic<std::size_t> uses_before_destruct = 0;
    std::atomic<std::size_t> uses_after_destruct = 0;
    //sync_out.println("Checking ", which_func, "...");
    {
        std::shared_ptr<detect_destruct> ptr = std::make_shared<detect_destruct>(&object_exists);
        auto task = [ptr, &object_exists, &uses_before_destruct, &uses_after_destruct, &sleep_time](auto&&...)
        {
            std::this_thread::sleep_for(sleep_time);
            if (object_exists)
                ++uses_before_destruct;
            else
                ++uses_after_destruct;
        };
        if (which_func == "PostBlocks()")
            pool.PostBlocks(0, num_tasks, std::move(task), num_tasks);
        else if (which_func == "PostLoop()")
            pool.PostLoop(0, num_tasks, std::move(task));
        else if (which_func == "PostSequence()")
            pool.PostSequence(0, num_tasks, std::move(task));
        else if (which_func == "SubmitBlocks()")
            std::ignore = pool.SubmitBlocks(0, num_tasks, std::move(task), num_tasks);
        else if (which_func == "SubmitLoop()")
            std::ignore = pool.SubmitLoop(0, num_tasks, std::move(task));
        else if (which_func == "SubmitSequence()")
            std::ignore = pool.SubmitSequence(0, num_tasks, std::move(task));
        ptr.reset();
    }
    pool.Wait();
    std::this_thread::sleep_for(sleep_time);
    //sync_out.println("Uses before destruct:");
    check(num_tasks, uses_before_destruct.load());
    //sync_out.println("Uses after destruct:");
    check(0, uses_after_destruct.load());
}

// Check, for all member functions which parallelize loops or sequences of tasks, that if a task that captures a shared pointer is submitted, the pointer is correctly shared between all the iterations of the task.
qor_pp_test_suite_case(ThreadPoolTestSuite, SharedPtrAllWorks)
{
    check_shared_ptr("PostBlocks()");
    check_shared_ptr("PostLoop()");
    check_shared_ptr("PostSequence()");
    check_shared_ptr("SubmitBlocks()");
    check_shared_ptr("SubmitLoop()");
    check_shared_ptr("SubmitSequence()");
}

// Check that a task is destructed immediately after it executes, and therefore does not artificially extend the lifetime of any captured objects.
qor_pp_test_suite_case(ThreadPoolTestSuite, TaskDestructionWorks)
{
    constexpr std::chrono::milliseconds sleep_time(20);
    ThreadPool pool;
    std::atomic<bool> object_exists = false;
    {
        const std::shared_ptr<detect_destruct> ptr = std::make_shared<detect_destruct>(&object_exists);
        pool.SubmitTask([ptr] {}).wait();
    }
    std::this_thread::sleep_for(sleep_time);
    check(!object_exists);
}

// Check that the type trait `common_index_type` works as expected.
qor_pp_test_suite_case(ThreadPoolTestSuite, CommonIndexTypeWorks)
{
    //sync_out.println("Checking std::int8_t...");
    check(std::is_same_v<common_index_type_t<std::int8_t, std::int8_t>, std::int8_t> && std::is_same_v<common_index_type_t<std::int8_t, std::int16_t>, std::int16_t> && std::is_same_v<common_index_type_t<std::int8_t, std::int32_t>, std::int32_t> && std::is_same_v<common_index_type_t<std::int8_t, std::int64_t>, std::int64_t> && std::is_same_v<common_index_type_t<std::int8_t, std::uint8_t>, std::int16_t> && std::is_same_v<common_index_type_t<std::int8_t, std::uint16_t>, std::int32_t> && std::is_same_v<common_index_type_t<std::int8_t, std::uint32_t>, std::int64_t> && std::is_same_v<common_index_type_t<std::int8_t, std::uint64_t>, std::uint64_t>);
    //sync_out.println("Checking std::int16_t...");
    check(std::is_same_v<common_index_type_t<std::int16_t, std::int8_t>, std::int16_t> && std::is_same_v<common_index_type_t<std::int16_t, std::int16_t>, std::int16_t> && std::is_same_v<common_index_type_t<std::int16_t, std::int32_t>, std::int32_t> && std::is_same_v<common_index_type_t<std::int16_t, std::int64_t>, std::int64_t> && std::is_same_v<common_index_type_t<std::int16_t, std::uint8_t>, std::int16_t> && std::is_same_v<common_index_type_t<std::int16_t, std::uint16_t>, std::int32_t> && std::is_same_v<common_index_type_t<std::int16_t, std::uint32_t>, std::int64_t> && std::is_same_v<common_index_type_t<std::int16_t, std::uint64_t>, std::uint64_t>);
    //sync_out.println("Checking std::int32_t...");
    check(std::is_same_v<common_index_type_t<std::int32_t, std::int8_t>, std::int32_t> && std::is_same_v<common_index_type_t<std::int32_t, std::int16_t>, std::int32_t> && std::is_same_v<common_index_type_t<std::int32_t, std::int32_t>, std::int32_t> && std::is_same_v<common_index_type_t<std::int32_t, std::int64_t>, std::int64_t> && std::is_same_v<common_index_type_t<std::int32_t, std::uint8_t>, std::int32_t> && std::is_same_v<common_index_type_t<std::int32_t, std::uint16_t>, std::int32_t> && std::is_same_v<common_index_type_t<std::int32_t, std::uint32_t>, std::int64_t> && std::is_same_v<common_index_type_t<std::int32_t, std::uint64_t>, std::uint64_t>);
    //sync_out.println("Checking std::int64_t...");
    check(std::is_same_v<common_index_type_t<std::int64_t, std::int8_t>, std::int64_t> && std::is_same_v<common_index_type_t<std::int64_t, std::int16_t>, std::int64_t> && std::is_same_v<common_index_type_t<std::int64_t, std::int32_t>, std::int64_t> && std::is_same_v<common_index_type_t<std::int64_t, std::int64_t>, std::int64_t> && std::is_same_v<common_index_type_t<std::int64_t, std::uint8_t>, std::int64_t> && std::is_same_v<common_index_type_t<std::int64_t, std::uint16_t>, std::int64_t> && std::is_same_v<common_index_type_t<std::int64_t, std::uint32_t>, std::int64_t> && std::is_same_v<common_index_type_t<std::int64_t, std::uint64_t>, std::uint64_t>);
    //sync_out.println("Checking std::uint8_t...");
    check(std::is_same_v<common_index_type_t<std::uint8_t, std::int8_t>, std::int16_t> && std::is_same_v<common_index_type_t<std::uint8_t, std::int16_t>, std::int16_t> && std::is_same_v<common_index_type_t<std::uint8_t, std::int32_t>, std::int32_t> && std::is_same_v<common_index_type_t<std::uint8_t, std::int64_t>, std::int64_t> && std::is_same_v<common_index_type_t<std::uint8_t, std::uint8_t>, std::uint8_t> && std::is_same_v<common_index_type_t<std::uint8_t, std::uint16_t>, std::uint16_t> && std::is_same_v<common_index_type_t<std::uint8_t, std::uint32_t>, std::uint32_t> && std::is_same_v<common_index_type_t<std::uint8_t, std::uint64_t>, std::uint64_t>);
    //sync_out.println("Checking std::uint16_t...");
    check(std::is_same_v<common_index_type_t<std::uint16_t, std::int8_t>, std::int32_t> && std::is_same_v<common_index_type_t<std::uint16_t, std::int16_t>, std::int32_t> && std::is_same_v<common_index_type_t<std::uint16_t, std::int32_t>, std::int32_t> && std::is_same_v<common_index_type_t<std::uint16_t, std::int64_t>, std::int64_t> && std::is_same_v<common_index_type_t<std::uint16_t, std::uint8_t>, std::uint16_t> && std::is_same_v<common_index_type_t<std::uint16_t, std::uint16_t>, std::uint16_t> && std::is_same_v<common_index_type_t<std::uint16_t, std::uint32_t>, std::uint32_t> && std::is_same_v<common_index_type_t<std::uint16_t, std::uint64_t>, std::uint64_t>);
    //sync_out.println("Checking std::uint32_t...");
    check(std::is_same_v<common_index_type_t<std::uint32_t, std::int8_t>, std::int64_t> && std::is_same_v<common_index_type_t<std::uint32_t, std::int16_t>, std::int64_t> && std::is_same_v<common_index_type_t<std::uint32_t, std::int32_t>, std::int64_t> && std::is_same_v<common_index_type_t<std::uint32_t, std::int64_t>, std::int64_t> && std::is_same_v<common_index_type_t<std::uint32_t, std::uint8_t>, std::uint32_t> && std::is_same_v<common_index_type_t<std::uint32_t, std::uint16_t>, std::uint32_t> && std::is_same_v<common_index_type_t<std::uint32_t, std::uint32_t>, std::uint32_t> && std::is_same_v<common_index_type_t<std::uint32_t, std::uint64_t>, std::uint64_t>);
    //sync_out.println("Checking std::uint64_t...");
    check(std::is_same_v<common_index_type_t<std::uint64_t, std::int8_t>, std::uint64_t> && std::is_same_v<common_index_type_t<std::uint64_t, std::int16_t>, std::uint64_t> && std::is_same_v<common_index_type_t<std::uint64_t, std::int32_t>, std::uint64_t> && std::is_same_v<common_index_type_t<std::uint64_t, std::int64_t>, std::uint64_t> && std::is_same_v<common_index_type_t<std::uint64_t, std::uint8_t>, std::uint64_t> && std::is_same_v<common_index_type_t<std::uint64_t, std::uint16_t>, std::uint64_t> && std::is_same_v<common_index_type_t<std::uint64_t, std::uint32_t>, std::uint64_t> && std::is_same_v<common_index_type_t<std::uint64_t, std::uint64_t>, std::uint64_t>);    
}

// ================================
// Functions to check for deadlocks
// ================================

// An auxiliary thread pool used by check_deadlock(). It's a global variable so that the program will not get stuck upon destruction of this pool if a deadlock actually occurs.
ThreadPool check_deadlock_pool;

//Check that the specified function does not create deadlocks. The function will be run many times to increase the probability of encountering a deadlock as a result of subtle timing issues. Uses an auxiliary pool so the whole test doesn't get stuck if a deadlock is encountered.
template <typename F>
void check_deadlock(const F&& task)
{
    constexpr std::chrono::milliseconds sleep_time(200);
    constexpr std::size_t tries = 10000;
    std::size_t try_n = 0;
    check_deadlock_pool.PostTask(
        [&try_n, &task]
        {
            do
                task();
            while (++try_n < tries);
        });
    bool passed = false;
    while (true)
    {
        const std::size_t old_try_n = try_n;
        check_deadlock_pool.WaitFor(sleep_time);
        if (try_n == tries)
        {
            //sync_out.println("Successfully finished all tries!");
            passed = true;
            break;
        }
        if (try_n == old_try_n)
        {
            //sync_out.println("Error: deadlock detected!");
            passed = false;
            break;
        }
        //sync_out.println("Finished ", try_n, " tries out of ", tries, "...");
    }
    check(passed);
}

// ====================================
// Functions to check native extensions
// ====================================

// A map between pre-defined OS process priorities and their string representations.
const std::map<ICurrentProcess::Priority, std::string> os_process_priority_map = {{ICurrentProcess::Priority::idle, "idle"}, {ICurrentProcess::Priority::below_normal, "below_normal"}, {ICurrentProcess::Priority::normal, "normal"}, {ICurrentProcess::Priority::above_normal, "above_normal"}, {ICurrentProcess::Priority::high, "high"}, {ICurrentProcess::Priority::realtime, "realtime"}};

//Get the string representation of an OS process priority.
std::string os_process_priority_name(const std::optional<ICurrentProcess::Priority>& priority)
{
    if (priority.has_value())
    {
        const std::map<ICurrentProcess::Priority, std::string>::const_iterator it = os_process_priority_map.find(*priority);
        return (it != os_process_priority_map.end()) ? it->second : "unknown";
    }
    return "N/A";
}

//A map between pre-defined OS thread priorities and their string representations.
const std::map<ICurrentThread::Priority, std::string> os_thread_priority_map = {{ICurrentThread::Priority::idle, "idle"}, {ICurrentThread::Priority::lowest, "lowest"}, {ICurrentThread::Priority::below_normal, "below_normal"}, {ICurrentThread::Priority::normal, "normal"}, {ICurrentThread::Priority::above_normal, "above_normal"}, {ICurrentThread::Priority::highest, "highest"}, {ICurrentThread::Priority::realtime, "realtime"}};

//Get the string representation of an OS thread priority.
std::string os_thread_priority_name(const std::optional<ICurrentThread::Priority>& priority)
{
    if (priority.has_value())
    {
        const std::map<ICurrentThread::Priority, std::string>::const_iterator it = os_thread_priority_map.find(*priority);
        return (it != os_thread_priority_map.end()) ? it->second : "unknown";
    }
    return "N/A";
}

//Check if a condition is met, report the result, but do not keep count of the total number of successes and failures, because failure is expected if the test is not run as root.
void check_root(const bool condition)
{
    if (condition)
    {
        //sync_out.println("-> passed.");
        qor_pp_assert_that(true).isTrue();
    }
    else
    {
        //sync_out.println("-> failed, most likely due to insufficient permissions; ignoring.");
    }
}

//Check if the expected result has been obtained, report the result, but do not keep count of the total number of successes and failures, because failure is expected if the test is not run as root.
template <typename T1, typename T2>
void check_root(const T1& expected, const T2& obtained)
{
    //sync_out.print("- Expected: ", expected, ", obtained: ", obtained, ' ');
    check_root(expected == static_cast<T1>(obtained));
}

//Check that getting and setting OS process priorities works.
qor_pp_test_suite_case(ThreadPoolTestSuite, checkOSProcessPriorities)
{
    //sync_out.println("Checking OS process priorities...");
    //sync_out.println("NOTE: This test must be run as admin/root, otherwise it will fail!");
    // We go over the priorities in reverse order because on Linux, a non-root user can only decrease the priority, so if we start from the lowest priority, all tests will fail except the first one.
    const std::vector<ICurrentProcess::Priority> priorities = {/*ICurrentProcess::Priority::realtime,*/ ICurrentProcess::Priority::high, ICurrentProcess::Priority::above_normal, ICurrentProcess::Priority::normal, ICurrentProcess::Priority::below_normal, ICurrentProcess::Priority::idle};
    for (ICurrentProcess::Priority priority : priorities)
    {
        //sync_out.print("Setting OS process priority to ", os_process_priority_name(priority), ' ');
        // On Windows we should be able to set all the priorities even as non-admin; realtime will "succeed" but actually set the priority to high. On Linux, only root can increase the priority beyond normal.
    #ifdef _WIN32
        check(new_ref<ICurrentProcess>()().SetPriority(priority));
    #else
        if (priority >= ICurrentProcess::Priority::normal)
            check(new_ref<ICurrentProcess>()().SetPriority(priority));
        else
            check_root(new_ref<ICurrentProcess>()().SetPriority(priority));
    #endif
        const std::optional<ICurrentProcess::Priority> new_priority = new_ref<ICurrentProcess>()().GetPriority();
        //sync_out.print("Obtaining new OS process priority ");
        check(new_priority.has_value());
    #ifdef _WIN32
        if (priority != ICurrentProcess::Priority::realtime)
            check(os_process_priority_name(priority), os_process_priority_name(new_priority));
        else
            check_root(os_process_priority_name(priority), os_process_priority_name(new_priority));
    #else
        if (priority >= ICurrentProcess::Priority::normal)
            check(os_process_priority_name(priority), os_process_priority_name(new_priority));
        else
            check_root(os_process_priority_name(priority), os_process_priority_name(new_priority));
    #endif
    }
    // Set the priority back to normal after the test ends. This will fail on Linux if not root.
    //sync_out.println("Setting priority back to normal...");
    #ifdef _WIN32
    check(new_ref<ICurrentProcess>()().SetPriority(ICurrentProcess::Priority::normal));
    #else
    check_root(new_ref<ICurrentProcess>()().SetPriority(ICurrentProcess::Priority::normal));
    #endif
}

//Check that getting and setting OS thread priorities works.
qor_pp_test_suite_case(ThreadPoolTestSuite, checkOSThreadPriorities)
{
    ThreadPool pool;
    pool.PostTask(
        []
        {
            //sync_out.println("Checking OS thread priorities for pool threads...");
    #ifdef __linux__
            //sync_out.println("NOTE: On Linux, this test must be run as root, otherwise it will fail!");
    #endif
            const std::vector<ICurrentThread::Priority> priorities = {ICurrentThread::Priority::realtime, ICurrentThread::Priority::highest, ICurrentThread::Priority::above_normal, ICurrentThread::Priority::normal, ICurrentThread::Priority::below_normal, ICurrentThread::Priority::lowest, ICurrentThread::Priority::idle};
            for (ICurrentThread::Priority priority : priorities)
            {
                //sync_out.print("Setting OS thread priority to ", os_thread_priority_name(priority), ' ');
            // On Windows we should be able to set all the priorities even as non-admin, including realtime. On Linux, only root can increase the priority beyond normal. (Also, note that on WSL, even root cannot set the priority to highest or above.)
    #ifdef _WIN32
                check(CurrentThread::GetCurrent().SetPriority(priority));
    #else
                if (priority <= ICurrentThread::Priority::normal)
                    check(CurrentThread::GetCurrent().SetPriority(priority));
                else
                    check_root(CurrentThread::GetCurrent().SetPriority(priority));
    #endif
                const std::optional<ICurrentThread::Priority> new_priority = CurrentThread::GetCurrent().GetPriority();
                //sync_out.print("Obtaining new OS thread priority ");
                check(new_priority.has_value());
    #ifdef _WIN32
                check(os_thread_priority_name(priority), os_thread_priority_name(new_priority));
    #else
                check_root(os_thread_priority_name(priority), os_thread_priority_name(new_priority));
    #endif
            }
            // Set the priority back to normal after the test ends. This will fail on Linux/macOS if not running as root.
            //sync_out.println("Setting priority back to normal...");
    #ifdef _WIN32
            check(CurrentThread::GetCurrent().SetPriority(ICurrentThread::Priority::normal));
    #else
            check_root(CurrentThread::GetCurrent().SetPriority(ICurrentThread::Priority::normal));
    #endif
        });
}

//Check that getting and setting OS thread names works.
qor_pp_test_suite_case(ThreadPoolTestSuite, checkOSThreadNames)
{
    //sync_out.println("Checking OS thread names...");
    const std::string name = "ThreadPool";
    //sync_out.println("Setting main thread name to \"", name, "\"...");
    check(CurrentThread::GetCurrent().SetName(name));
    //sync_out.println("Obtaining new OS thread name...");
    std::optional<std::string> new_name = CurrentThread::GetCurrent().GetName();
    if (new_name.has_value())
    {
        check(true);
        check(name, *new_name);
    }
    else
    {
        check(false);
    }
}

//Convert a `std::vector<bool>` representing CPU affinity to a string of 0s and 1s.
std::string affinity_to_string(const std::optional<std::vector<bool>>& affinity)
{
    if (affinity.has_value())
    {
        const std::size_t num_bits = affinity->size();
        std::string str(num_bits, ' ');
        for (std::size_t i = 0; i < num_bits; ++i)
            str[num_bits - i - 1] = (*affinity)[i] ? '1' : '0';
        return str;
    }
    return "N/A";
}

//Check that getting and setting OS process affinity works.
qor_pp_test_suite_case(ThreadPoolTestSuite, checkOSProcessAffinity)
{
    //sync_out.println("Checking OS process affinity...");

    //sync_out.print("Obtaining initial process affinity ");
    const std::optional<std::vector<bool>> initial_affinity = new_ref<ICurrentProcess>()().GetAffinity();
    check(initial_affinity.has_value());
    //sync_out.println("Initial affinity is: ", affinity_to_string(initial_affinity));
    const std::size_t num_bits = initial_affinity.has_value() ? initial_affinity->size() : std::thread::hardware_concurrency();

    //sync_out.print("Setting affinity to CPU 1 only ");
    std::vector<bool> cpu_1_in(num_bits, false);
    cpu_1_in[0] = true;
    check(new_ref<ICurrentProcess>()().SetAffinity(cpu_1_in));
    //sync_out.print("Obtaining new affinity ");
    const std::optional<std::vector<bool>> cpu_1_out = new_ref<ICurrentProcess>()().GetAffinity();
    check(cpu_1_out.has_value());
    check(affinity_to_string(cpu_1_in), affinity_to_string(cpu_1_out));

    //sync_out.print("Setting affinity to alternating CPUs ");
    std::vector<bool> alternating_in(num_bits, false);
    for (std::size_t i = 0; i < num_bits; ++i)
        alternating_in[i] = (i % 2 == 1);
    check(new_ref<ICurrentProcess>()().SetAffinity(alternating_in));
    //sync_out.print("Obtaining new affinity ");
    const std::optional<std::vector<bool>> alternating_out = new_ref<ICurrentProcess>()().GetAffinity();
    check(alternating_out.has_value());
    check(affinity_to_string(alternating_in), affinity_to_string(alternating_out));

    if (initial_affinity.has_value())
    {
        //sync_out.print("Setting affinity back to initial value ");
        check(new_ref<ICurrentProcess>()().SetAffinity(*initial_affinity));
        //sync_out.print("Obtaining new affinity ");
        const std::optional<std::vector<bool>> initial_out = new_ref<ICurrentProcess>()().GetAffinity();
        check(initial_out.has_value());
        check(affinity_to_string(initial_affinity), affinity_to_string(initial_out));
    }
}

//Check that getting and setting OS thread affinity works.
qor_pp_test_suite_case(ThreadPoolTestSuite, checkOSThreadAffinity)
{
    ThreadPool pool;
    pool.PostTask(
        []
        {
            // Since the thread affinity must be a subset of the process affinity, we first set its affinity to all CPUs if it wasn't already.
            const std::optional<std::vector<bool>> initial_process_affinity = new_ref<ICurrentProcess>()().GetAffinity();
            const std::size_t num_process_bits = initial_process_affinity.has_value() ? initial_process_affinity->size() : std::thread::hardware_concurrency();
            const std::vector<bool> all_enabled(num_process_bits, true);
            new_ref<ICurrentProcess>()().SetAffinity(all_enabled);

            //sync_out.println("Checking OS thread affinity for pool threads...");

            //sync_out.print("Obtaining initial thread affinity ");
            const std::optional<std::vector<bool>> initial_affinity = CurrentThread::GetCurrent().GetAffinity();
            check(initial_affinity.has_value());
            //sync_out.println("Initial affinity is: ", affinity_to_string(initial_affinity));
            const std::size_t num_bits = initial_affinity.has_value() ? initial_affinity->size() : std::thread::hardware_concurrency();

            //sync_out.print("Setting affinity to CPU 1 only ");
            std::vector<bool> cpu_1_in(num_bits, false);
            cpu_1_in[0] = true;
            check(CurrentThread::GetCurrent().SetAffinity(cpu_1_in));
            //sync_out.print("Obtaining new affinity ");
            const std::optional<std::vector<bool>> cpu_1_out = CurrentThread::GetCurrent().GetAffinity();
            check(cpu_1_out.has_value());
            check(affinity_to_string(cpu_1_in), affinity_to_string(cpu_1_out));

            //sync_out.print("Setting affinity to alternating CPUs ");
            std::vector<bool> alternating_in(num_bits, false);
            for (std::size_t i = 0; i < num_bits; ++i)
                alternating_in[i] = (i % 2 == 1);
            check(CurrentThread::GetCurrent().SetAffinity(alternating_in));
            //sync_out.print("Obtaining new affinity ");
            const std::optional<std::vector<bool>> alternating_out = CurrentThread::GetCurrent().GetAffinity();
            check(alternating_out.has_value());
            check(affinity_to_string(alternating_in), affinity_to_string(alternating_out));

            if (initial_affinity.has_value())
            {
                //sync_out.print("Setting affinity back to initial value ");
                check(CurrentThread::GetCurrent().SetAffinity(*initial_affinity));
                //sync_out.print("Obtaining new affinity ");
                const std::optional<std::vector<bool>> initial_out = CurrentThread::GetCurrent().GetAffinity();
                check(initial_out.has_value());
                check(affinity_to_string(initial_affinity), affinity_to_string(initial_out));
            }

            if (initial_process_affinity.has_value())
                new_ref<ICurrentProcess>()().SetAffinity(*initial_process_affinity);
        });
}

template <typename... T>
std::string make_string(const T&... items)
{
    std::ostringstream out;
    (out << ... << items);
    return out.str();
}

//Try to set the OS priority of this thread to the highest possible value. Also set the name of the thread for debugging purposes.
qor_pp_test_suite_case(ThreadPoolTestSuite, testOSThreadPriority)
{
    if (!CurrentThread::GetCurrent().SetPriority(ICurrentThread::Priority::realtime))
        if (!CurrentThread::GetCurrent().SetPriority(ICurrentThread::Priority::highest))
            CurrentThread::GetCurrent().SetPriority(ICurrentThread::Priority::above_normal);
    std::optional<std::size_t> idx = CurrentThread::GetCurrent().GetPoolIndex();
    if (idx.has_value())
    {
        CurrentThread::GetCurrent().SetName(make_string("Benchmark #", *idx));
    }
    else
    {
        CurrentThread::GetCurrent().SetName("Benchmark main");
    }
}
