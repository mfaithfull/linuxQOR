// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include <chrono>
#include <algorithm>
#include <ostream>

#include "src/qor/test/test.h"
#include "src/qor/assert/assert.h"
#include "src/framework/task/generator/recursivegenerator.h"
#include "src/qor/sync/onscopeexit.h"
#include "src/framework/task/fmap.h"

using namespace qor;
using namespace qor::test;
//using namespace qor::framework;

struct RecursiveGeneratorTestSuite{};

//using recursive_generator;

qor_pp_test_suite_case(RecursiveGeneratorTestSuite, default_constructed_recursive_generator_is_empty)
{
	recursive_generator<std::uint32_t> ints;
	qor_pp_assert_that(ints.begin() == ints.end());
}

qor_pp_test_suite_case(RecursiveGeneratorTestSuite, non_recursive_use_of_recursive_generator)
{
	auto f = []() -> recursive_generator<float>
	{
		co_yield 1.0f;
		co_yield 2.0f;
	};

	auto gen = f();
	auto iter = gen.begin();
	qor_pp_assert_that(*iter == 1.0f);
	++iter;
	qor_pp_assert_that(*iter == 2.0f);
	++iter;
	qor_pp_assert_that(iter == gen.end());
}

qor_pp_test_suite_case(RecursiveGeneratorTestSuite, throw_before_first_yield)
{
	class MyException : public std::exception {};

	auto f = []() -> recursive_generator<std::uint32_t>
	{
		throw MyException{};
		co_return;
	};

	auto gen = f();
	try
	{
		auto iter = gen.begin();
		qor_pp_assert_that(false);
	}
	catch (MyException)
	{
		qor_pp_assert_that(true);
	}
}

qor_pp_test_suite_case(RecursiveGeneratorTestSuite, throw_after_first_yield)
{
	class MyException : public std::exception {};

	auto f = []() -> recursive_generator<std::uint32_t>
	{
		co_yield 1;
		throw MyException{};
	};

	auto gen = f();
	auto iter = gen.begin();
	qor_pp_assert_that(*iter == 1u);
	try
	{
		++iter;
		qor_pp_assert_that(false);
	}
	catch (MyException)
	{
		qor_pp_assert_that(true);
	}
}

qor_pp_test_suite_case(RecursiveGeneratorTestSuite, generator_doesnt_start_executing_until_begin_is_called)
{
	bool reachedA = false;
	bool reachedB = false;
	bool reachedC = false;
	auto f = [&]() -> recursive_generator<std::uint32_t>
	{
		reachedA = true;
		co_yield 1;
		reachedB = true;
		co_yield 2;
		reachedC = true;
	};

	auto gen = f();
	qor_pp_assert_that(!reachedA);
	auto iter = gen.begin();
	qor_pp_assert_that(reachedA);
	qor_pp_assert_that(!reachedB);
	qor_pp_assert_that(*iter == 1u);
	++iter;
	qor_pp_assert_that(reachedB);
	qor_pp_assert_that(!reachedC);
	qor_pp_assert_that(*iter == 2u);
	++iter;
	qor_pp_assert_that(reachedC);
	qor_pp_assert_that(iter == gen.end());
}

qor_pp_test_suite_case(RecursiveGeneratorTestSuite, recursive_destroying_generator_before_completion_destructs_objects_on_stack)
{
	bool destructed = false;
	bool completed = false;
	auto f = [&]() -> recursive_generator<std::uint32_t>
	{
		auto onExit = on_scope_exit([&]
		{
			destructed = true;
		});

		co_yield 1;
		co_yield 2;
		completed = true;
	};

	{
		auto g = f();
		auto it = g.begin();
		auto itEnd = g.end();
		qor_pp_assert_that(*it == 1u);
		qor_pp_assert_that(!destructed);
	}

	qor_pp_assert_that(!completed);
	qor_pp_assert_that(destructed);
}

qor_pp_test_suite_case(RecursiveGeneratorTestSuite, simple_recursive_yield)
{
	auto f = [](int n, auto& f) -> recursive_generator<const std::uint32_t>
	{
		co_yield n;
		if (n > 0)
		{
			co_yield f(n - 1, f);
			co_yield n;
		}
	};

	auto f2 = [&f](int n)
	{
		return f(n, f);
	};

	{
		auto gen = f2(1);
		auto iter = gen.begin();
		qor_pp_assert_that(*iter == 1u);
		++iter;
		qor_pp_assert_that(*iter == 0u);
		++iter;
		qor_pp_assert_that(*iter == 1u);
		++iter;
		qor_pp_assert_that(iter == gen.end());
	}

	{
		auto gen = f2(2);
		auto iter = gen.begin();
		qor_pp_assert_that(*iter == 2u);
		++iter;
		qor_pp_assert_that(*iter == 1u);
		++iter;
		qor_pp_assert_that(*iter == 0u);
		++iter;
		qor_pp_assert_that(*iter == 1u);
		++iter;
		qor_pp_assert_that(*iter == 2u);
		++iter;
		qor_pp_assert_that(iter == gen.end());
	}
}

qor_pp_test_suite_case(RecursiveGeneratorTestSuite, nested_yield_that_yields_nothing)
{
	auto f = []() -> recursive_generator<std::uint32_t>
	{
		co_return;
	};

	auto g = [&f]() -> recursive_generator<std::uint32_t>
	{
		co_yield 1;
		co_yield f();
		co_yield 2;
	};

	auto gen = g();
	auto iter = gen.begin();
	qor_pp_assert_that(*iter == 1u);
	++iter;
	qor_pp_assert_that(*iter == 2u);
	++iter;
	qor_pp_assert_that(iter == gen.end());
}

qor_pp_test_suite_case(RecursiveGeneratorTestSuite, exception_thrown_from_recursive_call_can_be_caught_by_caller)
{
	class SomeException : public std::exception {};

	auto f = [](std::uint32_t depth, auto&& f) -> recursive_generator<std::uint32_t>
	{
		if (depth == 1u)
		{
			throw SomeException{};
		}

		co_yield 1;

		try
		{
			co_yield f(1, f);
		}
		catch (SomeException)
		{
		}

		co_yield 2;
	};

	auto gen = f(0, f);
	auto iter = gen.begin();
	qor_pp_assert_that(*iter == 1u);
	++iter;
	qor_pp_assert_that(*iter == 2u);
	++iter;
	qor_pp_assert_that(iter == gen.end());
}

qor_pp_test_suite_case(RecursiveGeneratorTestSuite, exceptions_thrown_from_nested_call_can_be_caught_by_caller)
{
	class SomeException : public std::exception {};

	auto f = [](std::uint32_t depth, auto&& f) -> recursive_generator<std::uint32_t>
	{
		if (depth == 4u)
		{
			throw SomeException{};
		}
		else if (depth == 3u)
		{
			co_yield 3;

			try
			{
				co_yield f(4, f);
			}
			catch (SomeException)
			{
			}

			co_yield 33;

			throw SomeException{};
		}
		else if (depth == 2u)
		{
			bool caught = false;
			try
			{
				co_yield f(3, f);
			}
			catch (SomeException)
			{
				caught = true;
			}

			if (caught)
			{
				co_yield 2;
			}
		}
		else
		{
			co_yield 1;
			co_yield f(2, f);
			co_yield f(3, f);
		}
	};

	auto gen = f(1, f);
	auto iter = gen.begin();
	qor_pp_assert_that(*iter == 1u);
	++iter;
	qor_pp_assert_that(*iter == 3u);
	++iter;
	qor_pp_assert_that(*iter == 33u);
	++iter;
	qor_pp_assert_that(*iter == 2u);
	++iter;
	qor_pp_assert_that(*iter == 3u);
	++iter;
	qor_pp_assert_that(*iter == 33u);
	try
	{
		++iter;
		qor_pp_assert_that(false);
	}
	catch (SomeException)
	{
	}

	qor_pp_assert_that(iter == gen.end());
}

namespace
{
	recursive_generator<std::uint32_t> iterate_range(std::uint32_t begin, std::uint32_t end)
	{
		if ((end - begin) <= 10u)
		{
			for (std::uint32_t i = begin; i < end; ++i)
			{
				co_yield i;
			}
		}
		else
		{
			std::uint32_t mid = begin + (end - begin) / 2;
			co_yield iterate_range(begin, mid);
			co_yield iterate_range(mid, end);
		}
	}
}

qor_pp_test_suite_case(RecursiveGeneratorTestSuite, recursive_iteration_performance)
{
	const std::uint32_t count = 100000;

	auto start = std::chrono::high_resolution_clock::now();

	std::uint64_t sum = 0;
	for (auto i : iterate_range(0, count))
	{
		sum += i;
	}

	auto end = std::chrono::high_resolution_clock::now();

	qor_pp_assert_that(sum == (std::uint64_t(count) * (count - 1)) / 2);

	const auto timeTakenUs = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
	std::cout << "Range iteration of " << count << "elements took " << timeTakenUs << "us";
}

qor_pp_test_suite_case(RecursiveGeneratorTestSuite, usage_in_standard_algorithms)
{
	{
		auto a = iterate_range(5, 30);
		auto b = iterate_range(5, 30);
		qor_pp_assert_that(std::equal(a.begin(), a.end(), b.begin(), b.end()));
	}

	{
		auto a = iterate_range(5, 30);
		auto b = iterate_range(5, 300);
		qor_pp_assert_that(!std::equal(a.begin(), a.end(), b.begin(), b.end()));
	}
}

namespace
{
	recursive_generator<int> range(int start, int end)
	{
		while (start < end)
		{
			co_yield start++;
		}
	}

	recursive_generator<int> range_chunks(int start, int end, int runLength, int stride)
	{
		while (start < end)
		{
			co_yield range(start, std::min(end, start + runLength));
			start += stride;
		}
	}
}

qor_pp_test_suite_case(RecursiveGeneratorTestSuite, recursive_fmap_operator)
{
	// 0, 1, 2, 3, 4, 10, 11, 12, 13, 14, 20, 21, 22, 23, 24
	generator<int> gen = range_chunks(0, 30, 5, 10)
		| fmap([](int x) { return x * 3; });

	auto it = gen.begin();
	qor_pp_assert_that(*it == 0);
	qor_pp_assert_that(*++it == 3);
	qor_pp_assert_that(*++it == 6);
	qor_pp_assert_that(*++it == 9);
	qor_pp_assert_that(*++it == 12);
	qor_pp_assert_that(*++it == 30);
	qor_pp_assert_that(*++it == 33);
	qor_pp_assert_that(*++it == 36);
	qor_pp_assert_that(*++it == 39);
	qor_pp_assert_that(*++it == 42);
	qor_pp_assert_that(*++it == 60);
	qor_pp_assert_that(*++it == 63);
	qor_pp_assert_that(*++it == 66);
	qor_pp_assert_that(*++it == 69);
	qor_pp_assert_that(*++it == 72);
	qor_pp_assert_that(++it == gen.end());
}

