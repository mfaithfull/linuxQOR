// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include <ostream>

#include "src/qor/test/test.h"
#include "src/qor/assert/assert.h"
#include "src/framework/task/generator/asyncgenerator.h"
#include "src/qor/sync/singleconsumerevent.h"
#include "src/framework/task/task.h"
#include "src/framework/task/syncwait.h"
#include "src/framework/task/whenall.h"

using namespace qor;
using namespace qor::test;
//using namespace qor::framework;

struct AsyncGeneratorTestSuite{};

qor_pp_test_suite_case(AsyncGeneratorTestSuite, default_constructed_async_generator_is_an_empty_sequence)
{
	sync_wait([]() -> task<>
	{
		// Iterating over default-constructed async_generator just gives an empty sequence.
		async_generator<int> g;
		auto it = co_await g.begin();
		qor_pp_assert_that(it == g.end()).isTrue();
	}());
}

qor_pp_test_suite_case(AsyncGeneratorTestSuite, async_generator_doesnt_start_if_begin_not_called)
{
	bool startedExecution = false;
	{
		auto gen = [&]() -> async_generator<int>
		{
			startedExecution = true;
			co_yield 1;
		}();
		qor_pp_assert_that(startedExecution).isFalse();
	}
	qor_pp_assert_that(startedExecution).isFalse();
}

qor_pp_test_suite_case(AsyncGeneratorTestSuite, enumerate_sequence_of_1_value)
{
	sync_wait([]() -> task<>
	{
		bool startedExecution = false;
		auto makeGenerator = [&]() -> async_generator<std::uint32_t>
		{
			startedExecution = true;
			co_yield 1;
		};

		auto gen = makeGenerator();

		qor_pp_assert_that(startedExecution).isFalse();

		auto it = co_await gen.begin();

		qor_pp_assert_that(startedExecution).isTrue();
		qor_pp_assert_that(it != gen.end()).isTrue();
		qor_pp_assert_that(*it == 1u).isTrue();
		qor_pp_assert_that(co_await ++it == gen.end()).isTrue();
	}());
}

qor_pp_test_suite_case(AsyncGeneratorTestSuite, enumerate_sequence_of_multiple_values)
{
	sync_wait([]() -> task<>
	{
		bool startedExecution = false;
		auto makeGenerator = [&]() -> async_generator<std::uint32_t>
		{
			startedExecution = true;
			co_yield 1;
			co_yield 2;
			co_yield 3;
		};

		auto gen = makeGenerator();

		qor_pp_assert_that(startedExecution).isFalse();

		auto it = co_await gen.begin();

		qor_pp_assert_that(startedExecution).isTrue();

		qor_pp_assert_that(it != gen.end());
		qor_pp_assert_that(*it == 1u);

		qor_pp_assert_that(co_await ++it != gen.end());
		qor_pp_assert_that(*it == 2u);

		qor_pp_assert_that(co_await ++it != gen.end());
		qor_pp_assert_that(*it == 3u);

		qor_pp_assert_that(co_await ++it == gen.end());
	}());
}

namespace
{
	class set_to_true_on_destruction
	{
	public:

		set_to_true_on_destruction(bool* value) : m_value(value) {}

		set_to_true_on_destruction(set_to_true_on_destruction&& other) : m_value(other.m_value)
		{
			other.m_value = nullptr;
		}

		~set_to_true_on_destruction()
		{
			if (m_value != nullptr)
			{
				*m_value = true;
			}
		}

		set_to_true_on_destruction(const set_to_true_on_destruction&) = delete;
		set_to_true_on_destruction& operator=(const set_to_true_on_destruction&) = delete;

	private:

		bool* m_value;
	};
}

qor_pp_test_suite_case(AsyncGeneratorTestSuite, destructors_of_values_in_scope_are_called_when_async_generator_destructed_early)
{
	sync_wait([]() -> task<>
	{
		bool aDestructed = false;
		bool bDestructed = false;

		auto makeGenerator = [&](set_to_true_on_destruction a) -> async_generator<std::uint32_t>
		{
			set_to_true_on_destruction b(&bDestructed);
			co_yield 1;
			co_yield 2;
		};

		{
			auto gen = makeGenerator(&aDestructed);

			qor_pp_assert_that(!aDestructed);
			qor_pp_assert_that(!bDestructed);

			auto it = co_await gen.begin();
			qor_pp_assert_that(!aDestructed);
			qor_pp_assert_that(!bDestructed);
			qor_pp_assert_that(*it == 1u);
		}

		qor_pp_assert_that(aDestructed);
		qor_pp_assert_that(bDestructed);
	}());
}

qor_pp_test_suite_case(AsyncGeneratorTestSuite, async_producer_with_async_consumer)
{
	single_consumer_event p1;
	single_consumer_event p2;
	single_consumer_event p3;
	single_consumer_event c1;

	auto produce = [&]() -> async_generator<std::uint32_t>
	{
		co_await p1;
		co_yield 1;
		co_await p2;
		co_yield 2;
		co_await p3;
	};

	bool consumerFinished = false;

	auto consume = [&]() -> task<>
	{
		auto generator = produce();
		auto it = co_await generator.begin();
		qor_pp_assert_that(*it == 1u);
		(void)co_await ++it;
		qor_pp_assert_that(*it == 2u);
		co_await c1;
		(void)co_await ++it;
		qor_pp_assert_that(it == generator.end());
		consumerFinished = true;
	};

	auto unblock = [&]() -> task<>
	{
		p1.set();
		p2.set();
		c1.set();
		qor_pp_assert_that(!consumerFinished);
		p3.set();
		qor_pp_assert_that(consumerFinished);
		co_return;
	};

	sync_wait(when_all_ready(consume(), unblock()));
}

class TestException {};

qor_pp_test_suite_case(AsyncGeneratorTestSuite, exception_thrown_before_first_yield_is_rethrown_from_begin_operation)
{
	
	auto gen = [](bool shouldThrow) -> async_generator<std::uint32_t>
	{
		if (shouldThrow)
		{
			throw TestException();
		}
		co_yield 1;
	}(true);

	sync_wait([&]() -> task<>
	{
		qor_pp_test_assert_throw(co_await gen.begin(), TestException);
	}());
}

qor_pp_test_suite_case(AsyncGeneratorTestSuite, exception_thrown_after_first_yield_is_rethrown_from_increment_operator)
{
	class TestException {};
	auto gen = [](bool shouldThrow) -> async_generator<std::uint32_t>
	{
		co_yield 1;
		if (shouldThrow)
		{
			throw TestException();
		}
	}(true);

	sync_wait([&]() -> task<>
	{
		auto it = co_await gen.begin();
		qor_pp_assert_that(*it == 1u);
		qor_pp_test_assert_throw(co_await ++it, TestException);
		qor_pp_assert_that(it == gen.end());
	}());
}

qor_pp_test_suite_case(AsyncGeneratorTestSuite, large_number_of_synchronous_completions_doesnt_result_in_stack_overflow)
{

	auto makeSequence = [](single_consumer_event& event) -> async_generator<std::uint32_t>
	{
		for (std::uint32_t i = 0; i < 1'000'000u; ++i)
		{
			if (i == 500'000u) co_await event;
			co_yield i;
		}
	};

	auto consumer = [](async_generator<std::uint32_t> sequence) -> task<>
	{
		std::uint32_t expected = 0;
		for (auto iter = co_await sequence.begin(); iter != sequence.end(); co_await ++iter)
		{
			std::uint32_t i = *iter;
			qor_pp_assert_that(i == expected++);
		}

		qor_pp_assert_that(expected == 1'000'000u);
	};

	auto unblocker = [](single_consumer_event& event) -> task<>
	{
		// Should have processed the first 500'000 elements synchronously with consumer driving
		// iteraction before producer suspends and thus consumer suspends.
		// Then we resume producer in call to set() below and it continues processing remaining
		// 500'000 elements, this time with producer driving the interaction.

		event.set();

		co_return;
	};

	single_consumer_event event;

	sync_wait(
		when_all_ready(
			consumer(makeSequence(event)),
			unblocker(event)));
}

qor_pp_test_suite_case(AsyncGeneratorTestSuite, test_fmap)
{
	//using async_generator;
	//using fmap;

	auto iota = [](int count) -> async_generator<int>
	{
		for (int i = 0; i < count; ++i)
		{
			co_yield i;
		}
	};

	auto squares = iota(5) | fmap([](auto x) { return x * x; });

	sync_wait([&]() -> task<>
	{
		auto it = co_await squares.begin();
		qor_pp_assert_that(*it == 0);
		qor_pp_assert_that(*co_await ++it == 1);
		qor_pp_assert_that(*co_await ++it == 4);
		qor_pp_assert_that(*co_await ++it == 9);
		qor_pp_assert_that(*co_await ++it == 16);
		qor_pp_assert_that(co_await ++it == squares.end());
	}());
}
