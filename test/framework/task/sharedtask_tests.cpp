// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include <ostream>
#include <string>

#include "src/qor/test/test.h"
#include "src/qor/assert/assert.h"
#include "src/framework/task/sharedtask.h"
#include "src/framework/task/task.h"
#include "src/framework/task/syncwait.h"
#include "src/framework/task/whenallready.h"
#include "src/qor/sync/singleconsumerevent.h"
#include "src/framework/task/fmap.h"
#include "counted.h"

using namespace qor;
using namespace qor::test;

struct SharedTaskTestSuite{};

qor_pp_test_suite_case(SharedTaskTestSuite, awaiting_default_constructed_shared_task_throws_broken_promise)
{
	sync_wait([]() -> task<>
	{
		qor_pp_test_assert_throw(co_await shared_task<>{}, broken_promise);
	}());
}

qor_pp_test_suite_case(SharedTaskTestSuite, coroutine_doesnt_start_executing_until_awaited)
{
	bool startedExecuting = false;
	auto f = [&]() -> shared_task<>
	{
		startedExecuting = true;
		co_return;
	};

	auto t = f();

	qor_pp_assert_that(!t.is_ready());
	qor_pp_assert_that(!startedExecuting);

	sync_wait([](shared_task<> t) -> task<>
	{
		co_await t;
	}(t));

	qor_pp_assert_that(t.is_ready());
	qor_pp_assert_that(startedExecuting);
}

qor_pp_test_suite_case(SharedTaskTestSuite, result_is_destroyed_when_last_reference_is_destroyed)
{
	counted::reset_counts();

	{
		auto t = []() -> shared_task<counted>
		{
			co_return counted{};
		}();

		qor_pp_assert_that(counted::active_count() == 0);

		sync_wait(t);

		qor_pp_assert_that(counted::active_count() == 1);
	}

	qor_pp_assert_that(counted::active_count() == 0);
}

qor_pp_test_suite_case(SharedTaskTestSuite, shared_task_multiple_awaiters)
{
	SingleConsumerEvent event;
	bool startedExecution = false;
	auto produce = [&]() -> shared_task<int>
	{
		startedExecution = true;
		co_await event;
		co_return 1;
	};

	auto consume = [](shared_task<int> t) -> task<>
	{
		int result = co_await t;
		qor_pp_assert_that(result == 1);
	};

	auto sharedTask = produce();

	sync_wait(when_all_ready(
		consume(sharedTask),
		consume(sharedTask),
		consume(sharedTask),
		[&]() -> task<>
		{
			event.set();
			qor_pp_assert_that(sharedTask.is_ready());
			co_return;
		}()));

	qor_pp_assert_that(sharedTask.is_ready());
}

qor_pp_test_suite_case(SharedTaskTestSuite, waiting_on_shared_task_in_loop_doesnt_cause_stack_overflow)
{
	// This test checks that awaiting a shared_task that completes
	// synchronously doesn't recursively resume the awaiter inside the
	// call to start executing the task. If it were to do this then we'd
	// expect that this test would result in failure due to stack-overflow.

	auto completesSynchronously = []() -> shared_task<int>
	{
		co_return 1;
	};

	sync_wait([&]() -> task<>
	{
		int result = 0;
		for (int i = 0; i < 1'000'000; ++i)
		{
			result += co_await completesSynchronously();
		}
		qor_pp_assert_that(result == 1'000'000);
	}());
}

qor_pp_test_suite_case(SharedTaskTestSuite, test_make_shared_task)
{
	bool startedExecution = false;

	auto f = [&]() -> task<std::string>
	{
		startedExecution = false;
		co_return "test";
	};

	auto t = f();

	shared_task<std::string> sharedT = make_shared_task(std::move(t));

	qor_pp_assert_that(!sharedT.is_ready());
	qor_pp_assert_that(!startedExecution);

	auto consume = [](shared_task<std::string> t) -> task<>
	{
		auto x = co_await std::move(t);
		qor_pp_assert_that(x == "test");
	};

	sync_wait(when_all_ready(
		consume(sharedT),
		consume(sharedT)));
}

qor_pp_test_suite_case(SharedTaskTestSuite, make_shared_task_of_void)
{
	bool startedExecution = false;

	auto f = [&]() -> task<>
	{
		startedExecution = true;
		co_return;
	};

	auto t = f();

	shared_task<> sharedT = make_shared_task(std::move(t));

	qor_pp_assert_that(!sharedT.is_ready());
	qor_pp_assert_that(!startedExecution);

	auto consume = [](shared_task<> t) -> task<>
	{
		co_await t;
	};

	auto c1 = consume(sharedT);
	sync_wait(c1);

	qor_pp_assert_that(startedExecution);

	auto c2 = consume(sharedT);
	sync_wait(c2);

	qor_pp_assert_that(c1.is_ready());
	qor_pp_assert_that(c2.is_ready());
}

qor_pp_test_suite_case(SharedTaskTestSuite, shared_task_void_fmap_operator)
{
	SingleConsumerEvent event;
	int value = 0;

	auto setNumber = [&]() -> shared_task<>
	{
		co_await event;
		value = 123;
	};

	sync_wait(when_all_ready(
		[&]() -> task<>
	{
		auto numericStringTask =
			setNumber()
			| fmap([&]() { return std::to_string(value); });

		qor_pp_assert_that(co_await numericStringTask == "123");
	}(),
		[&]() -> task<>
	{
		qor_pp_assert_that(value == 0);
		event.set();
		qor_pp_assert_that(value == 123);
		co_return;
	}()));
}

qor_pp_test_suite_case(SharedTaskTestSuite, shared_task_T_fmap_operator)
{
	SingleConsumerEvent event;

	auto getNumber = [&]() -> shared_task<int>
	{
		co_await event;
		co_return 123;
	};

	sync_wait(when_all_ready(
		[&]() -> task<>
	{
		auto numericStringTask =
			getNumber()
			| fmap([](int x) { return std::to_string(x); });

		qor_pp_assert_that(co_await numericStringTask == "123");
	}(),
		[&]() -> task<>
	{
		event.set();
		co_return;
	}()));
}

