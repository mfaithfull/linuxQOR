// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include <iostream>
#include <vector>
#include <string>
#include <forward_list>

#include "src/qor/test/test.h"
#include "src/qor/assert/assert.h"
#include "src/framework/task/generator/generator.h"
#include "src/qor/sync/onscopeexit.h"
#include "src/framework/task/fmap.h"

using namespace qor;
using namespace qor::test;
//using namespace qor::framework;

struct GeneratorTestSuite{};

qor_pp_test_suite_case(GeneratorTestSuite, default_constructed_generator_is_empty_sequence)
{
	Generator<int> ints;
	qor_pp_assert_that(ints.begin() == ints.end());
}

qor_pp_test_suite_case(GeneratorTestSuite, generator_of_arithmetic_type_returns_by_copy)
{
	auto f = []() -> Generator<float>
	{
		co_yield 1.0f;
		co_yield 2.0f;
	};

	auto gen = f();
	auto iter = gen.begin();

	qor_pp_assert_that(*iter == 1.0f);
	++iter;
	qor_pp_assert_that(*iter == 2.0f);
	++iter;
	qor_pp_assert_that(iter == gen.end());
}

qor_pp_test_suite_case(GeneratorTestSuite, generator_of_reference_returns_by_reference)
{
	auto f = [](float& value) -> Generator<float&>
	{
		co_yield value;
	};

	float value = 1.0f;
	for (auto& x : f(value))
	{
		qor_pp_assert_that(&x == &value);
		x += 1.0f;
	}

	qor_pp_assert_that(value == 2.0f);
}

qor_pp_test_suite_case(GeneratorTestSuite, generator_of_const_type)
{
	auto fib = []() -> Generator<const std::uint64_t>
	{
		std::uint64_t a = 0, b = 1;
		while (true)
		{
			co_yield b;
			b += std::exchange(a, b);
		}
	};

	std::uint64_t count = 0;
	for (auto i : fib())
	{
		if (i > 1'000'000) {
			break;
		}
		++count;
	}

	// 30th fib number is 832'040
	qor_pp_assert_that(count == 30);
}

qor_pp_test_suite_case(GeneratorTestSuite, value_category_of_fmap_matches_reference_type)
{
    //using fmap;

    auto checkIsRvalue = [](auto&& x) {
        static_assert(std::is_rvalue_reference_v<decltype(x)>);
        static_assert(!std::is_const_v<std::remove_reference_t<decltype(x)>>);
        qor_pp_assert_that(x == 123);
        return x;
    };
    auto checkIsLvalue = [](auto&& x) {
        static_assert(std::is_lvalue_reference_v<decltype(x)>);
        static_assert(!std::is_const_v<std::remove_reference_t<decltype(x)>>);
        qor_pp_assert_that(x == 123);
        return x;
    };
    auto checkIsConstLvalue = [](auto&& x) {
        static_assert(std::is_lvalue_reference_v<decltype(x)>);
        static_assert(std::is_const_v<std::remove_reference_t<decltype(x)>>);
        qor_pp_assert_that(x == 123);
        return x;
    };
    auto checkIsConstRvalue = [](auto&& x) {
        static_assert(std::is_rvalue_reference_v<decltype(x)>);
        static_assert(std::is_const_v<std::remove_reference_t<decltype(x)>>);
        qor_pp_assert_that(x == 123);
        return x;
    };

    auto consume = [](auto&& range) {
        for (auto&& x : range) {
            (void)x;
        }
    };

    consume([]() -> Generator<int> { co_yield 123; }() | fmap(checkIsLvalue));
    consume([]() -> Generator<const int> { co_yield 123; }() | fmap(checkIsConstLvalue));
    consume([]() -> Generator<int&> { co_yield 123; }() | fmap(checkIsLvalue));
    consume([]() -> Generator<const int&> { co_yield 123; }() | fmap(checkIsConstLvalue));
    consume([]() -> Generator<int&&> { co_yield 123; }() | fmap(checkIsRvalue));
    consume([]() -> Generator<const int&&> { co_yield 123; }() | fmap(checkIsConstRvalue));
}

qor_pp_test_suite_case(GeneratorTestSuite, generator_doesnt_start_until_its_called)
{
	bool reachedA = false;
	bool reachedB = false;
	bool reachedC = false;
	auto f = [&]() -> Generator<int>
	{
		reachedA = true;
		co_yield 1;
		reachedB = true;
		co_yield 2;
		reachedC = true;
	};

	auto gen = f();
	qor_pp_assert_that(!reachedA);
	auto iter = gen.begin();
	qor_pp_assert_that(reachedA);
	qor_pp_assert_that(!reachedB);
	qor_pp_assert_that(*iter == 1);
	++iter;
	qor_pp_assert_that(reachedB);
	qor_pp_assert_that(!reachedC);
	qor_pp_assert_that(*iter == 2);
	++iter;
	qor_pp_assert_that(reachedC);
	qor_pp_assert_that(iter == gen.end());
}

qor_pp_test_suite_case(GeneratorTestSuite, destroying_generator_before_completion_destructs_objects_on_stack)
{
	bool destructed = false;
	bool completed = false;
	auto f = [&]() -> Generator<int>
	{
		auto onExit = on_scope_exit([&]
		{
			destructed = true;
		});

		co_yield 1;
		co_yield 2;
		completed = true;
	};

	{
		auto g = f();
		auto it = g.begin();
		auto itEnd = g.end();
		qor_pp_assert_that(it != itEnd);
		qor_pp_assert_that(*it == 1u);
		qor_pp_assert_that(!destructed);
	}

	qor_pp_assert_that(!completed);
	qor_pp_assert_that(destructed);
}

qor_pp_test_suite_case(GeneratorTestSuite, generator_throwing_before_yielding_first_element_rethrows_out_of_begin)
{
	class X {};

	auto g = []() -> Generator<int>
	{
		throw X{};
		co_return;
	}();

	try
	{
		g.begin();
		qor_pp_assert_that(false);
	}
	catch (const X&)
	{
	}
}

qor_pp_test_suite_case(GeneratorTestSuite, generator_throwing_after_first_element_rethrows_out_of_operator_postincrement)
{
	class X {};

	auto g = []() -> Generator<int>
	{
		co_yield 1;
		throw X{};
	}();

	auto iter = g.begin();
	qor_pp_assert_that(iter != g.end());
	try
	{
		++iter;
		qor_pp_assert_that(false);
	}
	catch (const X&)
	{
	}
}

namespace
{
	template<typename FIRST, typename SECOND>
	auto concat(FIRST&& first, SECOND&& second)
	{
		using value_type = std::remove_reference_t<decltype(*first.begin())>;
		return [](FIRST first, SECOND second) -> Generator<value_type>
		{
			for (auto&& x : first) co_yield x;
			for (auto&& y : second) co_yield y;
		}(std::forward<FIRST>(first), std::forward<SECOND>(second));
	}
}

qor_pp_test_suite_case(GeneratorTestSuite, safe_capture_of_r_value_reference_args)
{
	using namespace std::string_literals;

	// Check that we can capture l-values by reference and that temporary
	// values are moved into the coroutine frame.
	std::string byRef = "bar";
	auto g = concat("foo"s, concat(byRef, std::vector<char>{ 'b', 'a', 'z' }));

	byRef = "buzz";

	std::string s;
	for (char c : g)
	{
		s += c;
	}

	qor_pp_assert_that(s == "foobuzzbaz");
}

namespace
{
	Generator<int> range(int start, int end)
	{
		for (; start < end; ++start)
		{
			co_yield start;
		}
	}
}

qor_pp_test_suite_case(GeneratorTestSuite, fmap_operator)
{
	Generator<int> gen = range(0, 5)
		| fmap([](int x) { return x * 3; });

	auto it = gen.begin();
	qor_pp_assert_that(*it == 0);
	qor_pp_assert_that(*++it == 3);
	qor_pp_assert_that(*++it == 6);
	qor_pp_assert_that(*++it == 9);
	qor_pp_assert_that(*++it == 12);
	qor_pp_assert_that(++it == gen.end());
}

namespace
{
	template<std::size_t window, typename Range>
	Generator<const double> low_pass(Range rng)
	{
		auto it = std::begin(rng);
		const auto itEnd = std::end(rng);

		const double invCount = 1.0 / window;
		double sum = 0;

		using iter_cat =
			typename std::iterator_traits<decltype(it)>::iterator_category;

		if constexpr (std::is_base_of_v<std::random_access_iterator_tag, iter_cat>)
		{
			for (std::size_t count = 0; it != itEnd && count < window; ++it)
			{
				sum += *it;
				++count;
				co_yield sum / count;
			}

			for (; it != itEnd; ++it)
			{
				sum -= *(it - window);
				sum += *it;
				co_yield sum * invCount;
			}
		}
		else if constexpr (std::is_base_of_v<std::forward_iterator_tag, iter_cat>)
		{
			auto windowStart = it;
			for (std::size_t count = 0; it != itEnd && count < window; ++it)
			{
				sum += *it;
				++count;
				co_yield sum / count;
			}

			for (; it != itEnd; ++it, ++windowStart)
			{
				sum -= *windowStart;
				sum += *it;
				co_yield sum * invCount;
			}
		}
		else
		{
			// Just assume an input iterator
			double buffer[window];

			for (std::size_t count = 0; it != itEnd && count < window; ++it)
			{
				buffer[count] = *it;
				sum += buffer[count];
				++count;
				co_yield sum / count;
			}

			for (std::size_t pos = 0; it != itEnd; ++it, pos = (pos + 1 == window) ? 0 : (pos + 1))
			{
				sum -= std::exchange(buffer[pos], *it);
				sum += buffer[pos];
				co_yield sum * invCount;
			}
		}
	}
}

// HACK: Disable this test as it's causing heap corruption errors under MSVC 2017 Update 5 x86 debug builds.
// Still needs investigation of root cause.
qor_pp_test_suite_case(GeneratorTestSuite, test_low_pass)
//TEST_CASE("low_pass" * doctest::skip{ true })
{
	// With random-access iterator
	{
		auto gen = low_pass<4>(std::vector<int>{ 10, 13, 10, 15, 18, 9, 11, 15 });
		auto it = gen.begin();
		qor_pp_assert_that(*it == 10.0);
		qor_pp_assert_that(*++it == 11.5);
		qor_pp_assert_that(*++it == 11.0);
		qor_pp_assert_that(*++it == 12.0);
		qor_pp_assert_that(*++it == 14.0);
		qor_pp_assert_that(*++it == 13.0);
		qor_pp_assert_that(*++it == 13.25);
		qor_pp_assert_that(*++it == 13.25);
		qor_pp_assert_that(++it == gen.end());
	}

	// With forward-iterator
	{
		auto gen = low_pass<4>(std::forward_list<int>{ 10, 13, 10, 15, 18, 9, 11, 15 });
		auto it = gen.begin();
		qor_pp_assert_that(*it == 10.0);
		qor_pp_assert_that(*++it == 11.5);
		qor_pp_assert_that(*++it == 11.0);
		qor_pp_assert_that(*++it == 12.0);
		qor_pp_assert_that(*++it == 14.0);
		qor_pp_assert_that(*++it == 13.0);
		qor_pp_assert_that(*++it == 13.25);
		qor_pp_assert_that(*++it == 13.25);
		qor_pp_assert_that(++it == gen.end());
	}

	// With input-iterator
	{
		auto gen = low_pass<3>(range(10, 20));
		auto it = gen.begin();
		qor_pp_assert_that(*it == 10.0);
		qor_pp_assert_that(*++it == 10.5);
		qor_pp_assert_that(*++it == 11.0);
		qor_pp_assert_that(*++it == 12.0);
		qor_pp_assert_that(*++it == 13.0);
		qor_pp_assert_that(*++it == 14.0);
		qor_pp_assert_that(*++it == 15.0);
		qor_pp_assert_that(*++it == 16.0);
		qor_pp_assert_that(*++it == 17.0);
		qor_pp_assert_that(*++it == 18.0);
		qor_pp_assert_that(++it == gen.end());
	}
}
