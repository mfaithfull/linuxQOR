// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include <functional>
#include <string>
#include <vector>
#include <ostream>

#include "src/qor/test/test.h"
#include "src/qor/assert/assert.h"
#include "src/framework/task/whenall.h"
#include "src/qor/sync/asyncmanualresetevent.h"
#include "src/qor/sync/asyncmutex.h"
#include "src/framework/task/fmap.h"
#include "src/framework/task/sharedtask.h"
#include "src/framework/task/syncwait.h"
#include "src/framework/task/task.h"
#include "counted.h"


using namespace qor;
using namespace qor::test;
//using namespace qor::framework;

struct WhenallTestSuite{};

namespace
{
	template<template<typename T> class TASK, typename T>
	TASK<T> when_event_set_return(AsyncManualResetEvent& event, T value)
	{
		co_await event;
		co_return std::move(value);
	}
}

qor_pp_test_suite_case(WhenallTestSuite, when_all_with_no_args_completes_immediately)
{
	[[maybe_unused]] std::tuple<> result = sync_wait(when_all());
}

qor_pp_test_suite_case(WhenallTestSuite, when_all_with_one_arg)
{
	bool started = false;
	bool finished = false;
	auto f = [&](AsyncManualResetEvent& event) -> task<std::string>
	{
		started = true;
		co_await event;
		finished = true;
		co_return "foo";
	};

	AsyncManualResetEvent event;

	auto whenAllTask = when_all(f(event));
	qor_pp_assert_that(!started);

	sync_wait(when_all_ready(
		[&]() -> task<>
	{
		auto[s] = co_await whenAllTask;
		qor_pp_assert_that(s == "foo");
	}(),
		[&]() -> task<>
	{
		qor_pp_assert_that(started);
		qor_pp_assert_that(!finished);
		event.set();
		qor_pp_assert_that(finished);
		co_return;
	}()));
}

qor_pp_test_suite_case(WhenallTestSuite, when_all_with_awaitables)
{
	sync_wait([]() -> task<>
	{
		auto makeTask = [](int x) -> task<int>
		{
			co_return x;
		};

		AsyncManualResetEvent event;
		event.set();

		AsyncMutex mutex;

		auto[eventResult, mutexLock, number] = co_await when_all(
			std::ref(event),
			mutex.scoped_lock_async(),
			makeTask(123) | fmap([](int x) { return x + 1; }));

		(void)eventResult;
		(void)mutexLock;
		qor_pp_assert_that(number == 124);
		qor_pp_assert_that(!mutex.try_lock());
	}());
}

qor_pp_test_suite_case(WhenallTestSuite, when_all_with_all_task_types)
{
	counted::reset_counts();

	auto run = [](AsyncManualResetEvent& event) -> task<>
	{
		using namespace std::string_literals;

		auto[a, b] = co_await when_all(
			when_event_set_return<task>(event, "foo"s),
			when_event_set_return<shared_task>(event, counted{}));

		qor_pp_assert_that(a == "foo");
		qor_pp_assert_that(b.id == 0);
		qor_pp_assert_that(counted::active_count() == 1);
	};

	AsyncManualResetEvent event;

	sync_wait(when_all_ready(
		run(event),
		[&]() -> task<>
	{
		event.set();
		co_return;
	}()));
}

qor_pp_test_suite_case(WhenallTestSuite, when_all_throws_if_any_task_throws)
{
	struct X {};
	struct Y {};

	int startedCount = 0;
	auto makeTask = [&](int value) -> task<int>
	{
		++startedCount;
		if (value == 0) throw X{};
		else if (value == 1) throw Y{};
		else co_return value;
	};

	sync_wait([&]() -> task<>
	{
		try
		{
			// This could either throw X or Y exception.
			// The exact exception that is thrown is not defined if multiple tasks throw an exception.
			// TODO: Consider throwing some kind of aggregate_exception that collects all of the exceptions together.
			(void)co_await when_all(makeTask(0), makeTask(1), makeTask(2));
		}
		catch (const X&)
		{
		}
		catch (const Y&)
		{
		}
	}());
}

qor_pp_test_suite_case(WhenallTestSuite, when_all_with_task_void)
{
	int voidTaskCount = 0;
	auto makeVoidTask = [&]() -> task<>
	{
		++voidTaskCount;
		co_return;
	};

	auto makeIntTask = [](int x) -> task<int>
	{
		co_return x;
	};

	// Single void task in when_all()
	auto[x] = sync_wait(when_all(makeVoidTask()));
	(void)x;
	qor_pp_assert_that(voidTaskCount == 1);

	// Multiple void tasks in when_all()
	auto[a, b] = sync_wait(when_all(
		makeVoidTask(),
		makeVoidTask()));
	(void)a;
	(void)b;
	qor_pp_assert_that(voidTaskCount == 3);

	// Mixing void and non-void tasks in when_all()
	auto[v1, i, v2] = sync_wait(when_all(
		makeVoidTask(),
		makeIntTask(123),
		makeVoidTask()));
	(void)v1;
	(void)v2;
	qor_pp_assert_that(voidTaskCount == 5);

	qor_pp_assert_that(i == 123);
}

qor_pp_test_suite_case(WhenallTestSuite, when_all_with_vector_task)
{
	int startedCount = 0;
	auto makeTask = [&](AsyncManualResetEvent& event) -> task<>
	{
		++startedCount;
		co_await event;
	};

	AsyncManualResetEvent event1;
	AsyncManualResetEvent event2;

	bool finished = false;

	auto run = [&]() -> task<>
	{
		std::vector<task<>> tasks;
		tasks.push_back(makeTask(event1));
		tasks.push_back(makeTask(event2));
		tasks.push_back(makeTask(event1));

		auto allTask = when_all(std::move(tasks));

		qor_pp_assert_that(startedCount == 0);

		co_await allTask;

		finished = true;
	};

	sync_wait(when_all_ready(
		run(),
		[&]() -> task<>
	{
		qor_pp_assert_that(startedCount == 3);
		qor_pp_assert_that(!finished);

		event1.set();

		qor_pp_assert_that(!finished);

		event2.set();

		qor_pp_assert_that(finished);
		co_return;
	}()));
}

qor_pp_test_suite_case(WhenallTestSuite, when_all_with_vector_shared_task)
{
	int startedCount = 0;
	auto makeTask = [&](AsyncManualResetEvent& event) -> shared_task<>
	{
		++startedCount;
		co_await event;
	};

	AsyncManualResetEvent event1;
	AsyncManualResetEvent event2;

	bool finished = false;

	auto run = [&]() -> task<>
	{
		std::vector<shared_task<>> tasks;
		tasks.push_back(makeTask(event1));
		tasks.push_back(makeTask(event2));
		tasks.push_back(makeTask(event1));

		auto allTask = when_all(std::move(tasks));

		qor_pp_assert_that(startedCount == 0);

		co_await allTask;

		finished = true;
	};

	sync_wait(when_all_ready(
		run(),
		[&]() -> task<>
	{
		qor_pp_assert_that(startedCount == 3);
		qor_pp_assert_that(!finished);

		event1.set();

		qor_pp_assert_that(!finished);

		event2.set();

		qor_pp_assert_that(finished);

		co_return;
	}()));
}

namespace
{
	template<template<typename T> class TASK>
	void check_when_all_vector_of_task_value()
	{
		AsyncManualResetEvent event1;
		AsyncManualResetEvent event2;

		bool whenAllCompleted = false;

		sync_wait(when_all_ready(
			[&]() -> task<>
		{
			std::vector<TASK<int>> tasks;

			tasks.emplace_back(when_event_set_return<TASK>(event1, 1));
			tasks.emplace_back(when_event_set_return<TASK>(event2, 2));

			auto whenAllTask = when_all(std::move(tasks));

			auto values = co_await whenAllTask;
			qor_pp_assert_that(values.size() == 2);
			qor_pp_assert_that(values[0] == 1);
			qor_pp_assert_that(values[1] == 2);

			whenAllCompleted = true;
		}(),
			[&]() -> task<>
		{
			qor_pp_assert_that(!whenAllCompleted);
			event2.set();
			qor_pp_assert_that(!whenAllCompleted);
			event1.set();
			qor_pp_assert_that(whenAllCompleted);
			co_return;
		}()));
	}
}

#if defined(CPPCORO_RELEASE_OPTIMISED)
constexpr bool isOptimised = true;
#else
constexpr bool isOptimised = false;
#endif

// Disable test on MSVC x86 optimised due to bad codegen bug in
// `co_await whenAllTask` expression under MSVC 15.7 (Preview 2) and earlier.
//TEST_CASE("when_all() with vector<task<T>>"
//* doctest::skip(CPPCORO_COMPILER_MSVC && CPPCORO_COMPILER_MSVC <= 191426316 && CPPCORO_CPU_X86 && isOptimised))
qor_pp_test_suite_case(WhenallTestSuite, when_all_with_vector_task_T)
{
	check_when_all_vector_of_task_value<task>();
}

// Disable test on MSVC x64 optimised due to bad codegen bug in
// 'co_await whenAllTask' expression.
// Issue reported to MS on 19/11/2017.
//TEST_CASE("when_all() with vector<shared_task<T>>"
//* doctest::skip(CPPCORO_COMPILER_MSVC && CPPCORO_COMPILER_MSVC <= 191225805 &&
//	            isOptimised && CPPCORO_CPU_X64))
qor_pp_test_suite_case(WhenallTestSuite, when_all_with_vector_shared_task_T)
{
	check_when_all_vector_of_task_value<shared_task>();
}

namespace
{
	template<template<typename T> class TASK>
	void check_when_all_vector_of_task_reference()
	{
		AsyncManualResetEvent event1;
		AsyncManualResetEvent event2;

		int value1 = 1;
		int value2 = 2;

		auto makeTask = [](AsyncManualResetEvent& event, int& value) -> TASK<int&>
		{
			co_await event;
			co_return value;
		};

		bool whenAllComplete = false;

		sync_wait(when_all_ready(
			[&]() -> task<>
		{
			std::vector<TASK<int&>> tasks;
			tasks.emplace_back(makeTask(event1, value1));
			tasks.emplace_back(makeTask(event2, value2));

			auto whenAllTask = when_all(std::move(tasks));

			std::vector<std::reference_wrapper<int>> values = co_await whenAllTask;
			qor_pp_assert_that(values.size() == 2);
			qor_pp_assert_that(&values[0].get() == &value1);
			qor_pp_assert_that(&values[1].get() == &value2);

			whenAllComplete = true;
		}(),
			[&]() -> task<>
		{
			qor_pp_assert_that(!whenAllComplete);
			event2.set();
			qor_pp_assert_that(!whenAllComplete);
			event1.set();
			qor_pp_assert_that(whenAllComplete);
			co_return;
		}()));
	}
}

// Disable test on MSVC x64 optimised due to bad codegen bug in
// 'co_await whenAllTask' expression.
// Issue reported to MS on 19/11/2017.
//TEST_CASE("when_all() with vector<task<T&>>"
//	* doctest::skip(CPPCORO_COMPILER_MSVC && CPPCORO_COMPILER_MSVC <= 191225805 &&
//		isOptimised && CPPCORO_CPU_X64))
qor_pp_test_suite_case(WhenallTestSuite, when_all_with_vector_task_T_ref)
{
	check_when_all_vector_of_task_reference<task>();
}

// Disable test on MSVC x64 optimised due to bad codegen bug in
// 'co_await whenAllTask' expression.
// Issue reported to MS on 19/11/2017.
//TEST_CASE("when_all() with vector<shared_task<T&>>"
//	* doctest::skip(CPPCORO_COMPILER_MSVC && CPPCORO_COMPILER_MSVC <= 191225805 &&
//		isOptimised && CPPCORO_CPU_X64))
qor_pp_test_suite_case(WhenallTestSuite, when_all_with_vector_shared_task_T_ref)
{
	check_when_all_vector_of_task_reference<shared_task>();
}

