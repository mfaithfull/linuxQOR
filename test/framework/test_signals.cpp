// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "../../src/configuration/configuration.h"

#include <condition_variable>

#include "../../src/qor/test/test.h"
#include "../../src/qor/assert/assert.h"
#include "../../src/framework/thread/currentthread.h"
#include "../../src/framework/thread/thread.h"
#include "../../src/framework/signals/signal.h"

using namespace qor;
using namespace qor::test;
using namespace qor::framework;

class TestPushButton : public SignalBase
{
public:
	SIGNAL_1(void qor_pp_noinline pressed())
	SIGNAL_2(pressed)

	SIGNAL_1(void qor_pp_noinline clicked(bool checked = false))
	SIGNAL_2(clicked, checked)

	qor_pp_signal_func toggled(bool checked)
	{
		qor_pp_emit(toggled,checked);
	}
};

class Peach : public SlotBase
{
public:
	Peach();

	void toggled(bool onOff);
	void methodPressed();
	void threadPressed();

	template<class T>
	void templatePressed();

	int m_slotPressed = 0;

	std::deque<PendingSlot>* m_array;
	std::mutex* m_mutex;
	std::condition_variable* m_alarm;

private:
	void queueSlot(PendingSlot data, ConnectionKind type) override;
};

template<class T>
void Peach::templatePressed()
{
	printf("  Peach SLOT: pressed (slot is a template method)\n");
	m_slotPressed++;
}

Peach::Peach()
{
}

void Peach::toggled(bool onOff)
{
	printf("  Peach SLOT: pushButton toggled is (0 or 1) %d\n", onOff);
	m_slotPressed++;
}

void Peach::methodPressed()
{
	printf("  Peach SLOT: pressed (slot is a method pointer)\n");
	m_slotPressed++;
}

void Peach::threadPressed()
{
	printf("  Peach SLOT: pressed (slot is from a thread)\n");
	m_slotPressed++;
}

void Peach::queueSlot(PendingSlot data, ConnectionKind)
{
	SlotBase* receiver = data.receiver();
	printf("  queueSlot(): receiver is %s\n", typeid(*receiver).name());

	std::lock_guard<std::mutex> lock(*m_mutex);
	m_array->push_back(std::move(data));

	// wake up the thread
	m_alarm->notify_one();
}

qor_pp_test_case(signals)
{
}

qor_pp_test_case(signals_1)
{
	bool ok = true;

	TestPushButton okButton;
	Peach obj = Peach{};

	connect(okButton, &TestPushButton::pressed, obj, &Peach::methodPressed);

	if (obj.m_slotPressed != 0) 
	{
		// ensure slot has not been accidentally called
		ok = false;
	}

	// call the signal
	okButton.pressed();

	if (obj.m_slotPressed != 1) 
	{
		// ensure slot has been called once
		ok = false;
	}

    qor_pp_assert_that(ok).isTrue();
}

void funcPressed()
{
	printf("  SLOT: pressed (slot is a function pointer)\n");
}

qor_pp_test_case(signals_2)
{
	bool ok = true;

	TestPushButton okButton;
	Peach obj = Peach{};

	connect(okButton, &TestPushButton::pressed, obj, &funcPressed);

	// call the signal
	okButton.pressed();

    qor_pp_assert_that(ok).isTrue();
}

qor_pp_test_case(signals_3)
{
	bool ok = true;
	int slotPressed = 0;

	TestPushButton okButton;
	Peach obj = Peach{};

	connect(okButton, &TestPushButton::pressed, obj, [&slotPressed]()
		{
			printf("  SLOT: pressed (slot is a lambda)\n");
			slotPressed++;
		});

	if (slotPressed != 0) 
	{
		// ensure slot has not been accidentally called
		ok = false;
	}

	// call the signal
	okButton.pressed();

	if (slotPressed != 1) 
	{
		// ensure slot has been called once
		ok = false;
	}

    qor_pp_assert_that(ok).isTrue();

}

qor_pp_test_case(signals_4)
{
	bool ok = true;

	TestPushButton okButton;
	Peach obj = Peach{};

	connect(okButton, &TestPushButton::pressed, obj, &Peach::templatePressed<int>);

	if (obj.m_slotPressed != 0) 
	{
		// ensure slot has not been accidentally called
		ok = false;
	}

	// call the signal
	okButton.pressed();

	if (obj.m_slotPressed != 1) 
	{
		// ensure slot has been called once
		ok = false;
	}

    qor_pp_assert_that(ok).isTrue();
}

void callBack(std::atomic<bool>& running, std::deque<PendingSlot>& array, std::mutex& mutex, std::condition_variable& alarm)
{
	while (true) 
	{
		std::unique_lock<std::mutex> lock(mutex);

		if (!array.empty()) 
		{
			auto data = std::move(array.front());
			array.pop_front();
			lock.unlock();

			// call the slot
			data();
			continue;

		}
		else if (!running) 
		{
			break;

		}

		alarm.wait(lock);
	}
}

qor_pp_test_case(signals_5)
{
	bool ok = true;

	// set up threads
	std::atomic<bool> running;
	running = true;

	std::deque<PendingSlot> array;
	std::mutex mutex;
	std::condition_variable alarm;

	std::thread thread1(callBack, std::ref(running), std::ref(array), std::ref(mutex), std::ref(alarm));

	Peach obj;
	obj.m_array = &array;
	obj.m_mutex = &mutex;
	obj.m_alarm = &alarm;

	TestPushButton okButton;

	connect(okButton, &TestPushButton::pressed, obj, &Peach::threadPressed, ConnectionKind::QueuedConnection);

	if (obj.m_slotPressed != 0) 
	{
		// ensure the slots were not been accidentally called
		ok = false;
	}

	// emit the signal
	okButton.pressed();

	running = false;

	// wake up the thread
	alarm.notify_one();

	thread1.join();

	if (obj.m_slotPressed != 1) 
	{
		// ensure slot has been called once
		ok = false;
	}

    qor_pp_assert_that(ok).isTrue();
}

qor_pp_test_case(signals_6)
{
	bool ok = true;

	TestPushButton okButton;
	Peach obj = Peach{};

	connect(okButton, &TestPushButton::pressed, obj, &Peach::methodPressed);

	if (obj.m_slotPressed != 0) 
	{
		// ensure slot has not been accidentally called
		ok = false;
	}

	// call the signal
	okButton.pressed();

	//
	printf("  Disconnect() then emit signal again\n");
	disconnect(okButton, &TestPushButton::pressed, obj, &Peach::methodPressed);
	okButton.pressed();

	if (obj.m_slotPressed == 1) 
	{
		printf("  Signal emitted after disconnect(), did nothing\n");

	}
	else 
	{
		// ensure slot has been called once
		ok = false;
	}

    qor_pp_assert_that(ok).isTrue();
}

qor_pp_test_case(signals_7)
{
	bool ok = true;

	TestPushButton okButton;
	Peach obj = Peach{};

	// testing a signal with a parameter
	connect(okButton, &TestPushButton::toggled, obj, &Peach::toggled);

	if (obj.m_slotPressed != 0) 
	{
		// ensure slot has not been accidentally called
		ok = false;
	}

	// call the signal
	okButton.toggled(true);

	if (obj.m_slotPressed != 1) 
	{
		// ensure slot has been called once
		ok = false;
	}

    qor_pp_assert_that(ok).isTrue();
}

qor_pp_test_case(signals_8)
{
	bool ok = true;

	if (true) 
	{

		TestPushButton okButton;
		Peach obj = Peach{};

		// sender is an rvalue
		connect(TestPushButton{}, &TestPushButton::pressed, obj, &funcPressed);

		// receiver is an rvalue
		// connect(okButton, &TestPushButton::pressed, Peach{}, &funcPressed); 

		// sender and receiver are rvalues
		// connect(TestPushButton{}, &TestPushButton::pressed, Peach{}, &funcPressed); 

	}
	else 
	{
		printf("  Not enabled, used to test for compile issues\n");
	}

    qor_pp_assert_that(ok).isTrue();
}

