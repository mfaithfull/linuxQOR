// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "../../src/configuration/configuration.h"
#include "../../src/qor/test/test.h"
#include "../../src/qor/assert/assert.h"
#include "../../src/qor/datastructures/guid.h"
#include "../../src/qor/injection/typeidentity.h"
#include "../../src/qor/factory/factory.h"
#include "../../src/qor/factory/externalfactory.h"
#include "../../src/qor/injection/typeregistry.h"
#include "../../src/qor/injection/typeregentry.h"
#include "../../src/framework/thread/currentthread.h"
#include "../../src/qor/reference/newref.h"
#include "../../src/qor/injection/diwrapper.h"

using namespace qor;
using namespace qor::test;

struct InjectionTestSuite{};

class ConstructByID
{
    public:
    ConstructByID(){}

    virtual ~ConstructByID(){}

    virtual int Tag()
    {
        return 1;
    }
};

class AlternateImplementation : public ConstructByID
{
    public:

    AlternateImplementation(){}

    virtual ~AlternateImplementation(){}

    virtual int Tag()
    {
        return 2;
    }
};

static constexpr GUID ConstructByIDGuid = {0x15c5b0a2,0xb429,0x44f4,0xa1,0x42,0x78,0x8b,0x13,0x6b,0x3b,0x80};
qor_pp_declare_guid_of(ConstructByID,ConstructByIDGuid)
qor_pp_declare_factory_of(ConstructByID, ExternalFactory)

qor_pp_test_suite_case(InjectionTestSuite, canRegisterTypeFactoryByID)
{
    TypeRegEntry< ConstructByID > reg;  
}

qor_pp_test_suite_case(InjectionTestSuite, canContructInstanceByID)
{
    TypeRegEntry< ConstructByID > reg;  
    auto ref = new_ref<ConstructByID>();
    qor_pp_assert_that(ref.operator->()).isNotNull();
    qor_pp_assert_that(ref->Tag()).isEqualTo(1);
}

qor_pp_test_suite_case(InjectionTestSuite, canContructAlternativeByID)
{
    TypeRegEntry< AlternateImplementation, ConstructByID > reg;  
    auto ref = new_ref<ConstructByID>();
    qor_pp_assert_that(ref.operator->()).isNotNull();
    qor_pp_assert_that(ref->Tag()).isEqualTo(2);
}

class DIConstructable
{
public:
    DIConstructable( qor_pp_did(ConstructByID, param) )
    {
        m_Tag = param()->Tag();
    }

    int m_Tag;
};

qor_pp_test_suite_case(InjectionTestSuite, DITargetCanBeDefaultConstructed)
{
    TypeRegEntry< AlternateImplementation, ConstructByID > reg;  

    DIConstructable target;

    qor_pp_assert_that(target.m_Tag).isEqualTo(2);
}
