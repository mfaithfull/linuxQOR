// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "../../src/configuration/configuration.h"
#include "../../src/qor/test/test.h"
#include "../../src/qor/assert/assert.h"
#include "../../src/qor/module/module.h"
#include "../../src/qor/interception/functioncontextlock.h"
#include "../../src/qor/interception/callinterceptor.h"
#include "../../src/qor/interception/parameters/return.h"
#include "../../src/qor/interception/parameters/checkedparam.h"

using namespace qor;
using namespace qor::test;

struct ParameterInterceptionTestSuite{};

class ReturnInterceptor : public CallInterceptor
{
public:

    ReturnInterceptor() : returnAssingmentCount(0), returnCount(0) {}

    virtual void OnReturnAssignment( CallContext* pCall )
    {
        returnAssingmentCount++;
    }

    virtual void OnReturn(CallContext* pCall)
    {
        returnCount++;
    }

    uint64_t returnAssingmentCount;
    uint64_t returnCount;
};

int doSomething(int a)
{
    qor_pp_fcontext;   
    CheckedReturn<int> checked_result = (a + 6);
    return checked_result;
}

qor_pp_test_suite_case(ParameterInterceptionTestSuite, canInstantiateARegisteredReturnParameter)
{
    qor_pp_ofcontext;
    ReturnInterceptor returncheck;
    int value = doSomething(4);
    qor_pp_assert_that(returncheck.returnAssingmentCount).isEqualTo(1);
    qor_pp_assert_that(returncheck.returnCount).isEqualTo(1);
    qor_pp_assert_that(value).isEqualTo(10);
}

int doSomethingUnsafe(CheckedParam<int> a)
{
    qor_pp_fcontext;   
    CheckedReturn<int> checked_result = (a + 6);
    return checked_result;
}

qor_pp_test_suite_case(ParameterInterceptionTestSuite, canUseCheckParameterWithNoCheck)
{
    qor_pp_ofcontext;
    int value = doSomethingUnsafe(4);
    qor_pp_assert_that(value).isEqualTo(10);
}

namespace qor {

    class CustomCheck
    {
    public:
        
        static void Check(int value) 
        {
            if( value != 4 )
            {
                std::cout << " value check failed. Must be == 4.";
            }
            else
            {
                std::cout << " value check passed. value == 4.";
            }
        }
    };
    
}//qor

int doSomethingSafe(CheckedParam<int, CustomCheck> a)
{
    qor_pp_fcontext;   
    CheckedReturn<int> checked_result = (a + 6);
    return checked_result;
}

qor_pp_test_suite_case(ParameterInterceptionTestSuite, canUseCheckParameterWithCustomCheck)
{
    qor_pp_ofcontext;
    int value = doSomethingSafe(4);
    qor_pp_assert_that(value).isEqualTo(10);
}

bool globalRelativeParamCheckResult = false;

namespace qor {

    class LargerThan
    {
    public:
        
        static void Check(int value) 
        {
            FunctionContextLock fcl;
            CallContext* pCallContext = dynamic_cast<CallContext*>(fcl.CallContextPtr());
            if(pCallContext)
            {
                ParameterBase& ParamBase = pCallContext->Parameters()[pCallContext->m_ucParamCount - 2];
                int* pParam = reinterpret_cast<int*>(ParamBase.m_p);
                if( pParam)
                {
                    if( value > *pParam)
                    {
                        std::cout << " relative value check passed. a > b.";
                        globalRelativeParamCheckResult = true;
                    }
                    else
                    {
                        std::cout << " relative value check falied. a is not larger than b.";
                        globalRelativeParamCheckResult = false;
                    }
                }
            }
        }
    };
    
}//qor

int doSomethingRelative( CheckedParam<int, LargerThan> a, CheckedParam<int> b) //a must be larger than b
{
    qor_pp_fcontext;
    return a + b;
}

qor_pp_test_suite_case(ParameterInterceptionTestSuite, canCheckParameterRelationWithCustomCheck)
{
    qor_pp_ofcontext;
    globalRelativeParamCheckResult = false;
    int value = doSomethingRelative(7, 3);
    qor_pp_assert_that(value).isEqualTo(10);
    qor_pp_assert_that(globalRelativeParamCheckResult).isTrue();
}

qor_pp_test_suite_case(ParameterInterceptionTestSuite, canCheckParameterRelationFails)
{
    qor_pp_ofcontext;
    globalRelativeParamCheckResult = true;   
    int value = doSomethingRelative(3, 7);
    qor_pp_assert_that(value).isEqualTo(10);
    qor_pp_assert_that(globalRelativeParamCheckResult).isFalse();
}
