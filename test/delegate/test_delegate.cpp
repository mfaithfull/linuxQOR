// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "../../src/configuration/configuration.h"
#include "../../src/qor/test/test.h"
#include "../../src/qor/assert/assert.h"
#include "../../src/qor/delegate/delegate.h"

using namespace qor;
using namespace qor::test;

struct DelegateTestSuite{};


class DelegateTestTarget 
{
    public:
        double InstanceFunction(int, char, const char*) 
        { 
            return 0.1; 
        }

        double ConstInstanceFunction(int, char, const char*) const 
        { 
            return 0.2; 
        }

        static double StaticFunction(int, char, const char*) 
        { 
            return 0.3; 
        }
};

qor_pp_test_suite_case(DelegateTestSuite, canDefaultConstructDelegate)
{         
    Delegate<double(int, char, const char*)> d;
}

qor_pp_test_suite_case(DelegateTestSuite, canConstructDelegateOnMemberFunction)
{
    DelegateTestTarget target;
      
    Delegate<double(int, char, const char*)> d;
    auto dInstance = decltype(d)::Create<DelegateTestTarget, &DelegateTestTarget::InstanceFunction>(&target);
}

qor_pp_test_suite_case(DelegateTestSuite, canCallDelegateOnMemberFunction)
{
    DelegateTestTarget target;
      
    Delegate<double(int, char, const char*)> d;
    auto dInstance = decltype(d)::Create<DelegateTestTarget, &DelegateTestTarget::InstanceFunction>(&target);
    qor_pp_assert_that(dInstance(0, 'A', "Instance method call")).isEqualTo(0.1);
}

qor_pp_test_suite_case(DelegateTestSuite, canConstructDelegateOnConstMemberFunction)
{
    DelegateTestTarget target;
      
    Delegate<double(int, char, const char*)> d;
    auto dConst = decltype(d)::Create<DelegateTestTarget, &DelegateTestTarget::ConstInstanceFunction>(&target);
}

qor_pp_test_suite_case(DelegateTestSuite, canCallDelegateOnConstMemberFunction)
{
    DelegateTestTarget target;
      
    Delegate<double(int, char, const char*)> d;
    auto dConst = decltype(d)::Create<DelegateTestTarget, &DelegateTestTarget::ConstInstanceFunction>(&target);
    qor_pp_assert_that(dConst(1, 'B', "Constant instance method call")).isEqualTo(0.2);
}

qor_pp_test_suite_case(DelegateTestSuite, canConstructDelegateOnStatictMemberFunction)
{
    Delegate<double(int, char, const char*)> d;
    auto dFunc = decltype(d)::Create<&DelegateTestTarget::StaticFunction>();
}

qor_pp_test_suite_case(DelegateTestSuite, canCallDelegateOnStatictMemberFunction)
{
    Delegate<double(int, char, const char*)> d;
    auto dFunc = decltype(d)::Create<&DelegateTestTarget::StaticFunction>();
    qor_pp_assert_that(dFunc(2, 'C', "Static function call")).isEqualTo(0.3);
}
    
qor_pp_test_suite_case(DelegateTestSuite, canCallDelegateOnLambda)
{    
        
    Delegate<double(int, char, const char*)> d;
    
    int touchPoint = 1;
    auto lambda = [&touchPoint](int i, char c, const char* msg) -> double {
        std::cout << msg << std::endl;      
        return (++touchPoint + (int)c) * 0.1 - i;
    };
    
    decltype(d) dLambda = lambda; // lambda to delegate
    
    if (d != nullptr)
    {
        d(1, '1', " lambda call"); //won't
    }
    
    d = dLambda; // delegate to delegate
    
    if (d == dLambda)
    {
        d(1, '1', " lambda call"); //will be called
    }
}