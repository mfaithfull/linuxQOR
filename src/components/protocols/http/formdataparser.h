// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_COMPONENTS_PROTOCOLS_HTTP_FORMDATAPARSER
#define QOR_PP_H_COMPONENTS_PROTOCOLS_HTTP_FORMDATAPARSER

#include "forms.h"

namespace qor { namespace components { namespace protocols { namespace http {

    using FormDataHeader = std::function<bool(const FormData &file)>;
    
    class FormDataParser 
    {
    public:
        FormDataParser() = default;

        void set_boundary(std::string &&boundary) 
        {
            boundary_ = boundary;
            dash_boundary_crlf_ = dash_ + boundary_ + crlf_;
            crlf_dash_boundary_ = crlf_ + dash_ + boundary_;
        }

        bool is_valid() const { return is_valid_; }

        bool parse(const char *buf, size_t n, const FormDataHeader &header_callback, const ContentReceiver &content_callback) 
        {
            buf_append(buf, n);

            while (buf_size() > 0) 
            {
            switch (state_) {
            case 0: { // Initial boundary
            auto pos = buf_find(dash_boundary_crlf_);
            if (pos == buf_size()) { return true; }
            buf_erase(pos + dash_boundary_crlf_.size());
            state_ = 1;
            break;
            }
            case 1: { // New entry
            clear_file_info();
            state_ = 2;
            break;
            }
            case 2: { // Headers
            auto pos = buf_find(crlf_);
            if (pos > CPPHTTPLIB_HEADER_MAX_LENGTH) { return false; }
            while (pos < buf_size()) {
            // Empty line
            if (pos == 0) {
            if (!header_callback(file_)) {
            is_valid_ = false;
            return false;
            }
            buf_erase(crlf_.size());
            state_ = 3;
            break;
            }

            const auto header = buf_head(pos);

            if (!parse_header(header.data(), header.data() + header.size(),
            [&](const std::string &, const std::string &) {})) {
            is_valid_ = false;
            return false;
            }

            // Parse and emplace space trimmed headers into a map
            if (!parse_header(
            header.data(), header.data() + header.size(),
            [&](const std::string &key, const std::string &val) {
            file_.headers.emplace(key, val);
            })) {
            is_valid_ = false;
            return false;
            }

            constexpr const char header_content_type[] = "Content-Type:";

            if (start_with_case_ignore(header, header_content_type)) {
            file_.content_type =
            trim_copy(header.substr(str_len(header_content_type)));
            } else {
            thread_local const std::regex re_content_disposition(
            R"~(^Content-Disposition:\s*form-data;\s*(.*)$)~",
            std::regex_constants::icase);

            std::smatch m;
            if (std::regex_match(header, m, re_content_disposition)) {
            Params params;
            parse_disposition_params(m[1], params);

            auto it = params.find("name");
            if (it != params.end()) {
            file_.name = it->second;
            } else {
            is_valid_ = false;
            return false;
            }

            it = params.find("filename");
            if (it != params.end()) { file_.filename = it->second; }

            it = params.find("filename*");
            if (it != params.end()) {
            // Only allow UTF-8 encoding...
            thread_local const std::regex re_rfc5987_encoding(
            R"~(^UTF-8''(.+?)$)~", std::regex_constants::icase);

            std::smatch m2;
            if (std::regex_match(it->second, m2, re_rfc5987_encoding)) {
            file_.filename = decode_path_component(m2[1]); // override...
            } else {
            is_valid_ = false;
            return false;
            }
            }
            }
            }
            buf_erase(pos + crlf_.size());
            pos = buf_find(crlf_);
            }
            if (state_ != 3) { return true; }
            break;
            }
            case 3: { // Body
            if (crlf_dash_boundary_.size() > buf_size()) { return true; }
            auto pos = buf_find(crlf_dash_boundary_);
            if (pos < buf_size()) {
            if (!content_callback(buf_data(), pos)) {
            is_valid_ = false;
            return false;
            }
            buf_erase(pos + crlf_dash_boundary_.size());
            state_ = 4;
            } else {
            auto len = buf_size() - crlf_dash_boundary_.size();
            if (len > 0) {
            if (!content_callback(buf_data(), len)) {
            is_valid_ = false;
            return false;
            }
            buf_erase(len);
            }
            return true;
            }
            break;
            }
            case 4: { // Boundary
            if (crlf_.size() > buf_size()) { return true; }
            if (buf_start_with(crlf_)) {
            buf_erase(crlf_.size());
            state_ = 1;
            } else {
            if (dash_.size() > buf_size()) { return true; }
            if (buf_start_with(dash_)) {
            buf_erase(dash_.size());
            is_valid_ = true;
            buf_erase(buf_size()); // Remove epilogue
            } else {
            return true;
            }
            }
            break;
            }
            }
            }

            return true;
        }

    private:

        void clear_file_info() 
        {
            file_.name.clear();
            file_.filename.clear();
            file_.content_type.clear();
            file_.headers.clear();
        }

        bool start_with_case_ignore(const std::string &a, const char *b) const 
        {
            const auto b_len = strlen(b);
            if (a.size() < b_len) { return false; }
            for (size_t i = 0; i < b_len; i++) {
            if (case_ignore::to_lower(a[i]) != case_ignore::to_lower(b[i])) {
            return false;
            }
            }
            return true;
        }

        const std::string dash_ = "--";
        const std::string crlf_ = "\r\n";
        std::string boundary_;
        std::string dash_boundary_crlf_;
        std::string crlf_dash_boundary_;

        size_t state_ = 0;
        bool is_valid_ = false;
        FormData file_;

        // Buffer
        bool start_with(const std::string &a, size_t spos, size_t epos, const std::string &b) const 
        {
            if (epos - spos < b.size()) { return false; }
            for (size_t i = 0; i < b.size(); i++) {
            if (a[i + spos] != b[i]) { return false; }
            }
            return true;
        }

        size_t buf_size() const { return buf_epos_ - buf_spos_; }

        const char *buf_data() const { return &buf_[buf_spos_]; }

        std::string buf_head(size_t l) const { return buf_.substr(buf_spos_, l); }

        bool buf_start_with(const std::string &s) const {
            return start_with(buf_, buf_spos_, buf_epos_, s);
        }

        size_t buf_find(const std::string &s) const 
        {
            auto c = s.front();

            size_t off = buf_spos_;
            while (off < buf_epos_) {
            auto pos = off;
            while (true) {
            if (pos == buf_epos_) { return buf_size(); }
            if (buf_[pos] == c) { break; }
            pos++;
            }

            auto remaining_size = buf_epos_ - pos;
            if (s.size() > remaining_size) { return buf_size(); }

            if (start_with(buf_, pos, buf_epos_, s)) { return pos - buf_spos_; }

            off = pos + 1;
            }

            return buf_size();
        }

        void buf_append(const char *data, size_t n) 
        {
            auto remaining_size = buf_size();
            if (remaining_size > 0 && buf_spos_ > 0) {
            for (size_t i = 0; i < remaining_size; i++) {
            buf_[i] = buf_[buf_spos_ + i];
            }
            }
            buf_spos_ = 0;
            buf_epos_ = remaining_size;

            if (remaining_size + n > buf_.size()) { buf_.resize(remaining_size + n); }

            for (size_t i = 0; i < n; i++) {
            buf_[buf_epos_ + i] = data[i];
            }
            buf_epos_ += n;
        }

        void buf_erase(size_t size) { buf_spos_ += size; }

        std::string buf_;
        size_t buf_spos_ = 0;
        size_t buf_epos_ = 0;
    };

}}}}

#endif//QOR_PP_H_COMPONENTS_PROTOCOLS_HTTP_FORMDATAPARSER
