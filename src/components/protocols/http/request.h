// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_COMPONENTS_PROTOCOLS_HTTP_REQUEST
#define QOR_PP_H_COMPONENTS_PROTOCOLS_HTTP_REQUEST

#include <string>
#include <chrono>
#include "text/utils.h"
#include "headers.h"
#include "forms.h"
#include "ranges.h"
#include "contentprovider.h"
#include "contentreader.h"

namespace qor { namespace components { namespace protocols { namespace http {

    class qor_pp_module_interface(QOR_HTTP) Request
    {
    public:
    
        std::string method;
        std::string path;
        std::string matched_route;
        Params params;
        Headers headers;
        Headers trailers;
        std::string body;

        std::string remote_addr;
        int remote_port = -1;
        std::string local_addr;
        int local_port = -1;

        // for server
        std::string version;
        std::string target;
        MultipartFormData form;
        Ranges ranges;
        Match matches;
        std::unordered_map<std::string, std::string> path_params;
        std::function<bool()> is_connection_closed = []() { return true; };

        // for client
        std::vector<std::string> accept_content_types;
        ResponseHandler response_handler;
        ContentReceiverWithProgress content_receiver;
        DownloadProgress download_progress;
        UploadProgress upload_progress;
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
        const SSL *ssl = nullptr;
#endif

        bool has_header(const std::string &key) const;
        std::string get_header_value(const std::string &key, const char *def = "", size_t id = 0) const;
        size_t get_header_value_u64(const std::string &key, size_t def = 0, size_t id = 0) const;
        size_t get_header_value_count(const std::string &key) const;
        void set_header(const std::string &key, const std::string &val);
        bool has_trailer(const std::string &key) const;
        std::string get_trailer_value(const std::string &key, size_t id = 0) const;
        size_t get_trailer_value_count(const std::string &key) const;
        bool has_param(const std::string &key) const;
        std::string get_param_value(const std::string &key, size_t id = 0) const;
        size_t get_param_value_count(const std::string &key) const;
        bool is_multipart_form_data() const;

        inline std::string get_bearer_token_auth() 
        {
            if (has_header("Authorization")) 
            {
                constexpr auto bearer_header_prefix_len = text::str_len("Bearer ");
                return get_header_value("Authorization").substr(bearer_header_prefix_len);
            }
            return "";
        }

        void StartTimeout()
        {
            start_time_ = std::chrono::steady_clock::now();
        }

        void SetContentLength(size_t length)
        {
            content_length_ = length;
        }

        void SetContentProvider(ContentProvider&& content_provider)
        {
            content_provider_ = content_provider;
        }

        void SetIsChunkedContentProvider(bool is)
        {
            is_chunked_content_provider_ = is;
        }

        std::chrono::time_point<std::chrono::steady_clock> GetStartTime(void)
        {
            return start_time_;
        }

        const ContentProvider& GetContentProvider(void) const
        {
            return content_provider_;
        }

        bool IsChunkedContentProvider(void) const
        {
            return is_chunked_content_provider_;
        }

        size_t GetContentLength(void) const
        {
            return content_length_;
        }

    private:

        size_t redirect_count_ = 1;//CPPHTTPLIB_REDIRECT_MAX_COUNT;
        size_t content_length_ = 0;
        ContentProvider content_provider_;
        bool is_chunked_content_provider_ = false;
        size_t authorization_count_ = 0;
        std::chrono::time_point<std::chrono::steady_clock> start_time_ = (std::chrono::steady_clock::time_point::min)();
    };

}}}}

#endif//QOR_PP_H_COMPONENTS_PROTOCOLS_HTTP_REQUEST