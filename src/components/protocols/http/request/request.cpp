// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"
#include <regex>
#include <unordered_set>
#include "request.h"

namespace qor { namespace components { namespace protocols { namespace http {

    std::string HTTPRequest::AppendQueryParams(const std::string &path, const qor::components::protocols::http::Params &params) 
    {
        std::string path_with_query = path;
        thread_local const std::regex re("[^?]+\\?.*");
        auto delm = std::regex_match(path, re) ? '&' : '?';
        path_with_query += delm + qor::components::protocols::http::HTTPRequest::ParamsToQueryStr(params);
        return path_with_query;
    }

    std::string HTTPRequest::ParamsToQueryStr(const qor::components::protocols::http::Params &params)
    {
        std::string query;

        for (auto it = params.begin(); it != params.end(); ++it) 
        {
            if (it != params.begin()) { query += "&"; }
            query += qor::components::protocols::http::HTTPRequest::EncodeQueryComponent(it->first);
            query += "=";
            query += qor::components::protocols::http::HTTPRequest::EncodeQueryComponent(it->second);
        }
        return query;
    }

    std::string HTTPRequest::EncodeQueryComponent(const std::string &component, bool space_as_plus) 
    {
        std::string result;
        result.reserve(component.size() * 3);

        for (size_t i = 0; i < component.size(); i++) 
        {
            auto c = static_cast<unsigned char>(component[i]);

            // Unreserved characters per RFC 3986
            if (std::isalnum(c) || c == '-' || c == '.' || c == '_' || c == '~') 
            {
                result += static_cast<char>(c);
            }
            // Space handling
            else if (c == ' ') 
            {
                if (space_as_plus) 
                {
                    result += '+';
                } 
                else {
                    result += "%20";
                }
            }
            // Plus sign handling
            else if (c == '+') 
            {
                if (space_as_plus) 
                {
                    result += "%2B";
                } 
                else 
                {
                    result += static_cast<char>(c);
                }
            }
            // Query-safe sub-delimiters (excluding & and = which are query delimiters)
            else if (c == '!' || c == '$' || c == '\'' || c == '(' || c == ')' || c == '*' || c == ',' || c == ';') 
            {
                result += static_cast<char>(c);
            }
            // Colon and @ are allowed in query
            else if (c == ':' || c == '@') 
            {
                result += static_cast<char>(c);
            }
            // Forward slash is allowed in query values
            else if (c == '/') 
            {
                result += static_cast<char>(c);
            }
            // Question mark is allowed in query values (after first ?)
            else if (c == '?') 
            {
                result += static_cast<char>(c);
            } 
            else 
            {
                result += '%';
                char hex[3];
                snprintf(hex, sizeof(hex), "%02X", c);
                result.append(hex, 2);
            }
        }
        return result;
    }
}}}} //qor::components::protocols::http