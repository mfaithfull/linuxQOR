
// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include "fieldparser.h"
#include "src/components/parser/nodes/digit.h"
#include "src/components/parser/nodes/char.h"
#include "nodes/token.h"
#include "nodes/fieldcontent.h"
#include "nodes/field.h"

namespace qor { namespace components { namespace protocols { namespace http {

    void obs_text::Emit()
    {
        char charVal = m_result.first;
        GetParser()->PushNode(
            new_ref<components::parser::Char>(
                charVal, 
                static_cast<uint64_t>(m_token)
            ).AsRef<components::parser::Node>()
        );
    }

    void field_vchar::Emit()
    {
        char charVal = m_result.first;
        GetParser()->PushNode(
            new_ref<components::parser::Char>(
                charVal, 
                static_cast<uint64_t>(m_token)
            ).AsRef<components::parser::Node>()
        );
    }

    void field_content::Prepare()
    {
        GetParser()->PushNode(new_ref<FieldContent>().AsRef<components::parser::Node>());
    }

    void field_content::Emit()
    {
        std::string contentValue;
        auto node = GetParser()->PopNode();
        while(node.IsNotNull() && node->GetToken() != m_token)
        {
            uint64_t token = node->GetToken();
            
            if(token == static_cast<uint64_t>(httpFieldToken::field_vchar) ||
                token == static_cast<uint64_t>(components::parser::eToken::Space) ||
                token == static_cast<uint64_t>(components::parser::eToken::HorizontalTab))
            {
                auto characterNode = node.AsRef<components::parser::Char>();
                char c = characterNode->GetValue();
                contentValue = std::string(&c,1) + contentValue;
            }
            else
            {
                auto f = httpFieldtokenNames.find(token);
                std::string tokenName;
                if(f != httpFieldtokenNames.end())
                {
                    tokenName = f->second;
                }

                std::cout << "Emitting a field_content expected field_vhar or SP or HTAB found: " << std::endl;
                std::cout << tokenName << std::endl;
            }

            node = GetParser()->PopNode();
        }

        if(node.IsNotNull())
        {
            auto contentNode = node.AsRef<FieldContent>();
            contentNode->SetValue(contentValue);
            GetParser()->PushNode(node);
        }
    }

    void field_content::Fail()
    {
        auto node = GetParser()->PopNode();
        if(node.IsNotNull() && node->GetToken() != m_token)
        {
            GetParser()->PushNode(node);
        }
    }


    void tchar::Emit()
    {
        char charVal = m_result.first;
        GetParser()->PushNode(
            new_ref<components::parser::Char>(
                charVal, 
                static_cast<uint64_t>(m_token)
            ).AsRef<components::parser::Node>()
        );
    }

    void token::Prepare()
    {
        GetParser()->PushNode(new_ref<Token>().AsRef<components::parser::Node>());
    }

    void token::Emit()
    {
        std::string tokenValue;
        auto node = GetParser()->PopNode();
        while(node.IsNotNull() && node->GetToken() != m_token)
        {
            uint64_t token = node->GetToken();
            
            if(token == static_cast<uint64_t>(httpFieldToken::tchar))
            {
                auto characterNode = node.AsRef<components::parser::Char>();
                char c = characterNode->GetValue();
                tokenValue = std::string(&c,1) + tokenValue;
            }
            else
            {
                auto f = httpFieldtokenNames.find(token);
                std::string tokenName;
                if(f != httpFieldtokenNames.end())
                {
                    tokenName = f->second;
                }

                std::cout << "Emitting a token expected tchar found: " << std::endl;
                std::cout << tokenName << std::endl;
            }

            node = GetParser()->PopNode();
        }

        if(node.IsNotNull())
        {
            auto stringNode = node.AsRef<Token>();
            stringNode->SetValue(tokenValue);
            GetParser()->PushNode(node);
        }
    }

    void token::Fail()
    {
        auto node = GetParser()->PopNode();
        if(node.IsNotNull() && node->GetToken() != m_token)
        {
            GetParser()->PushNode(node);
        }
    }

    void field::Prepare()
    {
        GetParser()->PushNode(new_ref<Field>().AsRef<components::parser::Node>());
    }

    void field::Emit()
    {
        std::string name;
        std::string content;
        auto node = GetParser()->PopNode();
        while(node.IsNotNull() && node->GetToken() != m_token)
        {
            uint64_t token = node->GetToken();
            
            if(token == static_cast<uint64_t>(httpFieldToken::token))
            {
                auto tokenNode = node.AsRef<Token>();
                name = tokenNode->GetValue();
                node = GetParser()->PopNode();

                if(token == static_cast<uint64_t>(httpFieldToken::field_content))
                {
                    auto contentNode = node.AsRef<FieldContent>();
                    content = contentNode->GetValue();
                    node = GetParser()->PopNode();
                    break;
                }
                else
                {
                    auto f = httpFieldtokenNames.find(token);
                    std::string tokenName;
                    if(f != httpFieldtokenNames.end())
                    {
                        tokenName = f->second;
                    }

                    std::cout << "Emitting a field expected field_content found: " << std::endl;
                    std::cout << tokenName << std::endl;
                    break;
                }
            }
            else
            {
                auto f = httpFieldtokenNames.find(token);
                std::string tokenName;
                if(f != httpFieldtokenNames.end())
                {
                    tokenName = f->second;
                }

                std::cout << "Emitting a field expected token found: " << std::endl;
                std::cout << tokenName << std::endl;
                break;
            }
        }

        if(node.IsNotNull())
        {
            auto fieldNode = node.AsRef<Field>();
            fieldNode->SetName(name);
            fieldNode->SetContent(content);
            GetParser()->PushNode(node);
        }

    }

    void field::Fail()
    {
        auto node = GetParser()->PopNode();
        if(node.IsNotNull() && node->GetToken() != m_token)
        {
            GetParser()->PushNode(node);
        }
    }

}}}}//qor::components::protocols::http

