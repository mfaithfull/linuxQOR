// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_COMPONENTS_PROTOCOLS_HTTP_RESPONSEGENERATOR_STATE
#define QOR_PP_H_COMPONENTS_PROTOCOLS_HTTP_RESPONSEGENERATOR_STATE

#include <iostream>
#include <string>
#include "src/platform/compiler/compiler.h"
#include "src/framework/thread/currentthread.h"
#include "src/qor/reference/newref.h"
#include "src/framework/workflow/workflow.h"
#include "src/components/parser/context.h"
#include "../../protocol.h"

namespace qor { namespace components { namespace protocols { namespace http { namespace response {
    
    class qor_pp_module_interface(QOR_HTTP) Generator;
    
    class qor_pp_module_interface(QOR_HTTP) State : public workflow::State
    {
    public:

        inline State(Generator* generator) : workflow::State(generator)
        {}
        virtual inline ~State() = default;

    protected:

        inline parser::Context* GetContext()
        {
            return dynamic_cast<Generator*>(m_Workflow)->GetContext();
        }

        inline workflow::Workflow* Workflow()
        {
            return dynamic_cast<workflow::Workflow*>(m_Workflow);
        }

        Generator* GetGenerator()
        {
            return dynamic_cast<Generator*>(m_Workflow);
        }
    };

    class Char : public State
    {
    public:

        inline Char(Generator* generator, byte character) : State(generator)
        {
            m_EnteredAtLeastOnce = false;

            Enter = [this, character]()
            {
                m_EnteredAtLeastOnce = true;
                std::cout << (char)character;
                GetContext()->PutOctet(character);
                Workflow()->PopState();
            };

            Resume = [this]()
            {
                if(m_EnteredAtLeastOnce)
                {
                    Workflow()->PopState();
                }
            };
        }

        virtual inline ~Char() = default;

    private:

        bool m_EnteredAtLeastOnce;
    };

    class CRLF : public State
    {
    public:

        inline CRLF(Generator* generator) : State(generator)
        {
            m_EnteredAtLeastOnce = false;
            
            Enter = [this]()
            {            
                m_EnteredAtLeastOnce = true;            
                Workflow()->PushState(new_ref<Char>(GetGenerator(), 0x0A));//LF
                Workflow()->PushState(new_ref<Char>(GetGenerator(), 0x0D));//CR
            };

            Resume = [this]()
            {
                if(m_EnteredAtLeastOnce)
                {
                    Workflow()->PopState();
                }
            };
        }

        virtual inline ~CRLF() = default;

    private:
        bool m_EnteredAtLeastOnce;
    };

    class String : public State
    {
    public:

        inline String(Generator* generator, std::string str) : State(generator), m_str(str)
        {
            m_it = m_str.begin();
            m_EnteredAtLeastOnce = false;

            Enter = [this, str]()
            {
                m_EnteredAtLeastOnce = true;
                if(m_it != m_str.end())
                {                
                    Workflow()->PushState(new_ref<Char>(GetGenerator(), (byte)(*m_it)));
                }
                else
                {
                    Workflow()->PopState();
                }
            };

            Resume = [this]()
            {
                if(m_EnteredAtLeastOnce == true)
                {
                    ++m_it;
                }
            };

        }

        virtual inline ~String() = default;

    private:

        std::string::iterator m_it;
        std::string m_str;
        bool m_EnteredAtLeastOnce;
    };

    class ReasonPhrase : public State
    {
    public:

        inline ReasonPhrase(Generator* generator) : State(generator)
        {
            m_EnteredAtLeastOnce = false;

            Enter = [this]()
            {
                note("Entered Reason Phrase");
                m_EnteredAtLeastOnce = true;
                auto gen = GetGenerator();
                auto response = gen->GetResponse();
                unsigned int code = response->GetStatus();
                std::string phrase = HTTPProtocol::GetReasonPhrase(code);
                Workflow()->SetState(new_ref<String>(gen, phrase));
            };

            Resume = [this]()
            {
                note("Resumed Reason Phrase");
                if(m_EnteredAtLeastOnce == true)
                {
                    Workflow()->PopState();
                }
            };

        }

        virtual inline ~ReasonPhrase() = default;

    private:

        bool m_EnteredAtLeastOnce;
    };

    class StatusCode : public State
    {
    public:

        inline StatusCode(Generator* generator) : State(generator)
        {
            m_EnteredAtLeastOnce = false;            

            Enter = [this]()
            {
                note("Entered Status Code");
                m_EnteredAtLeastOnce = true;
                auto gen = GetGenerator();
                auto response = gen->GetResponse();
                unsigned int code = response->GetStatus();
                std::string status = std::format("{0}", code);
                Workflow()->SetState(new_ref<String>(gen, status));
            };

            Resume = [this]()
            {
                note("Resumed Status Code");
                if(m_EnteredAtLeastOnce == true)
                {
                    Workflow()->PopState();
                }
            };

        }

        virtual inline ~StatusCode() = default;

    private:

        bool m_EnteredAtLeastOnce;
    };

    //HTTP-Version   = "HTTP" "/" 1*DIGIT "." 1*DIGIT
    class Version : public State
    {
    public:

        inline Version(Generator* generator) : State(generator)
        {
            m_EnteredAtLeastOnce = false;

            Enter = [this]()
            {
                note("Entered Version");
                m_EnteredAtLeastOnce = true;
                auto gen = GetGenerator();
                auto response = gen->GetResponse();
                HTTPVersion version = response->GetVersion();

                std::string major = std::format("{0}", version.major);
                std::string minor = std::format("{0}", version.minor);

                Workflow()->PushState(new_ref<String>(gen, minor));
                Workflow()->PushState(new_ref<Char>(gen, '.'));
                Workflow()->PushState(new_ref<String>(gen, major));
                Workflow()->PushState(new_ref<String>(gen, "HTTP/"));
            };

            Resume = [this]()
            {
                note("Resumed Version");
                if(m_EnteredAtLeastOnce == true)
                {
                    Workflow()->PopState();
                }
            };

        }

        virtual inline ~Version() = default;

    private:

        bool m_EnteredAtLeastOnce;
    };

    //Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
    class StatusLine : public State
    {
    public:

        inline StatusLine(Generator* generator) : State(generator)
        {
            m_EnteredAtLeastOnce = false;

            Enter = [this]()
            {
                note("Entered Status Line");
                m_EnteredAtLeastOnce = true;
                Workflow()->PushState(new_ref<CRLF>(GetGenerator()));
                Workflow()->PushState(new_ref<ReasonPhrase>(GetGenerator()));
                Workflow()->PushState(new_ref<Char>(GetGenerator(), ' '));
                Workflow()->PushState(new_ref<StatusCode>(GetGenerator()));
                Workflow()->PushState(new_ref<Char>(GetGenerator(), ' '));
                Workflow()->PushState(new_ref<Version>(GetGenerator()));
            };

            Resume = [this]()
            {
                note("Resumed Status Line");
                if(m_EnteredAtLeastOnce == true)
                {
                    Workflow()->PopState();
                }
            };

        }

        virtual inline ~StatusLine() = default;

    private:

        bool m_EnteredAtLeastOnce;
    };

    class Header : public State
    {
    public:
        inline Header(Generator* generator, std::pair<const std::string, std::string> header) : State(generator), m_key(header.first), m_value(header.second)
        {
            m_EnteredAtLeastOnce = false;

            Enter = [this]()
            {
                note("Entered Header");
                m_EnteredAtLeastOnce = true;
                auto gen = GetGenerator();
                Workflow()->PushState(new_ref<String>(gen, m_value));
                Workflow()->PushState(new_ref<Char>(gen, ':'));
                Workflow()->PushState(new_ref<String>(gen, m_key));
            };

            Resume = [this]()
            {
                note("Resumed Header");
                if(m_EnteredAtLeastOnce == true)
                {
                    Workflow()->PopState();
                }
            };
        }

        virtual inline ~Header() = default;

    private:

        bool m_EnteredAtLeastOnce;
        std::string m_key;
        std::string m_value;
    };

    class Headers : public State
    {
    public:

        inline Headers(Generator* generator) : State(generator)
        {
            m_EnteredAtLeastOnce = false;

            Enter = [this]()
            {
                note("Entered Headers");
                m_EnteredAtLeastOnce = true;
                auto gen = GetGenerator();
                auto response = gen->GetResponse();
                for(auto header : response->GetHeaders())
                {
                    Workflow()->PushState(new_ref<Header>(gen, header));
                }
                if(response->GetHeaders().size() == 0 )
                {
                    Workflow()->PopState();
                }
            };

            Resume = [this]()
            {
                note("Resumed Headers");
                if(m_EnteredAtLeastOnce == true)
                {
                    Workflow()->PopState();
                }
            };

        }

        virtual inline ~Headers() = default;

    private:

        bool m_EnteredAtLeastOnce;
    };

    class Body : public State
    {
    public:

        inline Body(Generator* generator) : State(generator)
        {
            m_EnteredAtLeastOnce = false;

            Enter = [this]()
            {
                note("Entered Body");
                m_EnteredAtLeastOnce = true;
                Workflow()->PopState();
            };

            Resume = [this]()
            {
                note("Resumed Body");
                if(m_EnteredAtLeastOnce == true)
                {
                    Workflow()->PopState();
                }
            };

        }

        virtual inline ~Body() = default;

    private:

        bool m_EnteredAtLeastOnce;
    };

    class qor_pp_module_interface(QOR_HTTP) GenerateResponse : public State
    {
    public:

        inline GenerateResponse(Generator* generator) : State(generator)
        {
            Enter = [this]()
            {                
                note("Entered Initial");
                auto gen = GetGenerator();
                Workflow()->PushState(new_ref<Body>(gen));
                Workflow()->PushState(new_ref<CRLF>(gen));
                Workflow()->PushState(new_ref<Headers>(gen));
                Workflow()->PushState(new_ref<StatusLine>(gen));
            };

            Resume = [this]()
            {
                note("Resumed Initial");
                Workflow()->PopState();
            };
        }

        virtual ~GenerateResponse() = default;
    };

/*
Response      = Status-Line
                       *(( general-header
                        | response-header
                        | entity-header ) CRLF)
                       CRLF
                       [ message-body ]
*/

}}}}}//qor::components::protocols::http::response

#endif//QOR_PP_H_COMPONENTS_PROTOCOLS_HTTP_RESPONSEGENERATOR_STATE