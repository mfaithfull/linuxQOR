// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_COMPONENTS_PROTOCOLS_HTTP_DETAIL_PORTING
#define QOR_PP_H_COMPONENTS_PROTOCOLS_HTTP_DETAIL_PORTING

#include <string>
#include <limits>
#include <unordered_set>

namespace qor { namespace components { namespace protocols { namespace http { namespace detail {

    namespace case_ignore {

        inline unsigned char to_lower(int c) 
        {
            const static unsigned char table[256] = 
            {
                0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   10,  11,  12,  13,  14,
                15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
                30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,
                45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
                60,  61,  62,  63,  64,  97,  98,  99,  100, 101, 102, 103, 104, 105, 106,
                107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,
                122, 91,  92,  93,  94,  95,  96,  97,  98,  99,  100, 101, 102, 103, 104,
                105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
                120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134,
                135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,
                150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164,
                165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179,
                180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 224, 225, 226,
                227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241,
                242, 243, 244, 245, 246, 215, 248, 249, 250, 251, 252, 253, 254, 223, 224,
                225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
                240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254,
                255,
            };
            return table[(unsigned char)(char)c];
        }

        inline bool equal(const std::string &a, const std::string &b) 
        {
            return a.size() == b.size() && std::equal(a.begin(), a.end(), b.begin(), [](char ca, char cb) 
                {
                    return to_lower(ca) == to_lower(cb);
                }
            );
        }

        struct equal_to 
        {
            bool operator()(const std::string &a, const std::string &b) const 
            {
                return equal(a, b);
            }
        };

        struct hash 
        {
            size_t operator()(const std::string &key) const 
            {
                return hash_core(key.data(), key.size(), 0);
            }

            size_t hash_core(const char *s, size_t l, size_t h) const 
            {
                return (l == 0) ? h
                                : hash_core(s + 1, l - 1,
                                            // Unsets the 6 high bits of h, therefore no
                                            // overflow happens
                                            (((std::numeric_limits<size_t>::max)() >> 6) &
                                            h * 33) ^
                                                static_cast<unsigned char>(to_lower(*s)));
            }
        };

        template <typename T>
        using unordered_set = std::unordered_set<T, detail::case_ignore::hash, detail::case_ignore::equal_to>;

    } //case_ignore


}}}}}//qor::components::protocols::http::detail

#endif//QOR_PP_H_COMPONENTS_PROTOCOLS_HTTP_DETAIL_PORTING

