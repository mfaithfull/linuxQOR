// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_COMPONENTS_PROTOCOLS_HTTP_TEXT_UTILS
#define QOR_PP_H_COMPONENTS_PROTOCOLS_HTTP_TEXT_UTILS

#include <utility>
#include <string>
#include <functional>
#include <limits>

namespace qor { namespace components { namespace protocols { namespace http { namespace text {

    void split(const char *b, const char *e, char d, std::function<void(const char *, const char *)> fn);
    void split(const char *b, const char *e, char d, size_t m, std::function<void(const char *, const char *)> fn);

    template <size_t N> inline constexpr size_t str_len(const char (&)[N]) 
    {
        return N - 1;
    }

    inline bool is_space_or_tab(char c) 
    { 
        return c == ' ' || c == '\t'; 
    }

    inline std::pair<size_t, size_t> trim(const char *b, const char *e, size_t left,size_t right) 
    {
        while (b + left < e && is_space_or_tab(b[left])) 
        {
            left++;
        }
        while (right > 0 && is_space_or_tab(b[right - 1])) 
        {
            right--;
        }
        return std::make_pair(left, right);
    }

    inline std::string trim_copy(const std::string &s) 
    {
        auto r = trim(s.data(), s.data() + s.size(), 0, s.size());
        return s.substr(r.first, r.second - r.first);
    }

    inline std::string trim_double_quotes_copy(const std::string &s) 
    {
        if (s.length() >= 2 && s.front() == '"' && s.back() == '"') 
        {
            return s.substr(1, s.size() - 2);
        }
        return s;
    }

    inline void divide(const char *data, std::size_t size, char d, std::function<void(const char *, std::size_t, const char *, std::size_t)> fn) 
    {
        const auto it = std::find(data, data + size, d);
        const auto found = static_cast<std::size_t>(it != data + size);
        const auto lhs_data = data;
        const auto lhs_size = static_cast<std::size_t>(it - data);
        const auto rhs_data = it + found;
        const auto rhs_size = size - lhs_size - found;

        fn(lhs_data, lhs_size, rhs_data, rhs_size);
    }

    inline void divide(const std::string &str, char d, std::function<void(const char *, std::size_t, const char *, std::size_t)> fn) 
    {
        divide(str.data(), str.size(), d, std::move(fn));
    }

    inline void split(const char *b, const char *e, char d, std::function<void(const char *, const char *)> fn) 
    {
        return split(b, e, d, (std::numeric_limits<size_t>::max)(), std::move(fn));
    }

    inline void split(const char *b, const char *e, char d, size_t m, std::function<void(const char *, const char *)> fn) 
    {
        size_t i = 0;
        size_t beg = 0;
        size_t count = 1;

        while (e ? (b + i < e) : (b[i] != '\0')) 
        {
            if (b[i] == d && count < m) 
            {
                auto r = trim(b, e, beg, i);
                if (r.first < r.second) 
                { 
                    fn(&b[r.first], &b[r.second]); 
                }
                beg = i + 1;
                count++;
            }
            i++;
        }

        if(i) 
        {
            auto r = trim(b, e, beg, i);
            if (r.first < r.second) 
            { 
                fn(&b[r.first], &b[r.second]); 
            }
        }
    }

}}}}}//qor::components::protocols::http::text

#endif//QOR_PP_H_COMPONENTS_PROTOCOLS_HTTP_TEXT_UTILS

