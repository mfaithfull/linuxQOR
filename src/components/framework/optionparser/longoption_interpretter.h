// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_OPTIONPARSER_LONGOPTIONINTERPRETTER
#define QOR_PP_H_OPTIONPARSER_LONGOPTIONINTERPRETTER

#include <stdlib.h>
#include <string.h>

#include "option.h"
#include "argument_iterator.h"

namespace qor{ namespace components{ namespace optparser {

    //Helper to match long options
    class LongOptInterpretter
    {
    public:

        LongOptInterpretter(Context& optionsContext, ShortOptInterpretter& shortinterpretter, arg_iter& it ) : 
        m_optionsContext(optionsContext), shortOptionInterpretter(shortinterpretter), itArgument(it)
        {        
            m_LongOptionIndex = 0;
            m_LongOnly = false;   
            m_pLongOptions = nullptr;    
        }

        void Init(const Option* longOptions)
        {
            m_pLongOptions = longOptions;
        }

        bool HasLongOptions()
        {
            return m_pLongOptions != nullptr ? true : false;
        }

        void SetLongOnly(bool longOnly)
        {
            m_LongOnly = longOnly;            
        }

        bool IsLongOnly()
        {
            return m_LongOnly;
        }

        void SetIndex(int index)
        {
            m_LongOptionIndex = index;
        }

        int Getindex()
        {
            return m_LongOptionIndex;
        }

        const char* GetName()
        {
            return m_pLongOptions[m_LongOptionIndex].name;
        }

        int ProcessLongOption(const char* prefix)
        {
            char* nameend = nullptr;
            size_t namelen = 0;
            const Option* p = nullptr;
            const Option* pfound = nullptr;
            int n_options = 0;
            int option_index = 0;
    
            for (nameend = m_optionsContext.m_pNextChar; *nameend && *nameend != '='; nameend++)
                /* Do nothing.  */;
    
            namelen = nameend - m_optionsContext.m_pNextChar;
    
            // First look for an exact match, counting the options as a side effect.
            for (p = m_pLongOptions, n_options = 0; p->name; p++, n_options++)
            {
                if (!strncmp(p->name, m_optionsContext.m_pNextChar, namelen) && namelen == strlen(p->name))
                {	// Exact match found.	
                    pfound = p;
                    option_index = n_options;
                    break;
                }
            }
    
            if (pfound == nullptr && HandleLongOptionAbbreviations(n_options, namelen, option_index, pfound, prefix))
            {
                return '?';
            }
    
            return (pfound == nullptr) ? HandleLongOptionUnrecognized(prefix) : ConsumeLongOption(nameend, pfound, option_index, prefix);
        }
    
        bool HandleLongOptionAbbreviations(int n_options, size_t namelen, int& option_index, const Option* pfound, const char* prefix)
        {
            // Didn't find an exact match, so look for abbreviations.
            const Option* p;
            unsigned char* ambig_set = nullptr;
            int ambig_malloced = 0;
            int ambig_fallback = 0;
            int indfound = -1;
            for (p = m_pLongOptions, option_index = 0; p->name; p++, option_index++)
            {
                if (!strncmp(p->name, m_optionsContext.m_pNextChar, namelen))
                {
                    HandleLongOptionAbbreviation(pfound, p, indfound, option_index, ambig_set, ambig_fallback, ambig_malloced, n_options);
                }
            }
            if (ambig_set || ambig_fallback)
            {
                if (m_optionsContext.m_RaiseErrors)
                {
                    if (ambig_fallback)
                    {
                        //issue::continuable(_TXT("%s: option '%s%s' is ambiguous\n"));
                        //fprintf(stderr, _ATXT("%s: option '%s%s' is ambiguous\n"), m_argv[0], prefix, m_pNextChar);
                    }
                    else
                    {
                        //TODO:flockfile(stderr);
                        //fprintf(stderr, _ATXT("%s: option '%s%s' is ambiguous; possibilities:"), m_argv[0], prefix, m_pNextChar);
                        for (option_index = 0; option_index < n_options; option_index++)
                        {
                            if (ambig_set[option_index])
                            {
                                //fprintf(stderr, " '%s%s'", prefix, m_pLongOptions[option_index].name);
                            }
                        }
                        //fprintf(stderr, "\n");
                        //TODO: funlockfile(stderr);
                    }
                }
                if (ambig_malloced)
                {
                    free(ambig_set);
                }
                m_optionsContext.m_pNextChar += strlen(m_optionsContext.m_pNextChar);
                itArgument.Next();
                m_optionsContext.m_OptionOption = 0;
                return true;
            }
            option_index = indfound;
            return false;
        }
    
        void HandleLongOptionAbbreviation(const Option* pfound, const Option* p, int& indfound, int& option_index, unsigned char* ambig_set, int& ambig_fallback, int& ambig_malloced, int n_options)
        {
            if (pfound == nullptr)
            {	// First nonexact match found.
                pfound = p;
                indfound = option_index;
            }
            else if (m_LongOnly || pfound->has_arg != p->has_arg || pfound->flag != p->flag || pfound->val != p->val)
            {	// Second or later nonexact match found.
                if (!ambig_fallback)
                {
                    if (!m_optionsContext.m_RaiseErrors)
                    {
                        // Don't waste effort tracking the ambig set if we're not going to print it anyway.
                        ambig_fallback = 1;
                    }
                    else if (!ambig_set)
                    {
                        if ((ambig_set = (unsigned char*)malloc(n_options)) == nullptr)
                        {
                            // Fall back to simpler error message.
                            ambig_fallback = 1;
                        }
                        else
                        {
                            ambig_malloced = 1;
                        }
                        if (ambig_set)
                        {
                            memset(ambig_set, 0, n_options);
                            ambig_set[indfound] = 1;
                        }
                    }
                    if (ambig_set)
                    {
                        ambig_set[option_index] = 1;
                    }
                }
            }
        }
    
        int HandleLongOptionUnrecognized(const char* prefix)
        {
            // Can't find it as a long option.  If this is not getopt_long_only,
            //or the option starts with '--' or is not a valid short option, then it's an error.
            if (!m_LongOnly || itArgument.Arg()[1] == '-' || shortOptionInterpretter.Find(*m_optionsContext.m_pNextChar) == nullptr)
            {
                if (m_optionsContext.m_RaiseErrors)
                {
                    //fprintf(stderr, _ATXT("%s: unrecognized option '%s%s'\n"), m_argv[0], prefix, m_pNextChar);
                }
                m_optionsContext.m_pNextChar = nullptr;
                itArgument.Next();
                m_optionsContext.m_OptionOption = 0;
                return '?';
            }
            // Otherwise interpret it as a short option.
            return -1;
        }
    
        int ConsumeLongOption(char* nameend, const Option* pfound, int option_index, const char* prefix)
        {
            itArgument.Next();
            m_optionsContext.m_pNextChar = nullptr;
            if (*nameend && CheckForLongOptionArgumentDisallowed(nameend, pfound, prefix))
            {
                return '?';
            }
            else if (pfound->has_arg == 1 && CheckForLongOptionArgumentRequired(pfound, prefix))
            {
                return shortOptionInterpretter.ColonQuestion();
            }
    
            m_LongOptionIndex = option_index;
    
            if (pfound->flag)
            {
                *(pfound->flag) = pfound->val;
                return 0;
            }
            return pfound->val;
        }
    
        bool CheckForLongOptionArgumentRequired(const Option* pfound, const char* prefix)
        {
            bool bResult = false;
            if (itArgument.NotAtEnd())
            {
                m_optionsContext.m_pArgument = itArgument.NextArg();
            }
            else
            {
                if (m_optionsContext.m_RaiseErrors)
                {
                    //fprintf(stderr, _ATXT("%s: option '%s%s' requires an argument\n"), m_argv[0], prefix, pfound->name);
                }
                m_optionsContext.m_OptionOption = pfound->val;
                bResult = true;
            }
            return bResult;
        }
    
        bool CheckForLongOptionArgumentDisallowed(char* nameend, const Option* pfound, const char* prefix)
        {
            bool bResult = false;
            if (pfound->has_arg)
            {
                m_optionsContext.m_pArgument = nameend + 1;
            }
            else
            {
                if (m_optionsContext.m_RaiseErrors)
                {
                    //fprintf(stderr, _ATXT("%s: option '%s%s' doesn't allow an argument\n"), m_argv[0], prefix, pfound->name);
                }
                m_optionsContext.m_OptionOption = pfound->val;
                return true;
            }
            return bResult;
        }
            
    private:

        Context& m_optionsContext;
        ShortOptInterpretter& shortOptionInterpretter;
        arg_iter& itArgument;

        bool m_LongOnly;
        const Option* m_pLongOptions;        
        int m_LongOptionIndex;

    };

}}}//qor::components::optparser

#endif//QOR_PP_H_OPTIONPARSER_LONGOPTIONINTERPRETTER
