// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_OPTIONPARSER_ARGITERATOR
#define QOR_PP_H_OPTIONPARSER_ARGITERATOR

#include <stdlib.h>
#include <string.h>

namespace qor{ namespace components{ namespace optparser {

    //Manages the walk through the elements of argv parameter as passed to main
    class arg_iter
    {
    private:

        int m_Index;
        char** m_argv;
        int m_argc;

    public:

        arg_iter()
        {
            m_Index = 0;
            m_argv = nullptr;
            m_argc = 0;
        }

        int IsEmpty()
        {
            return (m_argc < 1) ? true : false;
        }

        int Init(int argc, char** arguments)
        {
            m_Index = 1;
            m_argc = argc;
            m_argv = arguments;
            return m_Index;
        }

        int Begin()
        {
            m_Index = 1;
            return m_Index;
        }

        int Index()
        {
            return m_Index;
        }

        int Set(int i)
        {
            m_Index = i;
            return m_Index;
        }

        int Next()
        {
            return m_Index++;
        }

        int Inc()
        {
            return ++m_Index;
        }

        char* Arg()
        {
            return m_argv[m_Index];
        }

        char* Arg(int i)
        {
            return m_argv[i];
        }
        
        char* NextArg()
        {
            return m_argv[m_Index++];
        }

        bool NotAtEnd()
        {
            return (m_Index < m_argc) ? true : false;
        }

        bool AtEnd()
        {
            return (m_Index == m_argc) ? true : false;
        }

        int SetEnd()
        {
            m_Index = m_argc;
            return m_Index;
        }

        int End()
        {
            return m_argc;
        }

        bool AtNonOption()
        {
            return (m_argv[m_Index][0] != '-' || m_argv[m_Index][1] == '\0') ? true : false;
        }

        bool AtLongOption()
        {
            return (m_argv[m_Index][1] == '-') ? true : false;
        }

        void SwapTop(int bottom, int middle, int top, int i)
        {
            char* temp = m_argv[bottom + 1];
            m_argv[bottom + i] = m_argv[top - (middle - bottom) + i];
            m_argv[top - (middle - bottom) + i] = temp;
        }

        void SwapBottom(int bottom, int middle, int i)
        {
            char* temp = m_argv[bottom + i];
            m_argv[bottom + i] = m_argv[middle + i];
            m_argv[middle + i] = temp;
        }

        void SkipNonOptions()
        {
            while (m_Index < m_argc && (m_argv[m_Index][0] != '-' || m_argv[m_Index][1] == '\0'))
            {
                m_Index++;
            }    
        }

        bool IsDoubleDash()
        {
            return (m_Index != m_argc && !strcmp(m_argv[m_Index], "--")) ? true : false;
        }

    };

}}}//qor::components::optparser

#endif//QOR_PP_H_OPTIONPARSER_ARGITERATOR
