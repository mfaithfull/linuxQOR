// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include <cassert>

#include "widgetbase.h"
#include "event.h"

namespace qor{ namespace components{ namespace ui {

    WidgetBase::~WidgetBase() 
    {
        DetachAllChildren();
    }

    //Return the parent WidgetBase, or null
    WidgetBase* WidgetBase::Parent() const 
    {
        return parent_;
    }

    //Access the child at index `i`.
    Widget& WidgetBase::ChildAt(size_t i) 
    {
        assert(i < ChildCount());
        return children_[i];
    }

    size_t WidgetBase::ChildCount() const 
    {
        return children_.size();
    }

    //Return index of the component in its parent. -1 if no parent.
    int WidgetBase::Index() const 
    {
        if (parent_ == nullptr) 
        {
            return -1;
        }
        int index = 0;
        for (const Widget& child : parent_->children_) 
        {
            if (child.get() == this) 
            {
                return index;
            }
            index++;
        }
        return -1;  // Not reached.
    }

    //Add a child.
    void WidgetBase::Add(Widget child) 
    {
        child->Detach();
        child->parent_ = this;
        children_.push_back(std::move(child));
    }

    //Detach this child from its parent.
    void WidgetBase::Detach() 
    {
        if (parent_ == nullptr) {
            return;
        }
        auto it = std::find_if(std::begin(parent_->children_), std::end(parent_->children_), [this](const Widget& that) 
            {
                return this == that.get();
            }
        );
        WidgetBase* parent = parent_;
        parent_ = nullptr;
        parent->children_.erase(it);  // Might delete |this|.
    }

    //Remove all children.
    void WidgetBase::DetachAllChildren() 
    {
        while (!children_.empty()) 
        {
            children_[0]->Detach();
        }
    }

    //Draw the component.
    /// Build an Element to be 'drawn' on the target representing this
    /// Widget. Please override OnRender() to modify the rendering.
    Element WidgetBase::Render() 
    {
        // Some users might call `ComponentBase::Render()` from
        // `T::OnRender()`. To avoid infinite recursion, we use a flag.
        if (in_render) 
        {
            return WidgetBase::OnRender();
        }

        in_render = true;
        Element element = OnRender();
        in_render = false;

        class Wrapper : public Node 
        {
        public:
            bool active_ = false;

            Wrapper(Element child, bool active) : Node({std::move(child)}), active_(active) {}

            void SetBox(Box box) override 
            {
                Node::SetBox(box);
                if(children_[0])
                {
                    children_[0]->SetBox(box);
                }
            }

            void ComputeRequirement() override 
            {
                Node::ComputeRequirement();
                requirement_.focused.component_active = active_;
            }
        };

        return std::make_shared<Wrapper>(std::move(element), Active());
    }

    //Draw the component.
    Element WidgetBase::OnRender() 
    {
        if (children_.size() == 1) 
        {
            return children_.front()->Render();
        }

        return Element();
        //TODO: return text("Not implemented component");
    }

    //Called in response to an event.
    //return True when the event has been handled.
    // The default implementation calls OnEvent for every child until one returns true. If none returns true, return false.
    bool WidgetBase::OnEvent(Event event) 
    {
        for(Widget& child : children_) 
        {
            if (child->OnEvent(event)) 
            {
                return true;
            }
        }
        return false;
    }

    //Called in response to an animation event.
    // The default implementation dispatches the event to every child.
    void WidgetBase::OnAnimation(animation::Params& params) 
    {
        for (const Widget& child : children_) 
        {
            child->OnAnimation(params);
        }
    }

    //Return the currently Active child.
    Widget WidgetBase::ActiveChild() 
    {
        for (auto& child : children_) 
        {
            if (child->Focusable()) 
            {
                return child;
            }
        }
        return nullptr;
    }

    //Return true when the component contains focusable elements.
    //The non focusable Components will be skipped when navigating using the keyboard.
    bool WidgetBase::Focusable() const 
    {
        for (const Widget& child : children_) 
        {
            if (child->Focusable()) 
            {
                return true;
            }
        }
        return false;
    }

    //Returns true if the element is the currently active child of its parent.
    bool WidgetBase::Active() const 
    {
        return parent_ == nullptr || parent_->ActiveChild().get() == this;
    }

    // Returns if the elements is focused by the user.
    bool WidgetBase::Focused() const 
    {
        const auto* current = this;
        while (current && current->Active()) 
        {
            current = current->parent_;
        }
        return !current && Focusable();
    }

    //Make the |child| to be the "active" one.
    void WidgetBase::SetActiveChild([[maybe_unused]] WidgetBase* child) 
    {        
    }

    //Make the |child| to be the "active" one.
    void WidgetBase::SetActiveChild(Widget child) 
    {
        SetActiveChild(child.get());
    }

    //Configure all the ancestors to give focus to this component.
    void WidgetBase::TakeFocus() 
    {
        WidgetBase* child = this;
        while (WidgetBase* parent = child->parent_) 
        {
            parent->SetActiveChild(child);
            child = parent;
        }
    }

    //Take the CapturedMouse if available. There is only one component of them. It represents a component taking priority over others.
    /*
    CapturedMouse WidgetBase::CaptureMouse(const Event& event) 
    {
        if (event.screen_) 
        {
            return event.screen_->CaptureMouse();
        }
        return std::make_unique<CaptureMouseImpl>();
    }
    */

}}}//qor::components::ui

