// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

/*
 * Copyright (c) 2020 - 2025 the ThorVG project. All rights reserved.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
#include "src/configuration/configuration.h"
#include "gpubuffer.h"

#include <math.h>
#include <string.h>

namespace qor{ namespace components{ namespace ui{ namespace renderer{

    /************************************************************************/
    /* GlGpuBuffer Implementation                                           */
    /************************************************************************/

    static GLint _getGpuBufferAlign(qor::ref_of<qor::components::OpenGLESFeature>::type openGLES) 
    {
        static GLint offset = 0;

        if (!offset)
        {
            openGLES->GetIntegerv(GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT, &offset);
        }

        return offset;
    }


    void GlGpuBuffer::updateBufferData(Target target, uint32_t size, const void* data)
    {
        m_openGLES->BufferData(static_cast<uint32_t>(target), size, data, GL_STATIC_DRAW);
    }


    void GlGpuBuffer::bind(Target target)
    {
        m_openGLES->BindBuffer(static_cast<uint32_t>(target), mGlBufferId);
    }


    void GlGpuBuffer::unbind(Target target)
    {
        m_openGLES->BindBuffer(static_cast<uint32_t>(target), 0);
    }

    GlGpuBuffer::GlGpuBuffer(ref_of<OpenGLESFeature>::type openGLES) : m_openGLES(openGLES)
    {
        m_openGLES->GenBuffers(1, &mGlBufferId);
        assert(mGlBufferId != 0);
    }


    GlGpuBuffer::~GlGpuBuffer()
    {
        if (mGlBufferId)
        {
            m_openGLES->DeleteBuffers(1, &mGlBufferId);
        }
    }

    /************************************************************************/
    /* GlStageBuffer Implementation                                         */
    /************************************************************************/

    GlStageBuffer::GlStageBuffer(ref_of<OpenGLESFeature>::type openGLES) : m_openGLES(openGLES), mVao(0), mGpuBuffer(openGLES), mGpuIndexBuffer(openGLES)
    {
        m_openGLES->GenVertexArrays(1, &mVao);
    }


    GlStageBuffer::~GlStageBuffer()
    {
        if (mVao) {
            m_openGLES->DeleteVertexArrays(1, &mVao);
            mVao = 0;
        }
    }


    uint32_t GlStageBuffer::push(void *data, uint32_t size, bool alignGpuOffset)
    {
        if (alignGpuOffset) alignOffset(size);

        uint32_t offset = mStageBuffer.count;

        if (this->mStageBuffer.reserved - this->mStageBuffer.count < size) {
            this->mStageBuffer.grow(std::max(size, this->mStageBuffer.reserved));
        }

        memcpy(this->mStageBuffer.data + offset, data, size);

        this->mStageBuffer.count += size;

        return offset;
    }


    uint32_t GlStageBuffer::pushIndex(void *data, uint32_t size)
    {
        uint32_t offset = mIndexBuffer.count;

        if (this->mIndexBuffer.reserved - this->mIndexBuffer.count < size) {
            this->mIndexBuffer.grow(std::max(size, this->mIndexBuffer.reserved));
        }

        memcpy(this->mIndexBuffer.data + offset, data, size);

        this->mIndexBuffer.count += size;

        return offset;
    }


    bool GlStageBuffer::flushToGPU()
    {
        if (mStageBuffer.empty() || mIndexBuffer.empty()) {
            mStageBuffer.clear();
            mIndexBuffer.clear();
            return false;
        }


        mGpuBuffer.bind(GlGpuBuffer::Target::ARRAY_BUFFER);
        mGpuBuffer.updateBufferData(GlGpuBuffer::Target::ARRAY_BUFFER, mStageBuffer.count, mStageBuffer.data);
        mGpuBuffer.unbind(GlGpuBuffer::Target::ARRAY_BUFFER);

        mGpuIndexBuffer.bind(GlGpuBuffer::Target::ELEMENT_ARRAY_BUFFER);
        mGpuIndexBuffer.updateBufferData(GlGpuBuffer::Target::ELEMENT_ARRAY_BUFFER, mIndexBuffer.count, mIndexBuffer.data);
        mGpuIndexBuffer.unbind(GlGpuBuffer::Target::ELEMENT_ARRAY_BUFFER);

        mStageBuffer.clear();
        mIndexBuffer.clear();

        return true;
    }


    void GlStageBuffer::bind()
    {
        m_openGLES->BindVertexArray(mVao);
        mGpuBuffer.bind(GlGpuBuffer::Target::ARRAY_BUFFER);
        mGpuBuffer.bind(GlGpuBuffer::Target::UNIFORM_BUFFER);
        mGpuIndexBuffer.bind(GlGpuBuffer::Target::ELEMENT_ARRAY_BUFFER);
    }


    void GlStageBuffer::unbind()
    {
        m_openGLES->BindVertexArray(0);
        mGpuBuffer.unbind(GlGpuBuffer::Target::ARRAY_BUFFER);
        mGpuBuffer.unbind(GlGpuBuffer::Target::UNIFORM_BUFFER);
        mGpuIndexBuffer.unbind(GlGpuBuffer::Target::ELEMENT_ARRAY_BUFFER);
    }


    GLuint GlStageBuffer::getBufferId()
    {
        return mGpuBuffer.getBufferId();
    }


    void GlStageBuffer::alignOffset(uint32_t size)
    {

        uint32_t alignment = _getGpuBufferAlign(m_openGLES);

        if (mStageBuffer.count % alignment == 0) return;


        uint32_t offset = alignment - mStageBuffer.count % alignment;

        if (mStageBuffer.count + offset + size > mStageBuffer.reserved) {
            mStageBuffer.grow(std::max(offset + size, mStageBuffer.reserved));
        }

        mStageBuffer.count += offset;
    }

}}}}//qor::components::ui::renderer