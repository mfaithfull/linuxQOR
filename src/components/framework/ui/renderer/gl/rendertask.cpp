// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

/*
 * Copyright (c) 2020 - 2025 the ThorVG project. All rights reserved.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
#include "src/configuration/configuration.h"
#include "rendertask.h"
#include "program.h"
#include "renderpass.h"

namespace qor{ namespace components{ namespace ui{ namespace renderer{

/************************************************************************/
/* GlRenderTask Class Implementation                                    */
/************************************************************************/

GlRenderTask::GlRenderTask(qor::ref_of<qor::components::OpenGLESFeature>::type openGLES, GlProgram* program, GlRenderTask* other): m_openGLES(openGLES), mProgram(program)
{
    mVertexLayout.push(other->mVertexLayout);
    mViewport = other->mViewport;
    mIndexOffset = other->mIndexOffset;
    mIndexCount = other->mIndexCount;
}


void GlRenderTask::run()
{
    // bind shader
    mProgram->load();

    int32_t dLoc = mProgram->getUniformLocation("uDepth");
    if (dLoc >= 0) {        
        m_openGLES->Uniform1f(dLoc, mDrawDepth);
    }

    // setup scissor rect
    m_openGLES->Scissor(mViewport.sx(), mViewport.sy(), mViewport.sw(), mViewport.sh());

    // setup attribute layout
    for (uint32_t i = 0; i < mVertexLayout.count; i++) 
    {
        const auto &layout = mVertexLayout[i];
        m_openGLES->EnableVertexAttribArray(layout.index);
        m_openGLES->VertexAttribPointer(layout.index, layout.size, GL_FLOAT,
                                   GL_FALSE, layout.stride,
                                   reinterpret_cast<void *>(layout.offset));
    }

    // binding uniforms
    for (uint32_t i = 0; i < mBindingResources.count; i++) {
        const auto& binding = mBindingResources[i];
        if (binding.type == GlBindingType::kTexture) {
            m_openGLES->ActiveTexture(GL_TEXTURE0 + binding.bindPoint);
            m_openGLES->BindTexture(GL_TEXTURE_2D, binding.gBufferId);

            mProgram->setUniform1Value(binding.location, 1, (int32_t*)&binding.bindPoint);
        } else if (binding.type == GlBindingType::kUniformBuffer) {

            m_openGLES->UniformBlockBinding(mProgram->getProgramId(), binding.location, binding.bindPoint);
            m_openGLES->BindBufferRange(GL_UNIFORM_BUFFER, binding.bindPoint, binding.gBufferId, binding.bufferOffset, binding.bufferRange);
        }
    }

    m_openGLES->DrawElements(GL_TRIANGLES, mIndexCount, GL_UNSIGNED_INT, reinterpret_cast<void*>(mIndexOffset));

    // setup attribute layout
    for (uint32_t i = 0; i < mVertexLayout.count; i++) {
        const auto &layout = mVertexLayout[i];
        m_openGLES->DisableVertexAttribArray(layout.index);
    }
}


void GlRenderTask::addVertexLayout(const GlVertexLayout &layout)
{
    mVertexLayout.push(layout);
}


void GlRenderTask::addBindResource(const GlBindingResource &binding)
{
    mBindingResources.push(binding);
}


void GlRenderTask::setDrawRange(uint32_t offset, uint32_t count)
{
    mIndexOffset = offset;
    mIndexCount = count;
}


void GlRenderTask::setViewport(const RenderRegion &viewport)
{
    mViewport = viewport;
    if (mViewport.max.x < mViewport.min.x) mViewport.max.x = mViewport.min.x;
    if (mViewport.max.y < mViewport.min.y) mViewport.max.y = mViewport.min.y;
}


/************************************************************************/
/* GlStencilCoverTask Class Implementation                              */
/************************************************************************/

GlStencilCoverTask::GlStencilCoverTask(qor::ref_of<qor::components::OpenGLESFeature>::type openGLES, GlRenderTask* stencil, GlRenderTask* cover, GlStencilMode mode)
 :GlRenderTask(openGLES, nullptr), mStencilTask(stencil), mCoverTask(cover), mStencilMode(mode)
 {

 }


GlStencilCoverTask::~GlStencilCoverTask()
{
    delete mStencilTask;
    delete mCoverTask;
}


void GlStencilCoverTask::run()
{
    m_openGLES->Enable(GL_STENCIL_TEST);

    if (mStencilMode == GlStencilMode::Stroke) {
        m_openGLES->StencilFunc(GL_NOTEQUAL, 0x1, 0xFF);
        m_openGLES->StencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);
    } else {
        m_openGLES->StencilFuncSeparate(GL_FRONT, GL_ALWAYS, 0x0, 0xFF);
        m_openGLES->StencilOpSeparate(GL_FRONT, GL_KEEP, GL_KEEP, GL_INCR_WRAP);

        m_openGLES->StencilFuncSeparate(GL_BACK, GL_ALWAYS, 0x0, 0xFF);
        m_openGLES->StencilOpSeparate(GL_BACK, GL_KEEP, GL_KEEP, GL_DECR_WRAP);
    }
    m_openGLES->ColourMask(0, 0, 0, 0);

    mStencilTask->run();

    if (mStencilMode == GlStencilMode::FillEvenOdd) {
        m_openGLES->StencilFunc(GL_NOTEQUAL, 0x00, 0x01);
        m_openGLES->StencilOp(GL_REPLACE, GL_KEEP, GL_REPLACE);
    } else {
        m_openGLES->StencilFunc(GL_NOTEQUAL, 0x0, 0xFF);
        m_openGLES->StencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);
    }

    m_openGLES->ColourMask(1, 1, 1, 1);

    mCoverTask->run();

    m_openGLES->Disable(GL_STENCIL_TEST);
}


void GlStencilCoverTask::normalizeDrawDepth(int32_t maxDepth)
{
    mCoverTask->normalizeDrawDepth(maxDepth);
    mStencilTask->normalizeDrawDepth(maxDepth);
}


/************************************************************************/
/* GlComposeTask Class Implementation                                   */
/************************************************************************/

GlComposeTask::GlComposeTask(qor::ref_of<qor::components::OpenGLESFeature>::type openGLES, GlProgram* program, GLuint target, GlRenderTarget* fbo, Array<GlRenderTask*>&& tasks)
 :GlRenderTask(openGLES, program) ,mTargetFbo(target), mFbo(fbo), mTasks()
{
    mTasks.push(tasks);
    tasks.clear();
}


GlComposeTask::~GlComposeTask()
{
    ARRAY_FOREACH(p, mTasks) delete(*p);
    mTasks.clear();
}


void GlComposeTask::run()
{
    m_openGLES->BindFrameBuffer(GL_FRAMEBUFFER, getSelfFbo());

    // we must clear all area of fbo
    m_openGLES->Viewport(0, 0, mFbo->getWidth(), mFbo->getHeight());
    m_openGLES->Scissor(0, 0, mFbo->getWidth(), mFbo->getHeight());
    m_openGLES->ClearColour(0, 0, 0, 0);
    m_openGLES->ClearStencil(0);
//#ifdef THORVG_GL_TARGET_GLES
    m_openGLES->ClearDepthf(0.0);
//#else
    //m_openGLES->ClearDepth(0.0);
//#endif
    m_openGLES->DepthMask(1);

    m_openGLES->Clear(GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    m_openGLES->DepthMask(0);

    m_openGLES->Viewport(0, 0, mRenderWidth, mRenderHeight);
    m_openGLES->Scissor(0, 0, mRenderWidth, mRenderHeight);

    ARRAY_FOREACH(p, mTasks) {
        (*p)->run();
    }

//#if defined(THORVG_GL_TARGET_GLES)
    // only OpenGLES has tiled base framebuffer and discard function
    GLenum attachments[2] = {GL_STENCIL_ATTACHMENT, GL_DEPTH_ATTACHMENT };
    m_openGLES->InvalidateFramebuffer(GL_FRAMEBUFFER, 2, attachments);
//#endif
    // reset scissor box
    m_openGLES->Scissor(0, 0, mFbo->getWidth(), mFbo->getHeight());
    onResolve();
}


GLuint GlComposeTask::getSelfFbo()
{
    return mFbo->getFboId();
}


GLuint GlComposeTask::getResolveFboId()
{
    return mFbo->getResolveFboId();
}


void GlComposeTask::onResolve()
{
    m_openGLES->BindFrameBuffer(GL_READ_FRAMEBUFFER, getSelfFbo());
    m_openGLES->BindFrameBuffer(GL_DRAW_FRAMEBUFFER, getResolveFboId());
    m_openGLES->BlitFrameBuffer(0, 0, mRenderWidth, mRenderHeight, 0, 0, mRenderWidth, mRenderHeight, GL_COLOR_BUFFER_BIT, GL_NEAREST);
}


/************************************************************************/
/* GlBlitTask Class Implementation                                      */
/************************************************************************/

GlBlitTask::GlBlitTask(qor::ref_of<qor::components::OpenGLESFeature>::type openGLES, GlProgram* program, GLuint target, GlRenderTarget* fbo, Array<GlRenderTask*>&& tasks)
 : GlComposeTask(openGLES, program, target, fbo, std::move(tasks)), mColorTex(fbo->getColorTexture())
{
}


void GlBlitTask::run()
{
    GlComposeTask::run();

    m_openGLES->BindFrameBuffer(GL_FRAMEBUFFER, getTargetFbo());
    m_openGLES->Viewport(mTargetViewport.x(), mTargetViewport.y(), mTargetViewport.w(), mTargetViewport.h());

    if (mClearBuffer) {
        m_openGLES->ClearColour(0, 0, 0, 0);
        m_openGLES->Clear(GL_COLOR_BUFFER_BIT);
    }

    m_openGLES->Disable(GL_DEPTH_TEST);
    // make sure the blending is correct
    m_openGLES->Enable(GL_BLEND);
    m_openGLES->BlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);

    GlRenderTask::run();
}


/************************************************************************/
/* GlDrawBlitTask Class Implementation                                  */
/************************************************************************/


GlDrawBlitTask::GlDrawBlitTask(qor::ref_of<qor::components::OpenGLESFeature>::type openGLES, GlProgram* program, GLuint target, GlRenderTarget* fbo, Array<GlRenderTask*>&& tasks)
 : GlComposeTask(openGLES, program, target, fbo, std::move(tasks))
{
}


GlDrawBlitTask::~GlDrawBlitTask()
{
    if (mPrevTask) delete mPrevTask;
}


void GlDrawBlitTask::run()
{
    if (mPrevTask) mPrevTask->run();

    GlComposeTask::run();

    m_openGLES->BindFrameBuffer(GL_FRAMEBUFFER, getTargetFbo());

    m_openGLES->Viewport(0, 0, mParentWidth, mParentHeight);
    m_openGLES->Scissor(0, 0, mParentWidth, mParentHeight);
    GlRenderTask::run();
}


/************************************************************************/
/* GlSceneBlendTask Class Implementation                                  */
/************************************************************************/


GlSceneBlendTask::GlSceneBlendTask(qor::ref_of<qor::components::OpenGLESFeature>::type openGLES, GlProgram* program, GLuint target, GlRenderTarget* fbo, Array<GlRenderTask*>&& tasks)
 : GlComposeTask(openGLES, program, target, fbo, std::move(tasks))
{
}


GlSceneBlendTask::~GlSceneBlendTask()
{
}


void GlSceneBlendTask::run()
{
    GlComposeTask::run();

    const auto& vp = getViewport();

    // For EMSCRIPTEN: perform an intermediate blit from multisampled FBO to resolve FBO
    // Then perform a final blit to destination framebuffer.
    // For other platforms: direct blit from target FBO to destination resolve FBO.

    // Platform-specific source framebuffer binding
#ifdef __EMSCRIPTEN__
    m_openGLES->BindFrameBuffer(GL_READ_FRAMEBUFFER, mSrcFbo->getFboId());
    m_openGLES->BindFrameBuffer(GL_DRAW_FRAMEBUFFER, mSrcFbo->getResolveFboId());
    m_openGLES->Viewport(vp.x(), vp.y(), vp.w(), vp.h());
    m_openGLES->Scissor(vp.x(), vp.y(), vp.w(), vp.h());
    m_openGLES->BlitFrameBuffer(vp.min.x, vp.min.y, vp.max.x, vp.max.y, vp.min.x, vp.min.y, vp.max.x, vp.max.y, GL_COLOR_BUFFER_BIT, GL_LINEAR);

    // Prepare for second blit to destination framebuffer
    m_openGLES->BindFrameBuffer(GL_READ_FRAMEBUFFER, mSrcFbo->getResolveFboId());
#else
    m_openGLES->BindFrameBuffer(GL_READ_FRAMEBUFFER, getTargetFbo());
#endif

    // Common: bind destination framebuffer and blit
    m_openGLES->BindFrameBuffer(GL_DRAW_FRAMEBUFFER, mDstCopyFbo->getResolveFboId());
    m_openGLES->Viewport(0, 0, mDstCopyFbo->getWidth(), mDstCopyFbo->getHeight());
    m_openGLES->Scissor(0, 0, mDstCopyFbo->getWidth(), mDstCopyFbo->getHeight());
    m_openGLES->BlitFrameBuffer(vp.min.x, vp.min.y, vp.max.x, vp.max.y, 0, 0, vp.w(), vp.h(), GL_COLOR_BUFFER_BIT, GL_LINEAR);

    m_openGLES->BindFrameBuffer(GL_FRAMEBUFFER, getTargetFbo());
    m_openGLES->Viewport(0, 0, mParentWidth, mParentHeight);
    m_openGLES->Scissor(0, 0, mParentWidth, mParentHeight);

    m_openGLES->Disable(GL_DEPTH_TEST);
    m_openGLES->BlendFunc(GL_ONE, GL_ZERO);
    GlRenderTask::run();
    m_openGLES->BlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
    m_openGLES->Enable(GL_DEPTH_TEST);
}


/************************************************************************/
/* GlClipTask Class Implementation                                      */
/************************************************************************/

GlClipTask::GlClipTask(GlRenderTask* clip, GlRenderTask* mask)
 :GlRenderTask(m_openGLES, nullptr), mClipTask(clip), mMaskTask(mask) {}


GlClipTask::~GlClipTask()
{
    delete mClipTask;
    delete mMaskTask;
}


void GlClipTask::run()
{
    m_openGLES->Enable(GL_STENCIL_TEST);
    m_openGLES->ColourMask(0, 0, 0, 0);
    // draw clip path as normal stencil mask
    m_openGLES->StencilFuncSeparate(GL_FRONT, GL_ALWAYS, 0x1, 0xFF);
    m_openGLES->StencilOpSeparate(GL_FRONT, GL_KEEP, GL_KEEP, GL_INCR_WRAP);

    m_openGLES->StencilFuncSeparate(GL_BACK, GL_ALWAYS, 0x1, 0xFF);
    m_openGLES->StencilOpSeparate(GL_BACK, GL_KEEP, GL_KEEP, GL_DECR_WRAP);

    mClipTask->run();


    // draw clip mask
    m_openGLES->DepthMask(1);
    m_openGLES->StencilFunc(GL_EQUAL, 0x0, 0xFF);
    m_openGLES->StencilOp(GL_REPLACE, GL_KEEP, GL_REPLACE);

    mMaskTask->run();

    m_openGLES->ColourMask(1, 1, 1, 1);
    m_openGLES->DepthMask(0);
    m_openGLES->Disable(GL_STENCIL_TEST);
}


void GlClipTask::normalizeDrawDepth(int32_t maxDepth)
{
    mClipTask->normalizeDrawDepth(maxDepth);
    mMaskTask->normalizeDrawDepth(maxDepth);
}

/************************************************************************/
/* GlSimpleBlendTask Class Implementation                               */
/************************************************************************/

GlSimpleBlendTask::GlSimpleBlendTask(BlendMethod method, GlProgram* program)
 : GlRenderTask(m_openGLES, program), mBlendMethod(method)
 {
 }


void GlSimpleBlendTask::run()
{
    if (mBlendMethod == BlendMethod::Add) m_openGLES->BlendFunc(GL_ONE, GL_ONE);
    else if (mBlendMethod == BlendMethod::Darken) {
        m_openGLES->BlendFunc(GL_ONE, GL_ONE);
        glBlendEquation(GL_MIN);
    } else if (mBlendMethod == BlendMethod::Lighten) {
        m_openGLES->BlendFunc(GL_ONE, GL_ONE);
        glBlendEquation(GL_MAX);
    }
    else m_openGLES->BlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);

    GlRenderTask::run();

    if (mBlendMethod == BlendMethod::Darken || mBlendMethod == BlendMethod::Lighten) glBlendEquation(GL_FUNC_ADD);

    m_openGLES->BlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
}


/************************************************************************/
/* GlComplexBlendTask Class Implementation                              */
/************************************************************************/


GlComplexBlendTask::GlComplexBlendTask(GlProgram* program, GlRenderTarget* dstFbo, GlRenderTarget* dstCopyFbo, GlRenderTask* stencilTask, GlComposeTask* composeTask)
 : GlRenderTask(m_openGLES, program), mDstFbo(dstFbo), mDstCopyFbo(dstCopyFbo), mStencilTask(stencilTask), mComposeTask(composeTask)
 {
 }


GlComplexBlendTask::~GlComplexBlendTask()
{
    delete mStencilTask;
    delete mComposeTask;
}


void GlComplexBlendTask::run()
{
    mComposeTask->run();

    // copy the current fbo to the dstCopyFbo
    m_openGLES->BindFrameBuffer(GL_READ_FRAMEBUFFER, mDstFbo->getFboId());
    m_openGLES->BindFrameBuffer(GL_DRAW_FRAMEBUFFER, mDstCopyFbo->getResolveFboId());

    m_openGLES->Viewport(0, 0, mDstFbo->getViewport().w(), mDstFbo->getViewport().h());
    m_openGLES->Scissor(0, 0, mDstFbo->getViewport().w(), mDstFbo->getViewport().h());
    
    const auto& vp = getViewport();
    m_openGLES->BlitFrameBuffer(vp.min.x, vp.min.y, vp.max.x, vp.max.y, 0, 0, vp.w(), vp.h(), GL_COLOR_BUFFER_BIT, GL_LINEAR);

    m_openGLES->BindFrameBuffer(GL_FRAMEBUFFER, mDstFbo->getFboId());

    m_openGLES->Enable(GL_STENCIL_TEST);
    m_openGLES->ColourMask(0, 0, 0, 0);
    m_openGLES->StencilFuncSeparate(GL_FRONT, GL_ALWAYS, 0x0, 0xFF);
    m_openGLES->StencilOpSeparate(GL_FRONT, GL_KEEP, GL_KEEP, GL_INCR_WRAP);

    m_openGLES->StencilFuncSeparate(GL_BACK, GL_ALWAYS, 0x0, 0xFF);
    m_openGLES->StencilOpSeparate(GL_BACK, GL_KEEP, GL_KEEP, GL_DECR_WRAP);


    mStencilTask->run();

    m_openGLES->ColourMask(1, 1, 1, 1);
    m_openGLES->StencilFunc(GL_NOTEQUAL, 0x0, 0xFF);
    m_openGLES->StencilOp(GL_REPLACE, GL_KEEP, GL_REPLACE);

    m_openGLES->BlendFunc(GL_ONE, GL_ZERO);

    GlRenderTask::run();

    m_openGLES->Disable(GL_STENCIL_TEST);
    m_openGLES->BlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
}


void GlComplexBlendTask::normalizeDrawDepth(int32_t maxDepth)
{
    mStencilTask->normalizeDrawDepth(maxDepth);
    GlRenderTask::normalizeDrawDepth(maxDepth);
}

/************************************************************************/
/* GlGaussianBlurTask Class Implementation                              */
/************************************************************************/

void GlGaussianBlurTask::run()
{
    const auto vp = getViewport();
    const auto width = mDstFbo->getWidth();
    const auto height = mDstFbo->getHeight();

    // get targets handles
    GLuint dstCopyTexId0 = mDstCopyFbo0->getColorTexture();
    GLuint dstCopyTexId1 = mDstCopyFbo1->getColorTexture();
    // get programs properties
    GlProgram* programHorz = horzTask->getProgram();
    GlProgram* programVert = vertTask->getProgram();
    GLint horzSrcTextureLoc = programHorz->getUniformLocation("uSrcTexture");
    GLint vertSrcTextureLoc = programVert->getUniformLocation("uSrcTexture");

    m_openGLES->Viewport(0, 0, width, height);
    m_openGLES->Scissor(0, 0, width, height);
    // we need to make a full copy of dst to intermediate buffers to be sure that they don’t contain prev data.
    m_openGLES->BindFrameBuffer(GL_READ_FRAMEBUFFER, mDstFbo->getFboId());
    m_openGLES->BindFrameBuffer(GL_DRAW_FRAMEBUFFER, mDstCopyFbo0->getResolveFboId());
    m_openGLES->BlitFrameBuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST);
    m_openGLES->BindFrameBuffer(GL_FRAMEBUFFER, mDstFbo->getFboId());

    m_openGLES->Disable(GL_BLEND);
    if (effect->direction == 0) {
        m_openGLES->BindFrameBuffer(GL_READ_FRAMEBUFFER, mDstFbo->getFboId());
        m_openGLES->BindFrameBuffer(GL_DRAW_FRAMEBUFFER, mDstCopyFbo1->getResolveFboId());
        m_openGLES->BlitFrameBuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST);
        // horizontal blur
        m_openGLES->BindFrameBuffer(GL_FRAMEBUFFER, mDstCopyFbo1->getResolveFboId());
        horzTask->setViewport(vp);
        horzTask->addBindResource({ 0, dstCopyTexId0, horzSrcTextureLoc });
        horzTask->run();
        // vertical blur
        m_openGLES->BindFrameBuffer(GL_FRAMEBUFFER, mDstFbo->getFboId());
        vertTask->setViewport(vp);
        vertTask->addBindResource({ 0, dstCopyTexId1, vertSrcTextureLoc });
        vertTask->run();
    } // horizontal
    else if (effect->direction == 1) {
        horzTask->setViewport(vp);
        horzTask->addBindResource({ 0, dstCopyTexId0, horzSrcTextureLoc });
        horzTask->run();
    } // vertical
    else if (effect->direction == 2) {
        vertTask->setViewport(vp);
        vertTask->addBindResource({ 0, dstCopyTexId0, vertSrcTextureLoc });
        vertTask->run();
    }
    m_openGLES->Enable(GL_BLEND);
}

/************************************************************************/
/* GlEffectDropShadowTask Class Implementation                          */
/************************************************************************/

void GlEffectDropShadowTask::run()
{
    const auto vp = getViewport();
    const auto width = mDstFbo->getWidth();
    const auto height = mDstFbo->getHeight();

    // get targets handles
    GLuint dstCopyTexId0 = mDstCopyFbo0->getColorTexture();
    GLuint dstCopyTexId1 = mDstCopyFbo1->getColorTexture();
    // get programs properties
    GlProgram* programHorz = horzTask->getProgram();
    GlProgram* programVert = vertTask->getProgram();
    GLint horzSrcTextureLoc = programHorz->getUniformLocation("uSrcTexture");
    GLint vertSrcTextureLoc = programVert->getUniformLocation("uSrcTexture");

    GLint srcTextureLoc = getProgram()->getUniformLocation("uSrcTexture");
    GLint blrTextureLoc = getProgram()->getUniformLocation("uBlrTexture");
    addBindResource({ 0, dstCopyTexId0, srcTextureLoc });
    addBindResource({ 1, dstCopyTexId1, blrTextureLoc });

    m_openGLES->Viewport(0, 0, width, height);
    m_openGLES->Scissor(0, 0, width, height);

    // we need to make a full copy of dst to intermediate buffers to be sure that they don’t contain prev data.
    m_openGLES->BindFrameBuffer(GL_READ_FRAMEBUFFER, mDstFbo->getFboId());
    m_openGLES->BindFrameBuffer(GL_DRAW_FRAMEBUFFER, mDstCopyFbo0->getResolveFboId());
    m_openGLES->BlitFrameBuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST);
    m_openGLES->BindFrameBuffer(GL_READ_FRAMEBUFFER, mDstFbo->getFboId());
    m_openGLES->BindFrameBuffer(GL_DRAW_FRAMEBUFFER, mDstCopyFbo1->getResolveFboId());
    m_openGLES->BlitFrameBuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST);
    
    m_openGLES->Disable(GL_BLEND);
    // when sigma is 0, no blur is applied, and the original image is used directly as the shadow.
    if (!zero(effect->sigma)) {
        // horizontal blur
        m_openGLES->BindFrameBuffer(GL_FRAMEBUFFER, mDstCopyFbo0->getResolveFboId());
        horzTask->setViewport(vp);
        horzTask->addBindResource({ 0, dstCopyTexId1, horzSrcTextureLoc });
        horzTask->run();
        // vertical blur
        m_openGLES->BindFrameBuffer(GL_FRAMEBUFFER, mDstCopyFbo1->getResolveFboId());
        vertTask->setViewport(vp);
        vertTask->addBindResource({ 0, dstCopyTexId0, vertSrcTextureLoc });
        vertTask->run();
        // copy original image to intermediate buffer
        m_openGLES->BindFrameBuffer(GL_READ_FRAMEBUFFER, mDstFbo->getFboId());
        m_openGLES->BindFrameBuffer(GL_DRAW_FRAMEBUFFER, mDstCopyFbo0->getResolveFboId());
        m_openGLES->BlitFrameBuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST);
    }
    // run drop shadow effect
    m_openGLES->BindFrameBuffer(GL_FRAMEBUFFER, mDstFbo->getFboId());
    GlRenderTask::run();
    m_openGLES->Enable(GL_BLEND);
}

/************************************************************************/
/* GlEffectColorTransformTask Class Implementation                      */
/************************************************************************/

void GlEffectColorTransformTask::run()
{
    const auto width = mDstFbo->getWidth();
    const auto height = mDstFbo->getHeight();
    // get targets handles and pass to shader
    GLuint dstCopyTexId = mDstCopyFbo->getColorTexture();
    GLint srcTextureLoc = getProgram()->getUniformLocation("uSrcTexture");
    addBindResource({ 0, dstCopyTexId, srcTextureLoc });

    m_openGLES->Viewport(0, 0, width, height);
    m_openGLES->Scissor(0, 0, width, height);
    // we need to make a full copy of dst to intermediate buffers to be sure that they don’t contain prev data.
    m_openGLES->BindFrameBuffer(GL_READ_FRAMEBUFFER, mDstFbo->getFboId());
    m_openGLES->BindFrameBuffer(GL_DRAW_FRAMEBUFFER, mDstCopyFbo->getResolveFboId());
    m_openGLES->BlitFrameBuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST);
    m_openGLES->BindFrameBuffer(GL_FRAMEBUFFER, mDstFbo->getFboId());

    // run transform
    m_openGLES->Disable(GL_BLEND);
    GlRenderTask::run();
    m_openGLES->Enable(GL_BLEND);
}

}}}}//qor::components::ui::renderer