// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_COMPONENTS_FRAMEWORK_UI_RENDERER_GL_COMMON
#define QOR_PP_H_COMPONENTS_FRAMEWORK_UI_RENDERER_GL_COMMON

#include <cassert>
#include "gl.h"
#include "../render.h"
#include "../common/math.h"

#define MIN_GL_STROKE_WIDTH 1.0f
#define MIN_GL_STROKE_ALPHA 0.25f

#define MVP_MATRIX(w, h)                \
    float mvp[4*4] = {                  \
        2.f / w,      0.0,  0.0f, 0.0f, \
        0.0,     -2.f / h,  0.0f, 0.0f, \
        0.0f,        0.0f, -1.0f, 0.0f, \
        -1.f,         1.f,  0.0f, 1.0f  \
    };

#define MULTIPLY_MATRIX(A, B, transform)    \
    for(auto i = 0; i < 4; ++i) {           \
        for(auto j = 0; j < 4; ++j) {       \
            float sum = 0.0;                \
            for (auto k = 0; k < 4; ++k)    \
                sum += A[k*4+i] * B[j*4+k]; \
            transform[j*4+i] = sum;         \
        }                                   \
    }

    /**
     *  mat3x3               mat4x4
     *
     * [ e11 e12 e13 ]     [ e11 e12 0 e13 ]
     * [ e21 e22 e23 ] =>  [ e21 e22 0 e23 ]
     * [ e31 e32 e33 ]     [ 0   0   1  0  ]
     *                     [ e31 e32 0 e33 ]
     *
     */

    // All GPU use 4x4 matrix with column major order
    #define GET_MATRIX44(mat3, mat4) \
        do {                         \
            mat4[0] = mat3.e11;      \
            mat4[1] = mat3.e21;      \
            mat4[2] = 0;             \
            mat4[3] = mat3.e31;      \
            mat4[4] = mat3.e12;      \
            mat4[5] = mat3.e22;      \
            mat4[6] = 0;             \
            mat4[7] = mat3.e32;      \
            mat4[8] = 0;             \
            mat4[9] = 0;             \
            mat4[10] = 1;            \
            mat4[11] = 0;            \
            mat4[12] = mat3.e13;     \
            mat4[13] = mat3.e23;     \
            mat4[14] = 0;            \
            mat4[15] = mat3.e33;     \
        } while (false)

namespace qor{ namespace components{ namespace ui{ namespace renderer{

    enum class GlStencilMode 
    {
        None,
        FillNonZero,
        FillEvenOdd,
        Stroke,
    };


    class GlStageBuffer;
    class GlRenderTask;

    struct GlGeometryBuffer 
    {
        Array<float> vertex;
        Array<uint32_t> index;

        void clear()
        {
            vertex.clear();
            index.clear();
        }

    };

    struct GlGeometry
    {
        void prepare(const RenderShape& rshape);
        bool tesselateShape(const RenderShape& rshape, float* opacityMultiplier = nullptr);
        bool tesselateStroke(const RenderShape& rshape);
        bool tesselateLine(const RenderPath& path);
        void tesselateImage(const RenderSurface* image);
        bool draw(GlRenderTask* task, GlStageBuffer* gpuBuffer, RenderUpdateFlag flag);
        GlStencilMode getStencilMode(RenderUpdateFlag flag);
        RenderRegion getBounds() const;

        GlGeometryBuffer fill, stroke;
        Matrix matrix = {};
        RenderRegion viewport = {};
        RenderRegion bounds = {};
        FillRule fillRule = FillRule::NonZero;
        RenderPath optPath;  //optimal path
    };


    struct GlShape
    {
        const RenderShape* rshape = nullptr;
        float viewWd;
        float viewHt;
        uint32_t opacity = 0;
        unsigned int texId = 0;
        uint32_t texFlipY = 0;
        ColorSpace texColorSpace = ColorSpace::ABGR8888;
        GlGeometry geometry;
        Array<RenderData> clips;
        bool validFill = false;
        bool validStroke = false;
    };

    struct GlIntersector
    {
        bool isPointInTriangle(const Point& p, const Point& a, const Point& b, const Point& c);
        bool isPointInImage(const Point& p, const GlGeometryBuffer& mesh, const Matrix& tr);
        bool isPointInTris(const Point& p, const GlGeometryBuffer& mesh, const Matrix& tr);
        bool isPointInMesh(const Point& p, const GlGeometryBuffer& mesh, const Matrix& tr);
        bool intersectClips(const Point& pt, const Array<RenderData>& clips);
        bool intersectShape(const RenderRegion region, const GlShape* shape);
        bool intersectImage(const RenderRegion region, const GlShape* image);
    };

    #define MAX_GRADIENT_STOPS 16

    struct GlLinearGradientBlock
    {
        alignas(16) float nStops[4] = {};
        alignas(16) float startPos[2] = {};
        alignas(8) float stopPos[2] = {};
        alignas(8) float stopPoints[MAX_GRADIENT_STOPS] = {};
        alignas(16) float stopColors[4 * MAX_GRADIENT_STOPS] = {};
    };

    struct GlRadialGradientBlock
    {
        alignas(16) float nStops[4] = {};
        alignas(16) float centerPos[4] = {};
        alignas(16) float radius[2] = {};
        alignas(16) float stopPoints[MAX_GRADIENT_STOPS] = {};
        alignas(16) float stopColors[4 * MAX_GRADIENT_STOPS] = {};
    };

    struct GlCompositor : RenderCompositor
    {
        RenderRegion bbox;
        CompositionFlag flags;
        BlendMethod blendMethod = BlendMethod::Normal;

        GlCompositor(const RenderRegion& box, CompositionFlag flags) : bbox(box), flags(flags) {}
    };


}}}}//qor::components::ui::renderer

#endif//QOR_PP_H_COMPONENTS_FRAMEWORK_UI_RENDERER_GL_COMMON