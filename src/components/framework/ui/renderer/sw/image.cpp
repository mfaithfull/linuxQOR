// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include "../common/math.h"
#include "common.h"

namespace qor{ namespace components{ namespace ui{ namespace renderer{

    static inline bool _onlyShifted(const Matrix& m)
    {
        if (equal(m.e11, 1.0f) && equal(m.e22, 1.0f) && zero(m.e12) && zero(m.e21)) return true;
        return false;
    }

    static bool _genOutline(SwImage& image, const Matrix& transform, SwMpool* mpool, unsigned tid)
    {
        image.outline = mpoolReqOutline(mpool, tid);
        auto outline = image.outline;

        outline->pts.reserve(5);
        outline->types.reserve(5);
        outline->cntrs.reserve(1);
        outline->closed.reserve(1);

        Point to[4];
        auto w = static_cast<float>(image.w);
        auto h = static_cast<float>(image.h);
        to[0] = {0, 0};
        to[1] = {w, 0};
        to[2] = {w, h};
        to[3] = {0, h};

        for (int i = 0; i < 4; i++) {
            outline->pts.push(mathTransform(&to[i], transform));
            outline->types.push(SW_CURVE_TYPE_POINT);
        }

        outline->pts.push(outline->pts[0]);
        outline->types.push(SW_CURVE_TYPE_POINT);
        outline->cntrs.push(outline->pts.count - 1);
        outline->closed.push(true);

        image.outline = outline;
        image.outline->fillRule = FillRule::NonZero;

        return true;
    }

    bool imagePrepare(SwImage& image, const Matrix& transform, const RenderRegion& clipBox, RenderRegion& renderBox, SwMpool* mpool, unsigned tid)
    {
        image.direct = _onlyShifted(transform);

        //Fast track: Non-transformed image but just shifted.
        if (image.direct) {
            image.ox = -static_cast<int32_t>(nearbyint(transform.e13));
            image.oy = -static_cast<int32_t>(nearbyint(transform.e23));
        //Figure out the scale factor by transform matrix
        } else {
            auto scaleX = sqrtf((transform.e11 * transform.e11) + (transform.e21 * transform.e21));
            auto scaleY = sqrtf((transform.e22 * transform.e22) + (transform.e12 * transform.e12));
            image.scale = (fabsf(scaleX - scaleY) > 0.01f) ? 1.0f : scaleX;

            if (zero(transform.e12) && zero(transform.e21)) image.scaled = true;
            else image.scaled = false;
        }

        if (!_genOutline(image, transform, mpool, tid)) return false;
        return mathUpdateOutlineBBox(image.outline, clipBox, renderBox, image.direct);
    }

    bool imageGenRle(SwImage& image, const RenderRegion& renderBox, SwMpool* mpool, unsigned tid, bool antiAlias)
    {
        if ((image.rle = rleRender(image.rle, image.outline, renderBox, mpool, tid, antiAlias))) return true;

        return false;
    }

    void imageDelOutline(SwImage& image, SwMpool* mpool, uint32_t tid)
    {
        mpoolRetOutline(mpool, tid);
        image.outline = nullptr;
    }

    void imageReset(SwImage& image)
    {
        rleReset(image.rle);
    }

    void imageFree(SwImage& image)
    {
        rleFree(image.rle);
        image.rle = nullptr;
    }

}}}}//qor::components::ui::renderer
