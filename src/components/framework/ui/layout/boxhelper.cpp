// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include "boxhelper.h"

namespace qor{ namespace components{ namespace ui {

    namespace boxhelper
    {
        namespace 
        {
            int SafeRatio(int value, int numerator, int denominator) 
            {
                return static_cast<int64_t>(value) * static_cast<int64_t>(numerator) / std::max(static_cast<int64_t>(denominator), static_cast<int64_t>(1));
            }

            // Called when the size allowed is greater than the requested size. This
            // distributes the extra spaces toward the flexible elements, in relative
            // proportions.
            void ComputeGrow(std::vector<Element>* elements, int extra_space, int flex_grow_sum) 
            {
                for (Element& element : *elements) 
                {
                    const int added_space = SafeRatio(extra_space, element.flex_grow, flex_grow_sum);
                    extra_space -= added_space;
                    flex_grow_sum -= element.flex_grow;
                    element.size = element.min_size + added_space;
                }
            }

            // Called when the size allowed is lower than the requested size, and the
            // shrinkable element can absorbe the (negative) extra_space. This distribute
            // the extra_space toward those.
            void ComputeShrinkEasy(std::vector<Element>* elements, int extra_space, int flex_shrink_sum) 
            {
                for (Element& element : *elements) 
                {
                    const int added_space = SafeRatio(extra_space, element.min_size * element.flex_shrink, flex_shrink_sum);
                    extra_space -= added_space;
                    flex_shrink_sum -= element.flex_shrink * element.min_size;
                    element.size = element.min_size + added_space;
                }
            }

            // Called when the size allowed is lower than the requested size, and the
            // shrinkable element can not absorb the (negative) extra_space. This assigns
            // zero to shrinkable elements and distribute the remaining (negative)
            // extra_space toward the other non shrinkable elements.
            void ComputeShrinkHard(std::vector<Element>* elements, int extra_space, int size) 
            {
                for (Element& element : *elements) 
                {
                    if (element.flex_shrink != 0) 
                    {
                        element.size = 0;
                        continue;
                    }

                    const int added_space = SafeRatio(extra_space, element.min_size, size);
                    extra_space -= added_space;
                    size -= element.min_size;
                    element.size = element.min_size + added_space;
                }
            }

        }//

        void Compute(std::vector<Element>* elements, int target_size) 
        {
            int size = 0;
            int flex_grow_sum = 0;
            int flex_shrink_sum = 0;
            int flex_shrink_size = 0;

            for (auto& element : *elements) 
            {
                flex_grow_sum += element.flex_grow;
                flex_shrink_sum += element.min_size * element.flex_shrink;
                if (element.flex_shrink != 0) 
                {
                    flex_shrink_size += element.min_size;
                }
                size += element.min_size;
            }

            const int extra_space = target_size - size;
            if (extra_space >= 0) 
            {
                ComputeGrow(elements, extra_space, flex_grow_sum);
            } 
            else if (flex_shrink_size + extra_space >= 0) 
            {
                ComputeShrinkEasy(elements, extra_space, flex_shrink_sum);

            } 
            else 
            {
                ComputeShrinkHard(elements, extra_space + flex_shrink_size, size - flex_shrink_size);
            }
        }
    }//boxhelper

}}}//qor::components::tui
