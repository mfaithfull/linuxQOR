// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"
#include "base64encodefilter.h"

namespace qor{ namespace components{ 

    bool Base64EncodeFilter::ReadFilter(size_t& unitsProcessed, size_t unitsToProcess)
    {
        return Encode(unitsProcessed, unitsToProcess);
    }

    bool Base64EncodeFilter::WriteFilter(size_t& unitsProcessed, size_t unitsToProcess)
    {
        return Encode(unitsProcessed, unitsToProcess);
    }

    bool Base64EncodeFilter::Encode(size_t& unitsProcessed, size_t unitsToProcess)
    {
        static const char* base64_chars = 
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz"
        "0123456789+/";
        auto sourceBuffer = ActualSource()->GetBuffer();
        auto sinkBuffer = ActualSink()->GetBuffer();
        if(sourceBuffer && sinkBuffer && unitsToProcess)
        {
            byte* data = sourceBuffer->ReadRequest(unitsToProcess);
            size_t output_space = (unitsToProcess + 2 ) / 3 * 4;
            byte* space = sinkBuffer->WriteRequest(output_space);
            int val = 0, valb = -6;
            unsigned char* c = data;
            size_t index = 0;
            size_t outindex = 0;
            while(index < unitsToProcess && outindex < output_space)
            {
                val = (val << 8) + data[index++];
                valb += 8;
                while(valb >= 0 && outindex < output_space)
                {
                    byte output = base64_chars[(val >> valb) & 0x3f];
                    space[outindex++] = output;
                    valb -= 6;
                }
            };
            if (valb > -6 && outindex < output_space) 
            {
                byte output = base64_chars[((val << 8) >> valb) & 0x3F];
                space[outindex++] = output;
            }
            while (outindex % 4 && outindex < output_space)
            {
                space[outindex++] = '=';
            }
            sinkBuffer->WriteAcknowledge(outindex);
            sourceBuffer->ReadAcknowledge(index);
            unitsProcessed = outindex;
            return true;
        }
        return false;
    }
}}//qor::components