// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"
#include "base64decodefilter.h"

namespace qor{ namespace components{ 

    bool Base64DecodeFilter::ReadFilter(size_t& unitsProcessed, size_t unitsToProcess)
    {
        return Decode(unitsProcessed, unitsToProcess);
    }

    bool Base64DecodeFilter::WriteFilter(size_t& unitsProcessed, size_t unitsToProcess)
    {
        return Decode(unitsProcessed, unitsToProcess);
    }

    static unsigned int pos_of_char(const unsigned char chr) 
    {
        if      (chr >= 'A' && chr <= 'Z') return chr - 'A';
        else if (chr >= 'a' && chr <= 'z') return chr - 'a' + ('Z' - 'A')               + 1;
        else if (chr >= '0' && chr <= '9') return chr - '0' + ('Z' - 'A') + ('z' - 'a') + 2;
        else if (chr == '+' || chr == '-') return 62; // Be liberal with input and accept both url ('-') and non-url ('+') base 64 characters (
        else if (chr == '/' || chr == '_') return 63; // Ditto for '/' and '_'
        else
        {
            //TODO: Error not base64encoded
        }
        return 0;
    }

    bool Base64DecodeFilter::Decode(size_t& unitsProcessed, size_t unitsToProcess)
    {
        auto sourceBuffer = ActualSource()->GetBuffer();
        auto sinkBuffer = ActualSink()->GetBuffer();
        if(sourceBuffer && sinkBuffer && unitsToProcess)
        {
            byte* data = sourceBuffer->ReadRequest(unitsToProcess);
            size_t output_space = unitsToProcess / 4 * 3;
            byte* space = sinkBuffer->WriteRequest(output_space);
            size_t index = 0;
            size_t outindex = 0;
            while( index < (unitsToProcess-1) && outindex < output_space)
            {
                size_t pos_of_char_1 = pos_of_char(data[index + 1] );
                byte output = (((pos_of_char(data[index])) << 2) + ((pos_of_char_1 & 0x30) >> 4));
                space[outindex++] = output;

                if(( index + 2 < unitsToProcess) &&                    // Check for data that is not padded with equal signs (which is allowed by RFC 2045)
                        data[index+2]!= '=' && data[index+2] != '.')   // accept URL-safe base 64 strings, too, so check for '.' also.
                {
                    unsigned int pos_of_char_2 = pos_of_char(data[index + 2]);
                    output = ((( pos_of_char_1 & 0x0f) << 4) + ((pos_of_char_2 & 0x3c) >> 2));
                    space[outindex++] = output;

                    if((index + 3 < unitsToProcess) && data[index + 3] != '=' && data[index + 3] != '.')
                    {
                        output = (((pos_of_char_2 & 0x03) << 6) + pos_of_char(data[index+3]));
                        space[outindex++] = output;
                    }
                }
                index += 4;
            }
            sinkBuffer->WriteAcknowledge(outindex);
            sourceBuffer->ReadAcknowledge(index);
            unitsProcessed = outindex;
            return true;
        }
        return false;
    }

}}//qor::components