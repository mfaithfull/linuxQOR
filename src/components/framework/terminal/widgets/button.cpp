// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include <functional>
#include <utility>

#include "../ui/animation.h"
#include "../ui/component.h"
#include "../ui/componentbase.h"
#include "../ui/componentoptions.h"
#include "../ui/event.h"
#include "../ui/mouse.h"
#include "../ui/screeninteractive.h"
#include "../dom/elements.h"
#include "../screen/box.h"
#include "../screen/colour.h"
#include "../util/ref.h"

namespace qor{ namespace components{ namespace tui {

    namespace {

        Element DefaultTransform(EntryState params) 
        {
            auto element = text(params.label) | border;
            if (params.active) 
            {
                element |= bold;
            }
            if (params.focused) 
            {
                element |= inverted;
            }
            return element;
        }

        class qor_pp_module_interface(QOR_TUI) ButtonBase : public ComponentBase, public ButtonOption 
        {
        public:
            explicit ButtonBase(ButtonOption option) : ButtonOption(std::move(option)) {}

            // Component implementation:
            Element OnRender() override 
            {
                const bool active = Active();
                const bool focused = Focused();
                const bool focused_or_hover = focused || mouse_hover_;

                float target = focused_or_hover ? 1.f : 0.f;
                if (target != animator_background_.to()) 
                {
                    SetAnimationTarget(target);
                }

                const EntryState state
                {
                    std::string(*label), false, active, focused_or_hover, Index(),
                };

                auto element = (transform ? transform : DefaultTransform)(state);
                element |= AnimatedColorStyle();
                element |= focus;
                element |= reflect(box_);
                return element;
            }

            Decorator AnimatedColorStyle() 
            {
                Decorator style = nothing;
                if (animated_colors.background.enabled) 
                {
                    style = style | bgcolor(Colour::Interpolate(animation_foreground_, animated_colors.background.inactive, animated_colors.background.active));
                }
                if (animated_colors.foreground.enabled) 
                {
                    style = style | color(Colour::Interpolate(animation_foreground_, animated_colors.foreground.inactive, animated_colors.foreground.active));
                }
                return style;
            }

            void SetAnimationTarget(float target) 
            {
                if (animated_colors.foreground.enabled) 
                {
                    animator_foreground_ = animation::Animator(&animation_foreground_, target, animated_colors.foreground.duration, animated_colors.foreground.function);
                }
                if (animated_colors.background.enabled) 
                {
                    animator_background_ = animation::Animator( &animation_background_, target, animated_colors.background.duration, animated_colors.background.function);
                }
            }

            void OnAnimation(animation::Params& p) override 
            {
                animator_background_.OnAnimation(p);
                animator_foreground_.OnAnimation(p);
            }

            void OnClick() 
            {
                animation_background_ = 0.5F;
                animation_foreground_ = 0.5F;
                SetAnimationTarget(1.F);

                // TODO(arthursonzogni): Consider posting the task to the main loop, instead
                // of invoking it immediately.
                on_click();  // May delete this.
            }

            bool OnEvent(Event event) override 
            {
                if (event.is_mouse()) 
                {
                    return OnMouseEvent(event);
                }

                if (event == Event::Return) 
                {
                    OnClick();  // May delete this.
                    return true;
                }
                return false;
            }

            bool OnMouseEvent(Event event) {
                mouse_hover_ = box_.Contain(event.mouse().x, event.mouse().y) && CaptureMouse(event);

                if (!mouse_hover_) 
                {
                    return false;
                }

                if (event.mouse().button == Mouse::Left && event.mouse().motion == Mouse::Pressed) 
                {
                    TakeFocus();
                    OnClick();  // May delete this.
                    return true;
                }

                return false;
            }

            bool Focusable() const final { return true; }

        private:
            bool mouse_hover_ = false;
            Box box_;
            float animation_background_ = 0;
            float animation_foreground_ = 0;
            animation::Animator animator_background_ = animation::Animator(&animation_background_);
            animation::Animator animator_foreground_ = animation::Animator(&animation_foreground_);
        };

    }  // namespace

    /// @brief Draw a button. Execute a function when clicked.
    /// @param option Additional optional parameters.
    /// @ingroup component
    /// @see ButtonBase
    ///
    /// ### Example
    ///
    /// ```cpp
    /// auto screen = ScreenInteractive::FitComponent();
    /// Component button = Button({
    ///   .label = "Click to quit",
    ///   .on_click = screen.ExitLoopClosure(),
    /// });
    /// screen.Loop(button)
    /// ```
    ///
    /// ### Output
    ///
    /// ```bash
    /// ┌─────────────┐
    /// │Click to quit│
    /// └─────────────┘
    /// ```
    Component Button(ButtonOption option) 
    {
        return Make<ButtonBase>(std::move(option));
    }

    /// @brief Draw a button. Execute a function when clicked.
    /// @param label The label of the button.
    /// @param on_click The action to execute when clicked.
    /// @param option Additional optional parameters.
    /// @ingroup component
    /// @see ButtonBase
    ///
    /// ### Example
    ///
    /// ```cpp
    /// auto screen = ScreenInteractive::FitComponent();
    /// std::string label = "Click to quit";
    /// Component button = Button(&label, screen.ExitLoopClosure());
    /// screen.Loop(button)
    /// ```
    ///
    /// ### Output
    ///
    /// ```bash
    /// ┌─────────────┐
    /// │Click to quit│
    /// └─────────────┘
    /// ```
    // NOLINTNEXTLINE
    Component Button(ConstStringRef label, std::function<void()> on_click, ButtonOption option) 
    {
        option.label = std::move(label);
        option.on_click = std::move(on_click);
        return Make<ButtonBase>(std::move(option));
    }

}}}//qor::components::tui


