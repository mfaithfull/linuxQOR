// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include <algorithm>                              // for max
#include <functional>               // for function
#include <utility>                  // for move

#include "../ui/componentoptions.h"
#include "../dom/direction.h"
#include "../util/ref.h"
#include "../ui/capturedmouse.h"
#include "../ui/component.h"
#include "../ui/componentbase.h"
#include "../ui/event.h"
#include "../ui/mouse.h"
#include "../dom/elements.h"
#include "../screen/box.h"

namespace qor{ namespace components{ namespace tui {

    namespace 
    {

        class qor_pp_module_interface(QOR_TUI) ResizableSplitBase : public ComponentBase, public ResizableSplitOption 
        {
        public:
            explicit ResizableSplitBase(ResizableSplitOption options) : ResizableSplitOption(std::move(options)) 
            {
                switch (direction()) {
                case Direction::Left:
                    Add(Container::Horizontal({main, back}));
                    break;
                case Direction::Right:
                    Add(Container::Horizontal({back, main}));
                    break;
                case Direction::Up:
                    Add(Container::Vertical({main, back}));
                    break;
                case Direction::Down:
                    Add(Container::Vertical({back, main}));
                    break;
                }
            }

            bool OnEvent(Event event) final {
                if (event.is_mouse()) {
                return OnMouseEvent(std::move(event));
                }
                return ComponentBase::OnEvent(std::move(event));
            }

            bool OnMouseEvent(Event event) {
                if (captured_mouse_ && event.mouse().motion == Mouse::Released) {
                captured_mouse_.reset();
                return true;
                }

                if (event.mouse().button == Mouse::Left &&
                    event.mouse().motion == Mouse::Pressed &&
                    separator_box_.Contain(event.mouse().x, event.mouse().y) &&
                    !captured_mouse_) {
                captured_mouse_ = CaptureMouse(event);
                return true;
                }

                if (!captured_mouse_) {
                return ComponentBase::OnEvent(event);
                }

                switch (direction()) {
                case Direction::Left:
                    main_size() = std::max(0, event.mouse().x - box_.x_min);
                    break;
                case Direction::Right:
                    main_size() = std::max(0, box_.x_max - event.mouse().x);
                    break;
                case Direction::Up:
                    main_size() = std::max(0, event.mouse().y - box_.y_min);
                    break;
                case Direction::Down:
                    main_size() = std::max(0, box_.y_max - event.mouse().y);
                    break;
                }

                main_size() = std::clamp(main_size(), min(), max());
                return true;
            }

            Element OnRender() final {
                switch (direction()) {
                case Direction::Left:
                    return RenderLeft();
                case Direction::Right:
                    return RenderRight();
                case Direction::Up:
                    return RenderTop();
                case Direction::Down:
                    return RenderBottom();
                }
                // NOTREACHED()
                return text("unreacheable");
            }

            Element RenderLeft() {
                return hbox({
                        main->Render() | size(WIDTH, EQUAL, main_size()),
                        separator_func() | reflect(separator_box_),
                        back->Render() | xflex,
                    }) |
                    reflect(box_);
            }

            Element RenderRight() {
                return hbox({
                        back->Render() | xflex,
                        separator_func() | reflect(separator_box_),
                        main->Render() | size(WIDTH, EQUAL, main_size()),
                    }) |
                    reflect(box_);
            }

            Element RenderTop() {
                return vbox({
                        main->Render() | size(HEIGHT, EQUAL, main_size()),
                        separator_func() | reflect(separator_box_),
                        back->Render() | yflex,
                    }) |
                    reflect(box_);
            }

            Element RenderBottom() {
                return vbox({
                        back->Render() | yflex,
                        separator_func() | reflect(separator_box_),
                        main->Render() | size(HEIGHT, EQUAL, main_size()),
                    }) |
                    reflect(box_);
            }

        private:
            CapturedMouse captured_mouse_;
            Box separator_box_;
            Box box_;
        };

    }  // namespace

    /// @brief A split in between two components.
    /// @param options all the parameters.
    ///
    /// ### Example
    ///
    /// ```cpp
    /// auto left = Renderer([] { return text("Left") | center;});
    /// auto right = Renderer([] { return text("right") | center;});
    /// int left_size = 10;
    /// auto component = ResizableSplit({
    ///   .main = left,
    ///   .back = right,
    ///   .direction = Direction::Left,
    ///   .main_size = &left_size,
    ///   .separator_func = [] { return separatorDouble(); },
    /// });
    /// ```
    ///
    /// ### Output
    ///
    /// ```bash
    ///           ║
    ///    left   ║   right
    ///           ║
    /// ```
    qor_pp_module_interface(QOR_TUI) Component ResizableSplit(ResizableSplitOption options) {
    return Make<ResizableSplitBase>(std::move(options));
    }

    /// @brief An horizontal split in between two components, configurable using the
    /// mouse.
    /// @param main The main component of size |main_size|, on the left.
    /// @param back The back component taking the remaining size, on the right.
    /// @param main_size The size of the |main| component.
    /// @ingroup component
    ///
    /// ### Example
    ///
    /// ```cpp
    /// auto screen = ScreenInteractive::Fullscreen();
    /// int left_size = 10;
    /// auto left = Renderer([] { return text("Left") | center;});
    /// auto right = Renderer([] { return text("right") | center;});
    /// auto split = ResizableSplitLeft(left, right, &left_size);
    /// screen.Loop(split);
    /// ```
    ///
    /// ### Output
    ///
    /// ```bash
    ///           │
    ///    left   │   right
    ///           │
    /// ```
    qor_pp_module_interface(QOR_TUI)Component ResizableSplitLeft(Component main, Component back, int* main_size) {
    return ResizableSplit({
        std::move(main),
        std::move(back),
        Direction::Left,
        main_size,
    });
    }

    /// @brief An horizontal split in between two components, configurable using the
    /// mouse.
    /// @param main The main component of size |main_size|, on the right.
    /// @param back The back component taking the remaining size, on the left.
    /// @param main_size The size of the |main| component.
    /// @ingroup component
    ///
    /// ### Example
    ///
    /// ```cpp
    /// auto screen = ScreenInteractive::Fullscreen();
    /// int right_size = 10;
    /// auto left = Renderer([] { return text("Left") | center;});
    /// auto right = Renderer([] { return text("right") | center;});
    /// auto split = ResizableSplitRight(right, left, &right_size)
    /// screen.Loop(split);
    /// ```
    ///
    /// ### Output
    ///
    /// ```bash
    ///           │
    ///    left   │   right
    ///           │
    /// ```
    qor_pp_module_interface(QOR_TUI)Component ResizableSplitRight(Component main, Component back, int* main_size) {
    return ResizableSplit({
        std::move(main),
        std::move(back),
        Direction::Right,
        main_size,
    });
    }

    /// @brief An vertical split in between two components, configurable using the
    /// mouse.
    /// @param main The main component of size |main_size|, on the top.
    /// @param back The back component taking the remaining size, on the bottom.
    /// @param main_size The size of the |main| component.
    /// @ingroup component
    ///
    /// ### Example
    ///
    /// ```cpp
    /// auto screen = ScreenInteractive::Fullscreen();
    /// int top_size = 1;
    /// auto top = Renderer([] { return text("Top") | center;});
    /// auto bottom = Renderer([] { return text("Bottom") | center;});
    /// auto split = ResizableSplitTop(top, bottom, &top_size)
    /// screen.Loop(split);
    /// ```
    ///
    /// ### Output
    ///
    /// ```bash
    ///    top
    /// ────────────
    ///    bottom
    /// ```
    qor_pp_module_interface(QOR_TUI) Component ResizableSplitTop(Component main, Component back, int* main_size) 
    {
        return ResizableSplit({
            std::move(main),
            std::move(back),
            Direction::Up,
            main_size,
        });
    }

    /// @brief An vertical split in between two components, configurable using the
    /// mouse.
    /// @param main The main component of size |main_size|, on the bottom.
    /// @param back The back component taking the remaining size, on the top.
    /// @param main_size The size of the |main| component.
    /// @ingroup component
    ///
    /// ### Example
    ///
    /// ```cpp
    /// auto screen = ScreenInteractive::Fullscreen();
    /// int bottom_size = 1;
    /// auto top = Renderer([] { return text("Top") | center;});
    /// auto bottom = Renderer([] { return text("Bottom") | center;});
    /// auto split = ResizableSplit::Bottom(bottom, top, &bottom_size)
    /// screen.Loop(split);
    /// ```
    ///
    /// ### Output
    ///
    /// ```bash
    ///    top
    /// ────────────
    ///    bottom
    /// ```
    qor_pp_module_interface(QOR_TUI) Component ResizableSplitBottom(Component main, Component back, int* main_size) 
    {
        return ResizableSplit({
            std::move(main),
            std::move(back),
            Direction::Down,
            main_size,
        });
    }

}}}//qor::components::tui



