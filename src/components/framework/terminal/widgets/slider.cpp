// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include <algorithm>
#include <string>
#include <utility>

#include "../ui/componentoptions.h"
#include "../dom/direction.h"
#include "../ui/capturedmouse.h"
#include "../ui/component.h"
#include "../ui/componentbase.h"
#include "../ui/event.h"
#include "../ui/mouse.h"
#include "../ui/screeninteractive.h"
#include "../dom/elements.h"
#include "../screen/box.h"
#include "../screen/colour.h"
#include "../util/ref.h"

namespace qor{ namespace components{ namespace tui {

    namespace 
    {
        Decorator flexDirection(Direction direction) 
        {
            switch (direction) {
                case Direction::Up:
                case Direction::Down:
                return yflex;
                case Direction::Left:
                case Direction::Right:
                return xflex;
            }
            return xflex;
        }

        Direction Opposite(Direction d) 
        {
            switch (d) {
                case Direction::Up:
                return Direction::Down;
                case Direction::Down:
                return Direction::Up;
                case Direction::Left:
                return Direction::Right;
                case Direction::Right:
                return Direction::Left;
            }
            return d;
        }

        template <class T>
        class SliderBase : public SliderOption<T>, public ComponentBase 
        {
        public:
            explicit SliderBase(SliderOption<T> options) : SliderOption<T>(options) {}

            Element OnRender() override {
                auto gauge_color =
                    Focused() ? color(this->color_active) : color(this->color_inactive);
                const float percent =
                    float(this->value() - this->min()) / float(this->max() - this->min());
                return gaugeDirection(percent, this->direction) |
                    flexDirection(this->direction) | reflect(gauge_box_) | gauge_color;
            }

            void OnDirection(Direction pressed) {
                if (pressed == this->direction) {
                this->value() += this->increment();
                return;
                }

                if (pressed == Opposite(this->direction)) {
                this->value() -= this->increment();
                return;
                }
            }

            bool OnEvent(Event event) final {
                if (event.is_mouse()) {
                return OnMouseEvent(event);
                }

                T old_value = this->value();
                if (event == Event::ArrowLeft || event == Event::Character('h')) {
                OnDirection(Direction::Left);
                }
                if (event == Event::ArrowRight || event == Event::Character('l')) {
                OnDirection(Direction::Right);
                }
                if (event == Event::ArrowUp || event == Event::Character('k')) {
                OnDirection(Direction::Up);
                }
                if (event == Event::ArrowDown || event == Event::Character('j')) {
                OnDirection(Direction::Down);
                }

                this->value() = std::max(this->min(), std::min(this->max(), this->value()));
                if (old_value != this->value()) {
                if (this->on_change) {
                    this->on_change();
                }
                return true;
                }

                return ComponentBase::OnEvent(event);
            }

            bool OnCapturedMouseEvent(Event event) {
                if (event.mouse().motion == Mouse::Released) {
                captured_mouse_ = nullptr;
                return true;
                }

                T old_value = this->value();
                switch (this->direction) {
                case Direction::Right: {
                    this->value() = this->min() + (event.mouse().x - gauge_box_.x_min) *
                                                    (this->max() - this->min()) /
                                                    (gauge_box_.x_max - gauge_box_.x_min);

                    break;
                }
                case Direction::Left: {
                    this->value() = this->max() - (event.mouse().x - gauge_box_.x_min) *
                                                    (this->max() - this->min()) /
                                                    (gauge_box_.x_max - gauge_box_.x_min);
                    break;
                }
                case Direction::Down: {
                    this->value() = this->min() + (event.mouse().y - gauge_box_.y_min) *
                                                    (this->max() - this->min()) /
                                                    (gauge_box_.y_max - gauge_box_.y_min);
                    break;
                }
                case Direction::Up: {
                    this->value() = this->max() - (event.mouse().y - gauge_box_.y_min) *
                                                    (this->max() - this->min()) /
                                                    (gauge_box_.y_max - gauge_box_.y_min);
                    break;
                }
                }

                this->value() = std::max(this->min(), std::min(this->max(), this->value()));

                if (old_value != this->value() && this->on_change) {
                this->on_change();
                }
                return true;
            }

            bool OnMouseEvent(Event event) {
                if (captured_mouse_) {
                return OnCapturedMouseEvent(event);
                }

                if (event.mouse().button != Mouse::Left) {
                return false;
                }
                if (event.mouse().motion != Mouse::Pressed) {
                return false;
                }

                if (!gauge_box_.Contain(event.mouse().x, event.mouse().y)) {
                return false;
                }

                captured_mouse_ = CaptureMouse(event);

                if (captured_mouse_) {
                TakeFocus();
                return OnCapturedMouseEvent(event);
                }

                return false;
            }

            bool Focusable() const final { return true; }

        private:
            Box gauge_box_;
            CapturedMouse captured_mouse_;
        };

        class qor_pp_module_interface(QOR_TUI) SliderWithLabel : public ComponentBase 
        {
        public:
            SliderWithLabel(ConstStringRef label, Component inner)
                : label_(std::move(label)) {
                Add(std::move(inner));
                SetActiveChild(ChildAt(0));
            }

        private:
            bool OnEvent(Event event) final {
                if (ComponentBase::OnEvent(event)) {
                return true;
                }

                if (!event.is_mouse()) {
                return false;
                }

                mouse_hover_ = box_.Contain(event.mouse().x, event.mouse().y);

                if (!mouse_hover_) {
                return false;
                }

                if (!CaptureMouse(event)) {
                return false;
                }

                return true;
            }

            Element OnRender() override {
                auto gauge_color = (Focused() || mouse_hover_) ? color(Colour::White) : color(Colour::GrayDark);
                auto element = hbox({
                                text(label_()) | dim | vcenter,
                                hbox({
                                    text("["),
                                    ComponentBase::Render() | underlined,
                                    text("]"),
                                }) | xflex,
                            }) |
                            gauge_color | xflex | reflect(box_);

                element |= focus;
                return element;
            }

            ConstStringRef label_;
            Box box_;
            bool mouse_hover_ = false;
        };

    }  // namespace

    /// @brief An horizontal slider.
    /// @param label The name of the slider.
    /// @param value The current value of the slider.
    /// @param min The minimum value.
    /// @param max The maximum value.
    /// @param increment The increment when used by the cursor.
    /// @ingroup component
    ///
    /// ### Example
    ///
    /// ```cpp
    /// auto screen = ScreenInteractive::TerminalOutput();
    /// int value = 50;
    /// auto slider = Slider("Value:", &value, 0, 100, 1);
    /// screen.Loop(slider);
    /// ```
    ///
    /// ### Output
    ///
    /// ```bash
    /// Value:[██████████████████████████                          ]
    /// ```
    qor_pp_module_interface(QOR_TUI) Component Slider(ConstStringRef label,
                    Ref<int> value,
                    ConstRef<int> min,
                    ConstRef<int> max,
                    ConstRef<int> increment) {
    SliderOption<int> option;
    option.value = value;
    option.min = min;
    option.max = max;
    option.increment = increment;
    auto slider = Make<SliderBase<int>>(option);
    return Make<SliderWithLabel>(std::move(label), slider);
    }

    qor_pp_module_interface(QOR_TUI) Component Slider(ConstStringRef label,
                    Ref<float> value,
                    ConstRef<float> min,
                    ConstRef<float> max,
                    ConstRef<float> increment) {
    SliderOption<float> option;
    option.value = value;
    option.min = min;
    option.max = max;
    option.increment = increment;
    auto slider = Make<SliderBase<float>>(option);
    return Make<SliderWithLabel>(std::move(label), slider);
    }

    qor_pp_module_interface(QOR_TUI) Component Slider(ConstStringRef label,
                    Ref<long> value,
                    ConstRef<long> min,
                    ConstRef<long> max,
                    ConstRef<long> increment) {
    SliderOption<long> option;
    option.value = value;
    option.min = min;
    option.max = max;
    option.increment = increment;
    auto slider = Make<SliderBase<long>>(option);
    return Make<SliderWithLabel>(std::move(label), slider);
    }

    /// @brief A slider in any direction.
    /// @param options The options
    /// ### Example
    ///
    /// ```cpp
    /// auto screen = ScreenInteractive::TerminalOutput();
    /// int value = 50;
    /// auto slider = Slider({
    ///   .value = &value,
    ///   .min = 0,
    ///   .max = 100,
    ///   .increment= 20,
    /// });
    /// screen.Loop(slider);
    /// ```
    template <typename T>
    Component Slider(SliderOption<T> options) {
    return Make<SliderBase<T>>(options);
    }

    template Component Slider(SliderOption<int8_t>);
    template Component Slider(SliderOption<int16_t>);
    template Component Slider(SliderOption<int32_t>);
    template Component Slider(SliderOption<int64_t>);

    template Component Slider(SliderOption<uint8_t>);
    template Component Slider(SliderOption<uint16_t>);
    template Component Slider(SliderOption<uint32_t>);
    template Component Slider(SliderOption<uint64_t>);

    template Component Slider(SliderOption<float>);
    template Component Slider(SliderOption<double>);

}}}//qor::components::tui

