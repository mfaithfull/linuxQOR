// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include <functional>
#include <utility>

#include "component.h"
#include "componentbase.h"
#include "event.h"

namespace qor{ namespace components{ namespace tui {

    class qor_pp_module_interface(QOR_TUI) CatchEventBase : public ComponentBase {
    public:
    // Constructor.
    explicit CatchEventBase(std::function<bool(Event)> on_event)
        : on_event_(std::move(on_event)) {}

    // Component implementation.
    bool OnEvent(Event event) override {
        if (on_event_(event)) {
        return true;
        } else {
        return ComponentBase::OnEvent(event);
        }
    }

    protected:
    std::function<bool(Event)> on_event_;
    };

    /// @brief Return a component, using |on_event| to catch events. This function
    /// must returns true when the event has been handled, false otherwise.
    /// @param child The wrapped component.
    /// @param on_event The function drawing the interface.
    

    /// auto screen = ScreenInteractive::TerminalOutput();
    /// auto renderer = Renderer([] {
    ///   return text("My interface");
    /// });
    /// auto component = CatchEvent(renderer, [&](Event event) {
    ///   if (event == Event::Character('q')) {
    ///     screen.ExitLoopClosure()();
    ///     return true;
    ///   }
    ///   return false;
    /// });
    /// screen.Loop(component);
    
    qor_pp_module_interface(QOR_TUI) Component CatchEvent(Component child, std::function<bool(Event event)> on_event) 
    {
        auto out = Make<CatchEventBase>(std::move(on_event));
        out->Add(std::move(child));
        return out;
    }

    //Decorate a component, using |on_event| to catch events. This function must return true when the event has been handled, false otherwise.
    //on_event The function drawing the interface.

    /// auto screen = ScreenInteractive::TerminalOutput();
    /// auto renderer = Renderer([] { return text("Hello world"); });
    /// renderer |= CatchEvent([&](Event event) {
    ///   if (event == Event::Character('q')) {
    ///     screen.ExitLoopClosure()();
    ///     return true;
    ///   }
    ///   return false;
    /// });
    /// screen.Loop(renderer);
    
    qor_pp_module_interface(QOR_TUI) ComponentDecorator CatchEvent(std::function<bool(Event)> on_event) 
    {
        return [on_event = std::move(on_event)](Component child) 
        {
            return CatchEvent(std::move(child), [on_event = on_event](Event event) 
            {
                return on_event(std::move(event));
            });
        };
    }

}}}//qor::components::tui

