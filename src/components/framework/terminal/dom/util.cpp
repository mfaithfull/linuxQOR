// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include <algorithm>
#include <functional>
#include <memory>
#include <utility>

#include "elements.h"
#include "node.h"
#include "requirement.h"
#include "../screen/box.h"
#include "../screen/screen.h"
#include "../screen/terminal.h"

namespace qor{ namespace components{ namespace tui {

    namespace 
    {
        Decorator compose(Decorator a, Decorator b) 
        {
            return [a = std::move(a), b = std::move(b)](Element element) {
            return b(a(std::move(element)));
            };
        }
    }  // namespace

    //A decoration doing absolutely nothing.
    qor_pp_export Element nothing(Element element) 
    {
        return element;
    }

    //Compose two decorator into one.
    /// ### Example
    /// auto decorator = bold | blink;
    qor_pp_export Decorator operator|(Decorator a, Decorator b) 
    {
        return compose(std::move(a), std::move(b));
    }

    //From a set of element, apply a decorator to every elements.
    //return the set of decorated element.
    
    qor_pp_export Elements operator|(Elements elements, Decorator decorator) 
    {
        Elements output;
        output.reserve(elements.size());
        for (auto& it : elements) 
        {
            output.push_back(std::move(it) | decorator);
        }
        return output;
    }

    //From an element, apply a decorator.
    //return the decorated element.
    /// ### Example
    /// Both of these are equivalent:
    /// bold(text("Hello"));
    /// text("Hello") | bold;
    qor_pp_export Element operator|(Element element, Decorator decorator) 
    {
        return decorator(std::move(element));
    }

    //Apply a decorator to an element.
    //return the decorated element.
    /// ### Example
    /// Both of these are equivalent:
    /// auto element = text("Hello");
    /// element |= bold;
    qor_pp_export Element& operator|=(Element& e, Decorator d) 
    {
        e = e | std::move(d);
        return e;
    }

    /// The minimal dimension that will fit the given element.
    qor_pp_export Dimensions Dimension::Fit(Element& e, bool extend_beyond_screen) 
    {
        const Dimensions fullsize = Dimension::Full();
        Box box;
        box.x_min = 0;
        box.y_min = 0;
        box.x_max = fullsize.dimx;
        box.y_max = fullsize.dimy;

        Node::Status status;
        e->Check(&status);
        const int max_iteration = 20;
        while (status.need_iteration && status.iteration < max_iteration) 
        {
            e->ComputeRequirement();

            // Don't give the element more space than it needs:
            box.x_max = std::min(box.x_max, e->requirement().min_x);
            box.y_max = e->requirement().min_y;
            if (!extend_beyond_screen) 
            {
                box.y_max = std::min(box.y_max, fullsize.dimy);
            }

            e->SetBox(box);
            status.need_iteration = false;
            status.iteration++;
            e->Check(&status);

            if (!status.need_iteration) 
            {
                break;
            }
            // Increase the size of the box until it fits...
            box.x_max = std::min(e->requirement().min_x, fullsize.dimx);
            box.y_max = e->requirement().min_y;

            // ... but don't go beyond the screen size:
            if (!extend_beyond_screen) 
            {
                box.y_max = std::min(box.y_max, fullsize.dimy);
            }
        }

        return 
        {
            box.x_max,
            box.y_max,
        };
    }

    /// An element of size 0x0 drawing nothing.

    qor_pp_export Element emptyElement() 
    {
        class Impl : public Node 
        {
            void ComputeRequirement() override 
            {
                requirement_.min_x = 0;
                requirement_.min_y = 0;
            }
        };
        return std::make_unique<Impl>();
    }

}}}//qor::components::tui
