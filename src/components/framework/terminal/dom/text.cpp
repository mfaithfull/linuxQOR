// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include <algorithm>
#include <memory>
#include <sstream>
#include <string>
#include <string_view>
#include <utility>

//#include "deprecated.h"   // for text, vtext
#include "elements.h"
#include "node.h"
#include "requirement.h"
#include "selection.h"
#include "../screen/box.h"
#include "../screen/screen.h"
#include "../screen/string.h"

namespace qor{ namespace components{ namespace tui {

    namespace 
    {
        using qor::components::tui::Screen;

        class Text : public Node 
        {
        public:
            explicit Text(std::string text) : text_(std::move(text)) {}
            explicit Text(std::string_view sv) : Text(std::string(sv)) {}

            void ComputeRequirement() override 
            {
                requirement_.min_x = string_width(text_);
                requirement_.min_y = 1;
                has_selection = false;
            }

            void Select(Selection& selection) override 
            {
                if (Box::Intersection(selection.GetBox(), box_).IsEmpty()) 
                {
                    return;
                }

                const Selection selection_saturated = selection.SaturateHorizontal(box_);

                has_selection = true;
                selection_start_ = selection_saturated.GetBox().x_min;
                selection_end_ = selection_saturated.GetBox().x_max;

                std::stringstream ss;
                int x = box_.x_min;
                for (const auto& cell : Utf8ToGlyphs(text_)) 
                {
                    if (cell == "\n") {
                        continue;
                    }
                    if (selection_start_ <= x && x <= selection_end_) {
                        ss << cell;
                    }
                    x++;
                }
                selection.AddPart(ss.str(), box_.y_min, selection_start_, selection_end_);
            }

            void Render(Screen& screen) override 
            {
                int x = box_.x_min;
                const int y = box_.y_min;

                if (y > box_.y_max) 
                {
                    return;
                }

                for (const auto& cell : Utf8ToGlyphs(text_)) 
                {
                    if (x > box_.x_max) {
                        break;
                    }
                    if (cell == "\n") 
                    {
                        continue;
                    }
                    screen.PixelAt(x, y).character = cell;

                    if (has_selection) 
                    {
                        auto selectionTransform = screen.GetSelectionStyle();
                        if ((x >= selection_start_) && (x <= selection_end_)) 
                        {
                            selectionTransform(screen.PixelAt(x, y));
                        }
                    }

                    ++x;
                }
            }

        private:
            std::string text_;
            bool has_selection = false;
            int selection_start_ = 0;
            int selection_end_ = -1;
        };

        class VText : public Node 
        {
        public:
            explicit VText(std::string text)
                : text_(std::move(text)), width_{std::min(string_width(text_), 1)} {}

            explicit VText(std::string_view sv) : VText(std::string(sv)) {}

            void ComputeRequirement() override {
                requirement_.min_x = width_;
                requirement_.min_y = string_width(text_);
            }

            void Render(Screen& screen) override {
                const int x = box_.x_min;
                int y = box_.y_min;
                if (x + width_ - 1 > box_.x_max) {
                return;
                }
                for (const auto& it : Utf8ToGlyphs(text_)) {
                if (y > box_.y_max) {
                    return;
                }
                screen.PixelAt(x, y).character = it;
                y += 1;
                }
            }

        private:
            std::string text_;
            int width_ = 1;
        };

    }//

    //Display a piece of UTF8 encoded unicode text.
    // Element document = text("Hello world!");    
    Element text(std::string_view text) 
    {
        return std::make_shared<Text>(std::string(text));
    }

    //Display a piece of unicode text.
    // Element document = text(L"Hello world!");
    Element text(std::wstring text) 
    {
        return std::make_shared<Text>(to_string(text));
    }

    //Display a piece of unicode text.
    // Element document = text(L"Hello world!");
    // Hello world!
    Element text(std::wstring_view sv) 
    {
        return text(std::wstring(sv));
    }

    //Display a piece of unicode text vertically.
    // Element document = vtext("Hello world!");
    Element vtext(std::string_view text) 
    {
        return std::make_shared<VText>(std::string(text));
    }

    //Display a piece unicode text vertically.
    Element vtext(std::wstring text) 
    {
        return std::make_shared<VText>(to_string(text));
    }

    //Display a piece unicode text vertically.
    Element vtext(std::wstring_view text) 
    {
        return vtext(std::wstring(text));
    }

}}}//qor::components::tui
