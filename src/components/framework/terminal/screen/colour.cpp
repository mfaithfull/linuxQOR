// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include <array>

#include "colour.h"
#include "colourinfo.h"
#include "terminal.h"

namespace qor{ namespace components{ namespace tui {

    namespace 
    {
        const std::array<const char*, 33> palette16code = 
        {
            "30", "40",   //
            "31", "41",   //
            "32", "42",   //
            "33", "43",   //
            "34", "44",   //
            "35", "45",   //
            "36", "46",   //
            "37", "47",   //
            "90", "100",  //
            "91", "101",  //
            "92", "102",  //
            "93", "103",  //
            "94", "104",  //
            "95", "105",  //
            "96", "106",  //
            "97", "107",  //
        };
    }//

    bool Colour::operator==(const Colour& rhs) const 
    {
        return red_ == rhs.red_ && green_ == rhs.green_ && blue_ == rhs.blue_ && type_ == rhs.type_;
    }

    bool Colour::operator!=(const Colour& rhs) const 
    {
        return !operator==(rhs);
    }

    std::string Colour::Print(bool is_background_color) const 
    {
        if (is_background_color) 
        {
            switch (type_) 
            {
            case ColourType::Palette1:
                return "49";
            case ColourType::Palette16:
                return palette16code[2 * red_ + 1];  // NOLINT
            case ColourType::Palette256:
                return "48;5;" + std::to_string(red_);
            case ColourType::TrueColor:
                return "48;2;" + std::to_string(red_) + ";" + std::to_string(green_) + ";" + std::to_string(blue_);
            }
        } 
        else 
        {
            switch (type_) 
            {
            case ColourType::Palette1:
                return "39";
            case ColourType::Palette16:
                return palette16code[2 * red_];  // NOLINT
            case ColourType::Palette256:
                return "38;5;" + std::to_string(red_);
            case ColourType::TrueColor:
                return "38;2;" + std::to_string(red_) + ";" + std::to_string(green_) + ";" + std::to_string(blue_);
            }
        }        
        return "";
    }


    Colour::Colour() = default;

    Colour::Colour(Palette1 /*value*/) : Colour() {}

    //Build a colour using the Palette16 colors.
    Colour::Colour(Palette16 index) : type_(ColourType::Palette16), red_(index), alpha_(255) 
    {

    }

    //Build a colour using Palette256 colours.
    Colour::Colour(Palette256 index) : type_(ColourType::Palette256), red_(index), alpha_(255) 
    {
        if (Terminal::ColourSupport() >= Terminal::Colour::Palette256) 
        {
            return;
        }
        type_ = ColourType::Palette16;
        red_ = GetColourInfo(Colour::Palette256(red_)).index_16;
    }

    //Build a Colour from its RGB representation.
    //https://en.wikipedia.org/wiki/RGB_color_model
    Colour::Colour(uint8_t red, uint8_t green, uint8_t blue, uint8_t alpha) : type_(ColourType::TrueColor),
    red_(red),
    green_(green),
    blue_(blue),
    alpha_(alpha) 
    {
        if (Terminal::ColourSupport() == Terminal::Colour::TrueColour) 
        {
            return;
        }

        // Find the closest Colour from the database:
        const int max_distance = 256 * 256 * 3;
        int closest = max_distance;
        int best = 0;
        const int database_begin = 16;
        const int database_end = 256;
        for (int i = database_begin; i < database_end; ++i) 
        {
            const ColourInfo color_info = GetColourInfo(Colour::Palette256(i));
            const int dr = color_info.red - red;
            const int dg = color_info.green - green;
            const int db = color_info.blue - blue;
            const int dist = dr * dr + dg * dg + db * db;
            if (closest > dist) 
            {
                closest = dist;
                best = i;
            }
        }

        if (Terminal::ColourSupport() == Terminal::Colour::Palette256) 
        {
            type_ = ColourType::Palette256;
            red_ = best;
        } 
        else 
        {
            type_ = ColourType::Palette16;
            red_ = GetColourInfo(Colour::Palette256(best)).index_16;
        }
    }

    //Build a Colour from its RGB representation.
    //https://en.wikipedia.org/wiki/RGB_color_model
    //static
    Colour Colour::RGB(uint8_t red, uint8_t green, uint8_t blue) 
    {
        return RGBA(red, green, blue, 255);
    }

    //Build a Colour from its RGBA representation.
    /// https://en.wikipedia.org/wiki/RGB_color_model
    // static
    Colour Colour::RGBA(uint8_t red, uint8_t green, uint8_t blue, uint8_t alpha) 
    {
        return {red, green, blue, alpha};
    }

    //Build a Colour from its HSV representation.
    /// https://en.wikipedia.org/wiki/HSL_and_HSV
    // static
    Colour Colour::HSVA(uint8_t h, uint8_t s, uint8_t v, uint8_t alpha) 
    {
        uint8_t region = h / 43;                                        // NOLINT
        uint8_t remainder = (h - (region * 43)) * 6;                    // NOLINT
        uint8_t p = (v * (255 - s)) >> 8;                               // NOLINT
        uint8_t q = (v * (255 - ((s * remainder) >> 8))) >> 8;          // NOLINT
        uint8_t t = (v * (255 - ((s * (255 - remainder)) >> 8))) >> 8;  // NOLINT

        // clang-format off
        switch (region) {
        case 0: return Colour(v,t,p, alpha);
        case 1: return Colour(q,v,p, alpha);
        case 2: return Colour(p,v,t, alpha);
        case 3: return Colour(p,q,v, alpha);
        case 4: return Colour(t,p,v, alpha);
        case 5: return Colour(v,p,q, alpha);
        }                   
        // clang-format on
        return {0, 0, 0, alpha};
    }

    //Build a Colour from its HSV representation.
    //https://en.wikipedia.org/wiki/HSL_and_HSV
    //static
    Colour Colour::HSV(uint8_t h, uint8_t s, uint8_t v) 
    {
        return HSVA(h, s, v, 255);
    }

    // static
    Colour Colour::Interpolate(float t, const Colour& a, const Colour& b) 
    {
        if (a.type_ == ColourType::Palette1 || b.type_ == ColourType::Palette1) 
        {
            if (t < 0.5F) 
            {
                return a;
            } 
            else 
            {
                return b;
            }
        }

        auto get_colour = [](const Colour& colour, uint8_t* red, uint8_t* green, uint8_t* blue) 
        {
            switch (colour.type_) 
            {
            case ColourType::Palette1: 
            {
                return;
            }

            case ColourType::Palette16: 
            {
                const ColourInfo info = GetColourInfo(Colour::Palette16(colour.red_));
                *red = info.red;
                *green = info.green;
                *blue = info.blue;
                return;
            }

            case ColourType::Palette256: 
            {
                const ColourInfo info = GetColourInfo(Colour::Palette256(colour.red_));
                *red = info.red;
                *green = info.green;
                *blue = info.blue;
                return;
            }

            case ColourType::TrueColor:
            default: 
            {
                *red = colour.red_;
                *green = colour.green_;
                *blue = colour.blue_;
                return;
            }
            }
        };

        uint8_t a_r = 0;
        uint8_t a_g = 0;
        uint8_t a_b = 0;
        uint8_t b_r = 0;
        uint8_t b_g = 0;
        uint8_t b_b = 0;
        get_colour(a, &a_r, &a_g, &a_b);
        get_colour(b, &b_r, &b_g, &b_b);

        // Gamma correction:
        // https://en.wikipedia.org/wiki/Gamma_correction
        auto interp = [t](uint8_t a_u, uint8_t b_u) 
        {
            constexpr float gamma = 2.2F;
            const float a_f = powf(a_u, gamma);
            const float b_f = powf(b_u, gamma);
            const float c_f = a_f * (1.0F - t) + b_f * t;
            return static_cast<uint8_t>(powf(c_f, 1.F / gamma));
        };
        return Colour::RGB(interp(a_r, b_r), interp(a_g, b_g), interp(a_b, b_b));
    }

    Colour Colour::Blend(const Colour& lhs, const Colour& rhs)
    {
        Colour out = Interpolate(float(rhs.alpha_) / 255.F, lhs, rhs);
        out.alpha_ = lhs.alpha_ + rhs.alpha_ - lhs.alpha_ * rhs.alpha_ / 255;
        return out;
    }

    inline namespace literals 
    {
        Colour operator""_rgb(unsigned long long int combined) 
        {
            // assert(combined <= 0xffffffU);
            auto const red = static_cast<uint8_t>(combined >> 16U);
            auto const green = static_cast<uint8_t>(combined >> 8U);
            auto const blue = static_cast<uint8_t>(combined);
            return {red, green, blue};
        }
    }//literals

}}}//qor::components::tui 
