// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include <string>
#include <format>

#include "src/qor/error/defaulterrorhandler.h"
#include "src/qor/log/defaultloghandler.h"
#include "src/framework/application/application_builder.h"
#include "netserver.h"
#include "netsession.h"
#include "src/components/framework/pipeline/connectors/socketconnector/socketconnector.h"
#include "src/components/framework/logaggregator/logaggregator.h"

using namespace qor;
using namespace qor::framework;
using namespace qor::pipeline;
using namespace qor::network;
using namespace qor::network::sockets;

namespace qor{ namespace components{

    NetworkServer::NetworkServer(unsigned port, ref_of<Protocol>::type protocol) :
        m_port(port),
        bind(new_ref<workflow::State>(this)),
        listen(new_ref<workflow::State>(this)),
        accept(new_ref<workflow::State>(this))
    {
        qor_pp_ofcontext;

        bind->Enter = [this, protocol]()->void
        {
            qor_pp_ofcontext;

            //Get the required features from the Application Role
            auto application = AppBuilder().TheApplication();
            auto role = application(qor_shared).GetRole();
            m_io = role(qor_shared).GetFeature<AsyncIOService>();
            m_threadPool = role(qor_shared).GetFeature<ThreadPool>();
            m_sockets = ThePlatform()(qor_shared).GetSubsystem<Sockets>();

            //Get a session for async IO
            m_ioSession = m_io->GetSession();

            //Set the socket for server connection
            m_serverSocket = m_sockets->CreateSocket(
                protocol->GetAddressFamily(), 
                protocol->FramingType(), 
                protocol->ProtocolType(), m_ioSession);

            Address serverAddress;
            serverAddress.sa_family = protocol->GetAddressFamily();
            serverAddress.SetPort(m_port);

            //Bind Server socket
            auto result = m_serverSocket->Bind(serverAddress);

            if( result < 0 )
            {
                std::string s(strerror(result));
                serious("Can't bind socket to port {0}: {1}", m_port,s);
                SetComplete(EXIT_FAILURE);            
            }
            else
            {
                log::inform("Bound server socket {0} to port {1}", m_serverSocket->m_fd, m_port);
                SetState(listen);
            }
        };

        listen->Enter = [this]()->void
        {
            qor_pp_ofcontext;
            //Listen on connection port
            auto result = m_serverSocket->Listen(2);//TODO: Make the backlog parameter configurable

            if( result < 0)
            {
                std::string s(strerror(result));
                serious("Can't listen on socket {0}: {1}", m_serverSocket->m_fd ,s);
                SetComplete(EXIT_FAILURE);
            }
            else
            {
                qor::log::inform("Listening on server socket: {0}...", m_serverSocket->m_fd);
                SetState(accept);
            }
        };

        accept->Enter = [this, protocol]()->void
        {
            qor_pp_ofcontext;
            Address ClientAddress;
            //Accept connections
            auto ClientSocket = m_serverSocket->Accept(m_ioSession, ClientAddress);
            
            if(!ClientSocket->IsAlive())
            {
                serious("Failed to accept client connection. Socket {0} failed is-alive check.", ClientSocket->m_fd );
            }
            else
            {
                auto addr = ClientAddress.GetIPV4Address();
                log::inform("Accepted client connection: {0}:{1}", ClientSocket->m_fd, addr );
                //Handle the connected client in it's own task
                m_threadPool->PostTask(
                    //Note: this lambda runs on a pool thread
                    [this, ClientSocket, protocol]()
                    {   
                        //Rename the thread for debugging to indicate which client session it's servicing
                        CurrentThread::GetCurrent().SetName(std::format("Client {0}", ClientSocket->m_fd));
                        //Run a client session
                        new_ref<NetworkSession>(ClientSocket, protocol)->Run(
                            [](Workflow& clientSession)
                            {
                                //Configure the client session with it's own error and log handlers
                                clientSession.m_errorHandler = new_ref<DefaultErrorHandler>();
                                clientSession.m_logHander = new_ref<DefaultLogHandler>();
                                auto logAggregator = AppBuilder().TheApplication(qor_shared)->GetRole(qor_shared)->GetFeature<components::LogAggregatorService>();
                                if(logAggregator.IsNotNull())
                                {
                                    connect(clientSession.m_logHander(qor_shared), clientSession.m_logHander->GetForwardSignal(), 
                                        logAggregator(qor_shared).Receiver(), &LogReceiver::ReceiveLog, 
                                        ConnectionKind::QueuedConnection);
                                    logAggregator->Receiver().WriteToStandardOutput();
                                }                                
                            }
                        );
                    }
                );
            }
        };

        SetInitialState(bind);
    }
}}//qor::components

