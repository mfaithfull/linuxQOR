// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include "socketclient.h"

namespace qor{ namespace components{ namespace network{

    SocketClient::SocketClient(const std::string& host, int port) : 
        m_host(escape_abstract_namespace_unix_domain(host)), 
        m_port(port), 
        m_hostAndPort(adjust_host_string(m_host) + ":" + std::to_string(port))
    {
        m_OutputBuffer.SetCapacity(16384);
        m_InputBuffer.SetCapacity(4096);
        m_Connector = new_ref<SocketClientConnector>();
        m_Writer.SetPlug(m_Connector);
        m_Reader.SetPlug(m_Connector);        
    }    

    std::string SocketClient::Host() const
    {
        return m_host;
    }

    void SocketClient::Stop() 
    {
        std::lock_guard<std::mutex> guard(socket_mutex_);

        // If there is anything ongoing right now, the ONLY thread-safe thing we can
        // do is to shutdown_socket, so that threads using this socket suddenly
        // discover they can't read/write any more and error out. Everything else
        // (closing the socket, shutting ssl down) is unsafe because these actions are
        // not thread-safe.
        if (socket_requests_in_flight_ > 0) 
        {
            m_Socket->Shutdown(qor::network::sockets::eShutdown::ShutdownReadWrite);
            // Aside from that, we set a flag for the socket to be closed when we're done.
            socket_should_be_closed_when_request_is_done_ = true;
            return;
        }

        // Otherwise, still holding the mutex, we can shut everything down ourselves
        m_Socket->Shutdown(qor::network::sockets::eShutdown::ShutdownReadWrite);
        m_Socket.Dispose();
    }

    void SocketClient::SetHostnameAddressMap(std::map<std::string, std::string> addr_map)
    {
        m_AddressMap = std::move(addr_map);
    }

    void SocketClient::SetAddressFamily(qor::network::sockets::eAddressFamily family)
    {
        m_AddressFamily = family;
    }

    void SocketClient::SetTCPNoDelay(bool on)
    {
        m_TCPNoDelay = on;
    }

    void SocketClient::SetIPV6Only(bool on)
    {
        m_IPv6Only = on;
    }
/*
    void SocketClient::SetSocketOptions(SocketOptions socket_options)
    {
        socket_options_ = std::move(socket_options);
    }
*/
    void SocketClient::SetInterface(const std::string &intf)
    {
        m_Interface = intf;
    }

    void SocketClient::SetProxy(const std::string &host, int port) 
    {
        m_ProxyHost = host;
        m_ProxyPort = port;
    }

    void SocketClient::ShutdownSocket() const
    {
        if(m_Socket.IsNotNull() && m_Socket->ID() != m_Socket->Invalid_Socket)
        {
            m_Socket->Shutdown(qor::network::sockets::eShutdown::ShutdownReadWrite);
        }
    }

    void SocketClient::CloseSocket()
    {
        // If there are requests in flight in another thread, usually closing
        // the socket will be fine and they will simply receive an error when
        // using the closed socket, but it is still a bug since rarely the OS
        // may reassign the socket id to be used for a new socket, and then
        // suddenly they will be operating on a live socket that is different
        // than the one they intended!
        assert(socket_requests_in_flight_ == 0 || socket_requests_are_from_thread_ == std::this_thread::get_id());

        if(m_Socket.IsNotNull() && m_Socket->ID() != m_Socket->Invalid_Socket)
        {
            m_Socket.Dispose();
        }
    }

    bool SocketClient::SetSocketOptImpl(int level, int optname, const void *optval, socklen_t optlen)
    {
        return m_Socket->SetSockOpt(level, optname, (const char*)optval, optlen) == 0;
    }

    bool SocketClient::SetSocketOptTime(int level, int optname, time_t sec, time_t usec)
    {
#ifdef _WIN32
        auto timeout = static_cast<uint32_t>(sec * 1000 + usec / 1000);
#else
        timeval timeout;
        timeout.tv_sec = static_cast<long>(sec);
        timeout.tv_usec = static_cast<decltype(timeout.tv_usec)>(usec);
#endif
        return SetSocketOptImpl(level, optname, &timeout, sizeof(timeout));
    }

    bool SocketClient::Connect(const std::string &host, const std::string &ip, int port)//, qor::network::sockets::eAddressFamily address_family, qor::network::addrinfo_flags socket_flags, bool tcp_nodelay, bool ipv6_v6only, SocketOptions socket_options, time_t connection_timeout_sec, time_t connection_timeout_usec, time_t read_timeout_sec, time_t read_timeout_usec, time_t write_timeout_sec, time_t write_timeout_usec, const std::string &intf)
    {
        m_Connector->ConnectToAddress(host, ip, port, m_AddressFamily, 0, m_TCPNoDelay, m_IPv6Only, connection_timeout_sec_);
        m_Socket = m_Connector->m_Socket;
        return m_Socket.IsNotNull() && m_Socket->ID() != m_Socket->Invalid_Socket;
    }

    SocketWriter* SocketClient::GetWriter()
    {
        return &m_Writer;
    }

    bool SocketClient::Connect()
    {
        if (!m_ProxyHost.empty() && m_ProxyPort != -1) 
        {
            return Connect(m_ProxyHost, std::string(), m_ProxyPort);//, m_AddressFamily, 0, m_TCPNoDelay, m_IPv6Only, socket_options_, connection_timeout_sec_, connection_timeout_usec_, read_timeout_sec_, read_timeout_usec_, write_timeout_sec_, write_timeout_usec_, m_Interface);
        }

        // Check is custom IP specified for m_host
        std::string ip;
        auto it = m_AddressMap.find(m_host);
        if (it != m_AddressMap.end()) 
        { 
            ip = it->second; 
        }

        return Connect(m_host, ip, m_port);//, m_AddressFamily, 0, m_TCPNoDelay, m_IPv6Only, socket_options_, connection_timeout_sec_, connection_timeout_usec_, read_timeout_sec_, read_timeout_usec_, write_timeout_sec_, write_timeout_usec_, m_Interface);
    }

    void SocketClient::SetConnectionTimeout(time_t sec, time_t usec)
    {
        connection_timeout_sec_ = sec;
        connection_timeout_usec_ = usec;
    }

    void SocketClient::SetReadTimeout(time_t sec, time_t usec)
    {
        read_timeout_sec_ = sec;
        read_timeout_usec_ = usec;
    }

    void SocketClient::SetWriteTimeout(time_t sec, time_t usec)
    {
        write_timeout_sec_ = sec;
        write_timeout_usec_ = usec;
    }

    void SocketClient::SetMaxTimeout(time_t msec)
    {
        max_timeout_msec_ = msec;
    }

    bool SocketClient::is_connection_error()
    {
#ifdef _WIN32
        return WSAGetLastError() != WSAEWOULDBLOCK;
#else
        return errno != EINPROGRESS;
#endif
    }

    bool SocketClient::PrepareToSend()
    {
        std::lock_guard<std::mutex> guard(socket_mutex_);

        // Set this to false immediately - if it ever gets set to true by the end of
        // the request, we know another thread instructed us to close the socket.
        socket_should_be_closed_when_request_is_done_ = false;

        auto is_alive = false;
        if(m_Socket.IsNotNull() && m_Socket->ID() != m_Socket->Invalid_Socket) 
        {
            is_alive = m_Socket->IsAlive();

            if (!is_alive) 
            {
                // Attempt to avoid sigpipe by shutting down non-gracefully if it seems like the other side has already closed the connection Also, there
                // cannot be any requests in flight from other threads since we locked request_mutex_, so safe to close everything immediately
                m_Socket->Shutdown(qor::network::sockets::eShutdown::ShutdownReadWrite);
                m_Socket.Dispose();
            }
        }

        if (!is_alive) 
        {
            if (!Connect()) 
            {
                //TODO:output_error_log(error, &req);
                return false;
            }
        }

        // Mark the current socket as being in use so that it cannot be closed by
        // anyone else while this request is ongoing, even though we will be
        // releasing the mutex.
        if (socket_requests_in_flight_ > 1) 
        {
            assert(socket_requests_are_from_thread_ == std::this_thread::get_id());
        }
        socket_requests_in_flight_ += 1;
        socket_requests_are_from_thread_ = std::this_thread::get_id();
        return true;
    }

    bool SocketClient::Process(std::chrono::time_point<std::chrono::steady_clock> start_time, std::function<bool(void*)> callback)
    {        
        auto close_connection = !keep_alive_;
        auto result = callback(&m_Writer);
        if(result == false || close_connection)
        {
            Shutdown();
        }
        return result;
    }   

    void SocketClient::Shutdown(void)
    {
        std::lock_guard<std::mutex> guard(socket_mutex_);
        if(m_Socket.IsNotNull() && m_Socket->ID() != m_Socket->Invalid_Socket)
        {
            m_Socket->Shutdown(qor::network::sockets::eShutdown::ShutdownReadWrite);
            m_Socket.Dispose();
        }
    }

    bool SocketClient::FollowLocation(void)
    {
        return this->follow_location_;
    }

    bool SocketClient::IsUnixSocket(void)
    {
        return m_AddressFamily == AF_UNIX ? true : false;
    }

    unsigned short SocketClient::Port(void) const
    {
        return m_port;
    }
        
    bool SocketClient::IsSSL(void)
    {
        return false;
    }

    std::string SocketClient::GetHost(void)
    {
        return m_host;
    }
        
    std::string SocketClient::GetHostAndPort(void)
    {
        return m_hostAndPort;
    }

    qor::pipeline::Sink* SocketClient::GetSink(void)
    {
        return &m_Writer;
    }

    qor::pipeline::Source* SocketClient::GetSource(void)
    {
        return &m_Reader;
    }

    qor::pipeline::Buffer* SocketClient::GetOutputBuffer(void)
    {
        return &m_OutputBuffer;
    }

    qor::pipeline::Buffer* SocketClient::GetInputBuffer(void)
    {
        return &m_InputBuffer;
    }

}}}//qor::components::network
