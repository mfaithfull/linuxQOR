// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_COMPONENTS_NETWORK_CLIENTS_HTTP_PROTOHTTPCLIENT
#define QOR_PP_H_COMPONENTS_NETWORK_CLIENTS_HTTP_PROTOHTTPCLIENT

#include <mutex>
#include <cassert>
#include "src/components/protocols/http/result.h"
#include "src/components/protocols/http/response.h"
#include "src/components/protocols/http/headers.h"
#include "src/components/protocols/http/datasink.h"
#include "src/components/protocols/http/forms.h"
#include "src/components/protocols/http/request.h"
#include "src/components/protocols/http/error.h"
#include "src/components/protocols/http/contentprovideradapter.h"
#include "src/components/protocols/http/requestwriter.h"
#include "src/components/protocols/http/responsereader.h"
#include "src/components/network/clients/http/text.h"

#include "src/components/network/clients/itransportclient.h"

#define CPPHTTPLIB_VERSION "0.26.0"

namespace qor{ namespace components{ namespace network{

    using DownloadProgress = std::function<bool(size_t current, size_t total)>;
    using UploadProgress = std::function<bool(size_t current, size_t total)>;
    using ContentReceiverWithProgress = std::function<bool(const char *data, size_t data_length, size_t offset, size_t total_length)>;
    using ContentReceiver = std::function<bool(const char *data, size_t data_length)>;
    using ResponseHandler = std::function<bool(const protocols::http::Response &response)>;
    using Params = std::multimap<std::string, std::string>;
    using ContentProvider = std::function<bool(size_t offset, size_t length,  protocols::http::DataSink &sink)>;
    using ContentProviderWithoutLength = std::function<bool(size_t offset,  protocols::http::DataSink &sink)>;
    using Logger = std::function<void(const protocols::http::Request &, const protocols::http::Response &)>;

    // Forward declaration for Error type
    using Error = protocols::http::Error;
    using ErrorLogger = std::function<void(const Error &, const protocols::http::Request*)>;

    class qor_pp_module_interface(QOR_HTTPCLIENT) ProtoHTTPClient
    {

    public:

        ProtoHTTPClient();

        protocols::http::Result Get(const std::string &path, DownloadProgress progress = nullptr);
        protocols::http::Result Get(const std::string &path, ContentReceiver content_receiver, DownloadProgress progress = nullptr);
        protocols::http::Result Get(const std::string &path, ResponseHandler response_handler, ContentReceiver content_receiver, DownloadProgress progress = nullptr);
        protocols::http::Result Get(const std::string &path, const protocols::http::Headers &headers, DownloadProgress progress = nullptr);
        protocols::http::Result Get(const std::string &path, const protocols::http::Headers &headers, ContentReceiver content_receiver, DownloadProgress progress = nullptr);
        protocols::http::Result Get(const std::string &path, const protocols::http::Headers &headers, ResponseHandler response_handler, ContentReceiver content_receiver, DownloadProgress progress = nullptr);
        protocols::http::Result Get(const std::string &path, const Params &params, const protocols::http::Headers &headers, DownloadProgress progress = nullptr);
        protocols::http::Result Get(const std::string &path, const Params &params, const protocols::http::Headers &headers, ContentReceiver content_receiver, DownloadProgress progress = nullptr);
        protocols::http::Result Get(const std::string &path, const Params &params, const protocols::http::Headers &headers, ResponseHandler response_handler, ContentReceiver content_receiver, DownloadProgress progress = nullptr);

        protocols::http::Result Head(const std::string &path);
        protocols::http::Result Head(const std::string &path, const protocols::http::Headers &headers);

        protocols::http::Result Post(const std::string &path);
        protocols::http::Result Post(const std::string &path, const char *body, size_t content_length, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Post(const std::string &path, const std::string &body, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Post(const std::string &path, size_t content_length, ContentProvider content_provider, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Post(const std::string &path, ContentProviderWithoutLength content_provider, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Post(const std::string &path, const Params &params);
        protocols::http::Result Post(const std::string &path, const protocols::http::UploadFormDataItems &items, UploadProgress progress = nullptr);
        protocols::http::Result Post(const std::string &path, const protocols::http::Headers &headers);
        protocols::http::Result Post(const std::string &path, const protocols::http::Headers &headers, const char *body, size_t content_length, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Post(const std::string &path, const protocols::http::Headers &headers, const std::string &body, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Post(const std::string &path, const protocols::http::Headers &headers, size_t content_length, ContentProvider content_provider, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Post(const std::string &path, const protocols::http::Headers &headers, ContentProviderWithoutLength content_provider, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Post(const std::string &path, const protocols::http::Headers &headers, const Params &params);
        protocols::http::Result Post(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, UploadProgress progress = nullptr);
        protocols::http::Result Post(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, const std::string &boundary, UploadProgress progress = nullptr);
        protocols::http::Result Post(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, const protocols::http::FormDataProviderItems &provider_items, UploadProgress progress = nullptr);
        protocols::http::Result Post(const std::string &path, const protocols::http::Headers &headers, const std::string &body, const std::string &content_type, ContentReceiver content_receiver, DownloadProgress progress = nullptr);

        protocols::http::Result Put(const std::string &path);
        protocols::http::Result Put(const std::string &path, const char *body, size_t content_length, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Put(const std::string &path, const std::string &body, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Put(const std::string &path, size_t content_length, ContentProvider content_provider, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Put(const std::string &path, ContentProviderWithoutLength content_provider, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Put(const std::string &path, const Params &params);
        protocols::http::Result Put(const std::string &path, const protocols::http::UploadFormDataItems &items, UploadProgress progress = nullptr);
        protocols::http::Result Put(const std::string &path, const protocols::http::Headers &headers);
        protocols::http::Result Put(const std::string &path, const protocols::http::Headers &headers, const char *body, size_t content_length, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Put(const std::string &path, const protocols::http::Headers &headers, const std::string &body, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Put(const std::string &path, const protocols::http::Headers &headers, size_t content_length, ContentProvider content_provider, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Put(const std::string &path, const protocols::http::Headers &headers, ContentProviderWithoutLength content_provider, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Put(const std::string &path, const protocols::http::Headers &headers, const Params &params);
        protocols::http::Result Put(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, UploadProgress progress = nullptr);
        protocols::http::Result Put(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, const std::string &boundary, UploadProgress progress = nullptr);
        protocols::http::Result Put(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, const protocols::http::FormDataProviderItems &provider_items, UploadProgress progress = nullptr);
        protocols::http::Result Put(const std::string &path, const protocols::http::Headers &headers, const std::string &body, const std::string &content_type, ContentReceiver content_receiver, DownloadProgress progress = nullptr);

        protocols::http::Result Patch(const std::string &path);
        protocols::http::Result Patch(const std::string &path, const char *body, size_t content_length, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Patch(const std::string &path, const std::string &body, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Patch(const std::string &path, size_t content_length, ContentProvider content_provider, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Patch(const std::string &path, ContentProviderWithoutLength content_provider, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Patch(const std::string &path, const Params &params);
        protocols::http::Result Patch(const std::string &path, const protocols::http::UploadFormDataItems &items, UploadProgress progress = nullptr);
        protocols::http::Result Patch(const std::string &path, const protocols::http::Headers &headers);
        protocols::http::Result Patch(const std::string &path, const protocols::http::Headers &headers, const char *body, size_t content_length, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Patch(const std::string &path, const protocols::http::Headers &headers, const std::string &body, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Patch(const std::string &path, const protocols::http::Headers &headers, size_t content_length, ContentProvider content_provider, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Patch(const std::string &path, const protocols::http::Headers &headers, ContentProviderWithoutLength content_provider, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Patch(const std::string &path, const protocols::http::Headers &headers, const Params &params);
        protocols::http::Result Patch(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, UploadProgress progress = nullptr);
        protocols::http::Result Patch(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, const std::string &boundary, UploadProgress progress = nullptr);
        protocols::http::Result Patch(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, const protocols::http::FormDataProviderItems &provider_items, UploadProgress progress = nullptr);
        protocols::http::Result Patch(const std::string &path, const protocols::http::Headers &headers, const std::string &body, const std::string &content_type, ContentReceiver content_receiver, DownloadProgress progress = nullptr);

        protocols::http::Result Delete(const std::string &path, DownloadProgress progress = nullptr);
        protocols::http::Result Delete(const std::string &path, const char *body, size_t content_length, const std::string &content_type, DownloadProgress progress = nullptr);
        protocols::http::Result Delete(const std::string &path, const std::string &body, const std::string &content_type, DownloadProgress progress = nullptr);
        protocols::http::Result Delete(const std::string &path, const Params &params, DownloadProgress progress = nullptr);
        protocols::http::Result Delete(const std::string &path, const protocols::http::Headers &headers, DownloadProgress progress = nullptr);
        protocols::http::Result Delete(const std::string &path, const protocols::http::Headers &headers, const char *body, size_t content_length, const std::string &content_type, DownloadProgress progress = nullptr);
        protocols::http::Result Delete(const std::string &path, const protocols::http::Headers &headers, const std::string &body, const std::string &content_type, DownloadProgress progress = nullptr);
        protocols::http::Result Delete(const std::string &path, const protocols::http::Headers &headers, const Params &params, DownloadProgress progress = nullptr);

        protocols::http::Result Options(const std::string &path);
        protocols::http::Result Options(const std::string &path, const protocols::http::Headers &headers);

    private:

        bool send(protocols::http::Request &req, protocols::http::Response &res, Error &error);
        protocols::http::Result send(const protocols::http::Request &req);
        bool send_(protocols::http::Request &req, protocols::http::Response &res, Error &error);
        protocols::http::Result send_(protocols::http::Request &&req);

        void SetRequestTimeout(protocols::http::Request& req)
        {
            if (m_transport->GetMaxTimeout_msec() > 0) 
            {
                req.StartTimeout();
            }
        }

        std::string append_query_params(const std::string &path, const Params &params) 
        {
            std::string path_with_query = path;
            thread_local const std::regex re("[^?]+\\?.*");
            auto delm = std::regex_match(path, re) ? '&' : '?';
            path_with_query += delm + params_to_query_str(params);
            return path_with_query;
        }

        std::string params_to_query_str(const Params &params) 
        {
            std::string query;

            for (auto it = params.begin(); it != params.end(); ++it) 
            {
                if (it != params.begin()) { query += "&"; }
                query += encode_query_component(it->first);
                query += "=";
                query += encode_query_component(it->second);
            }
            return query;
        }

        std::string encode_query_component(const std::string &component, bool space_as_plus = true) 
        {
            std::string result;
            result.reserve(component.size() * 3);

            for (size_t i = 0; i < component.size(); i++) 
            {
                auto c = static_cast<unsigned char>(component[i]);

                // Unreserved characters per RFC 3986
                if (std::isalnum(c) || c == '-' || c == '.' || c == '_' || c == '~') 
                {
                    result += static_cast<char>(c);
                }
                // Space handling
                else if (c == ' ') 
                {
                    if (space_as_plus) 
                    {
                        result += '+';
                    } 
                    else {
                        result += "%20";
                    }
                }
                // Plus sign handling
                else if (c == '+') 
                {
                    if (space_as_plus) 
                    {
                        result += "%2B";
                    } 
                    else 
                    {
                        result += static_cast<char>(c);
                    }
                }
                // Query-safe sub-delimiters (excluding & and = which are query delimiters)
                else if (c == '!' || c == '$' || c == '\'' || c == '(' || c == ')' || c == '*' || c == ',' || c == ';') 
                {
                    result += static_cast<char>(c);
                }
                // Colon and @ are allowed in query
                else if (c == ':' || c == '@') 
                {
                    result += static_cast<char>(c);
                }
                // Forward slash is allowed in query values
                else if (c == '/') 
                {
                    result += static_cast<char>(c);
                }
                // Question mark is allowed in query values (after first ?)
                else if (c == '?') 
                {
                    result += static_cast<char>(c);
                } 
                else 
                {
                    result += '%';
                    char hex[3];
                    snprintf(hex, sizeof(hex), "%02X", c);
                    result.append(hex, 2);
                }
            }
            return result;
        }

        std::string decode_query_component(const std::string &component, bool plus_as_space = true) 
        {
            std::string result;
            result.reserve(component.size());

            for (size_t i = 0; i < component.size(); i++) 
            {
                if (component[i] == '%' && i + 2 < component.size()) 
                {
                    std::string hex = component.substr(i + 1, 2);
                    char *end;
                    unsigned long value = std::strtoul(hex.c_str(), &end, 16);
                    if (end == hex.c_str() + 2) 
                    {
                        result += static_cast<char>(value);
                        i += 2;
                    } 
                    else 
                    {
                        result += component[i];
                    }
                } 
                else if (component[i] == '+' && plus_as_space) 
                {
                    result += ' '; // + becomes space in form-urlencoded
                } 
                else 
                {
                    result += component[i];
                }
            }
            return result;
        }

        std::unique_ptr<protocols::http::Response> send_with_content_provider( protocols::http::Request &req, const char *body, size_t content_length, ContentProvider content_provider, ContentProviderWithoutLength content_provider_without_length, const std::string &content_type, Error &error)
        {
            if (!content_type.empty()) 
            { 
                req.set_header("Content-Type", content_type); 
            }

#ifdef CPPHTTPLIB_ZLIB_SUPPORT
            if (compress_) 
            { 
                req.set_header("Content-Encoding", "gzip"); 
            }
#endif

#ifdef CPPHTTPLIB_ZLIB_SUPPORT
            if (compress_ && !content_provider_without_length) 
            {
            // TODO: Brotli support
            detail::gzip_compressor compressor;

            if (content_provider) {
            auto ok = true;
            size_t offset = 0;
            DataSink data_sink;

            data_sink.write = [&](const char *data, size_t data_len) -> bool {
            if (ok) {
            auto last = offset + data_len == content_length;

            auto ret = compressor.compress(
            data, data_len, last,
            [&](const char *compressed_data, size_t compressed_data_len) {
            req.body.append(compressed_data, compressed_data_len);
            return true;
            });

            if (ret) {
            offset += data_len;
            } else {
            ok = false;
            }
            }
            return ok;
            };

            while (ok && offset < content_length) {
            if (!content_provider(offset, content_length - offset, data_sink)) {
            error = Error::Canceled;
            output_error_log(error, &req);
            return nullptr;
            }
            }
            } else {
            if (!compressor.compress(body, content_length, true,
            [&](const char *data, size_t data_len) {
            req.body.append(data, data_len);
            return true;
            })) {
            error = Error::Compression;
            output_error_log(error, &req);
            return nullptr;
            }
            }
            } else
#endif
            {
            if (content_provider) 
            {
                req.SetContentLength(content_length);
                req.SetContentProvider(std::move(content_provider));
                req.SetIsChunkedContentProvider(false);
            } 
            else if (content_provider_without_length) 
            {
                req.SetContentLength(0);
                req.SetContentProvider( protocols::http::ContentProviderAdapter( std::move(content_provider_without_length)));
                req.SetIsChunkedContentProvider(true);
                req.set_header("Transfer-Encoding", "chunked");
            } 
            else 
            {
                req.body.assign(body, content_length);
            }
            }

            auto res = std::make_unique<protocols::http::Response>();
            return send(req, *res, error) ? std::move(res) : nullptr;
        }

        protocols::http::Result send_with_content_provider( const std::string &method, const std::string &path, const protocols::http::Headers &headers, const char *body, size_t content_length, ContentProvider content_provider, ContentProviderWithoutLength content_provider_without_length, const std::string &content_type, UploadProgress progress) 
        {
            protocols::http::Request req;
            req.method = method;
            req.headers = headers;
            req.path = path;
            req.upload_progress = std::move(progress);
            SetRequestTimeout(req);

            auto error = Error::Success;

            auto res = send_with_content_provider(req, body, content_length, std::move(content_provider), std::move(content_provider_without_length), content_type, error);

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
            return Result{std::move(res), error, std::move(req.headers), last_ssl_error_,
            last_openssl_error_};
#else
            return protocols::http::Result{std::move(res), error, std::move(req.headers)};
#endif
        }


        std::string base64_encode(const std::string &in) 
        {
            static const auto lookup = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            std::string out;
            out.reserve(in.size());
            auto val = 0;
            auto valb = -6;
            for (auto c : in) 
            {
                val = (val << 8) + static_cast<uint8_t>(c);
                valb += 8;
                while (valb >= 0) 
                {
                    out.push_back(lookup[(val >> valb) & 0x3F]);
                    valb -= 6;
                }
            }

            if (valb > -6) 
            { 
                out.push_back(lookup[((val << 8) >> (valb + 8)) & 0x3F]); 
            }

            while (out.size() % 4) 
            {
                out.push_back('=');
            }

            return out;
        }

        std::pair<std::string, std::string> make_basic_authentication_header(const std::string &username, const std::string &password, bool is_proxy) 
        {
            auto field = "Basic " + base64_encode(username + ":" + password);
            auto key = is_proxy ? "Proxy-Authorization" : "Authorization";
            return std::make_pair(key, std::move(field));
        }

        std::pair<std::string, std::string> make_bearer_token_authentication_header(const std::string &token, bool is_proxy = false) 
        {
            auto field = "Bearer " + token;
            auto key = is_proxy ? "Proxy-Authorization" : "Authorization";
            return std::make_pair(key, std::move(field));
        }

        std::string encode_path(const std::string &s) 
        {
            std::string result;
            result.reserve(s.size());

            for (size_t i = 0; s[i]; i++) 
            {
                switch (s[i]) 
                {
                case ' ': result += "%20"; break;
                case '+': result += "%2B"; break;
                case '\r': result += "%0D"; break;
                case '\n': result += "%0A"; break;
                case '\'': result += "%27"; break;
                case ',': result += "%2C"; break;
                // case ':': result += "%3A"; break; // ok? probably...
                case ';': result += "%3B"; break;
                default:
                    auto c = static_cast<uint8_t>(s[i]);
                    if (c >= 0x80) 
                    {
                        result += '%';
                        char hex[4];
                        auto len = snprintf(hex, sizeof(hex) - 1, "%02X", c);
                        assert(len == 2);
                        result.append(hex, static_cast<size_t>(len));
                    } 
                    else 
                    {
                        result += s[i];
                    }
                    break;
                }
            }

            return result;
        }

        void parse_query_text(const char *data, std::size_t size, Params &params) 
        {
            std::set<std::string> cache;
            text::split(data, data + size, '&', [&](const char *b, const char *e) 
                {
                    std::string kv(b, e);
                    if (cache.find(kv) != cache.end()) 
                    { 
                        return; 
                    }
                    cache.insert(std::move(kv));

                    std::string key;
                    std::string val;
                    text::divide(b, static_cast<std::size_t>(e - b), '=', [&](const char *lhs_data, std::size_t lhs_size, const char *rhs_data, std::size_t rhs_size) 
                        {
                            key.assign(lhs_data, lhs_size);
                            val.assign(rhs_data, rhs_size);
                        }
                    );

                    if (!key.empty()) 
                    {
                        params.emplace(decode_query_component(key), decode_query_component(val));
                    }
                }
            );
        }

        inline void parse_query_text(const std::string &s, Params &params) 
        {
            parse_query_text(s.data(), s.size(), params);
        }

        bool PrepareRequest(protocols::http::Request &req, bool close_connection);
        bool HandleRequest(void* strm, protocols::http::Request &req, protocols::http::Response &res, bool close_connection, Error &error);
        bool process_request(void* strm, protocols::http::Request &req, protocols::http::Response &res, bool close_connection, Error &error);
        std::string ExtractPathAndQuery(protocols::http::Request& req);
        std::string EncodePathAndQuery(protocols::http::Request& req, const std::string& path_part, const std::string& query_part);

        ContentProviderWithoutLength get_multipart_content_provider( const std::string &boundary, const protocols::http::UploadFormDataItems &items, const protocols::http::FormDataProviderItems &provider_items) const;

        // Default headers
        protocols::http::Headers default_headers_;

        std::string basic_auth_username_;
        std::string basic_auth_password_;
        std::string bearer_token_auth_token_;
        std::string proxy_basic_auth_username_;
        std::string proxy_basic_auth_password_;
        std::string proxy_bearer_token_auth_token_;
        bool path_encode_ = true;

    protected:

        protocols::http::HTTPRequestWriter request_writer;
        protocols::http::HTTPResponseReader response_reader;
        ITransportClient* m_transport;
        std::recursive_mutex request_mutex_;
    };

}}}//qor::components::network

#endif//QOR_PP_H_COMPONENTS_NETWORK_CLIENTS_HTTP_PROTOHTTPCLIENT