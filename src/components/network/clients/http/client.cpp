// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include <string>
#include <regex>
#include "client.h"
#include "clientimpl.h"

namespace qor{ namespace components{ namespace network{
    
    // Universal client implementation
    HTTPClient::HTTPClient(const std::string &scheme_host_port) : HTTPClient(scheme_host_port, std::string(), std::string()) 
    {
    }

    HTTPClient::HTTPClient(const std::string &scheme_host_port, const std::string &client_cert_path, const std::string &client_key_path)
    {
        const static std::regex re(R"((?:([a-z]+):\/\/)?(?:\[([a-fA-F\d:]+)\]|([^:/?#]+))(?::(\d+))?)");

        std::smatch m;
        if (std::regex_match(scheme_host_port, m, re)) 
        {
            auto scheme = m[1].str();
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
            if (!scheme.empty() && (scheme != "http" && scheme != "https")) 
            {
#else
            if (!scheme.empty() && scheme != "http") 
            {
#endif
#ifndef CPPHTTPLIB_NO_EXCEPTIONS
                std::string msg = "'" + scheme + "' scheme is not supported.";
                throw std::invalid_argument(msg);
#endif
                return;
            }

            auto is_ssl = scheme == "https";
            auto host = m[2].str();
            if (host.empty()) 
            { 
                host = m[3].str(); 
            }

            auto port_str = m[4].str();
            auto port = !port_str.empty() ? std::stoi(port_str) : (is_ssl ? 443 : 80);

            if (is_ssl) 
            {
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
                cli_ = detail::make_unique<SSLClient>(host, port, client_cert_path,
                client_key_path);
                is_ssl_ = is_ssl;
#endif
            } 
            else 
            {
                cli_ = std::make_unique<ClientImpl>(host, port, client_cert_path, client_key_path);
            }
        } 
        else 
        {
            // NOTE: Update TEST(UniversalClientImplTest, Ipv6LiteralAddress)
            // if port param below changes.
            cli_ = std::make_unique<ClientImpl>(scheme_host_port, 80, client_cert_path, client_key_path);
        }
    }

    HTTPClient::HTTPClient(const std::string &host, int port) : cli_(std::make_unique<ClientImpl>(host, port)) 
    {        
    }

    HTTPClient::HTTPClient(const std::string &host, int port, const std::string &client_cert_path, const std::string &client_key_path) : cli_(std::make_unique<ClientImpl>(host, port, client_cert_path, client_key_path)) 
    {        
    }

    inline HTTPClient::~HTTPClient() = default;

    bool HTTPClient::is_valid() const 
    {
        return cli_ != nullptr && cli_->is_valid();
    }

    inline protocols::http::Result HTTPClient::Get(const std::string &path, DownloadProgress progress) {
    return cli_->Get(path, std::move(progress));
    }
    inline protocols::http::Result HTTPClient::Get(const std::string &path, const protocols::http::Headers &headers,
    DownloadProgress progress) {
    return cli_->Get(path, headers, std::move(progress));
    }
    inline protocols::http::Result HTTPClient::Get(const std::string &path,
    ContentReceiver content_receiver,
    DownloadProgress progress) {
    return cli_->Get(path, std::move(content_receiver), std::move(progress));
    }
    inline protocols::http::Result HTTPClient::Get(const std::string &path, const protocols::http::Headers &headers,
    ContentReceiver content_receiver,
    DownloadProgress progress) {
    return cli_->Get(path, headers, std::move(content_receiver),
    std::move(progress));
    }
    inline protocols::http::Result HTTPClient::Get(const std::string &path,
    ResponseHandler response_handler,
    ContentReceiver content_receiver,
    DownloadProgress progress) {
    return cli_->Get(path, std::move(response_handler),
    std::move(content_receiver), std::move(progress));
    }
    inline protocols::http::Result HTTPClient::Get(const std::string &path, const protocols::http::Headers &headers,
    ResponseHandler response_handler,
    ContentReceiver content_receiver,
    DownloadProgress progress) {
    return cli_->Get(path, headers, std::move(response_handler),
    std::move(content_receiver), std::move(progress));
    }
    inline protocols::http::Result HTTPClient::Get(const std::string &path, const Params &params,
    const protocols::http::Headers &headers, DownloadProgress progress) {
    return cli_->Get(path, params, headers, std::move(progress));
    }
    inline protocols::http::Result HTTPClient::Get(const std::string &path, const Params &params,
    const protocols::http::Headers &headers,
    ContentReceiver content_receiver,
    DownloadProgress progress) {
    return cli_->Get(path, params, headers, std::move(content_receiver),
    std::move(progress));
    }
    inline protocols::http::Result HTTPClient::Get(const std::string &path, const Params &params,
    const protocols::http::Headers &headers,
    ResponseHandler response_handler,
    ContentReceiver content_receiver,
    DownloadProgress progress) {
    return cli_->Get(path, params, headers, std::move(response_handler),
    std::move(content_receiver), std::move(progress));
    }

    inline protocols::http::Result HTTPClient::Head(const std::string &path) { return cli_->Head(path); }
    inline protocols::http::Result HTTPClient::Head(const std::string &path, const protocols::http::Headers &headers) {
    return cli_->Head(path, headers);
    }

    inline protocols::http::Result HTTPClient::Post(const std::string &path) { return cli_->Post(path); }
    inline protocols::http::Result HTTPClient::Post(const std::string &path, const protocols::http::Headers &headers) {
    return cli_->Post(path, headers);
    }
    inline protocols::http::Result HTTPClient::Post(const std::string &path, const char *body,
    size_t content_length,
    const std::string &content_type,
    UploadProgress progress) {
    return cli_->Post(path, body, content_length, content_type, progress);
    }
    inline protocols::http::Result HTTPClient::Post(const std::string &path, const protocols::http::Headers &headers,
    const char *body, size_t content_length,
    const std::string &content_type,
    UploadProgress progress) {
    return cli_->Post(path, headers, body, content_length, content_type,
    progress);
    }
    inline protocols::http::Result HTTPClient::Post(const std::string &path, const std::string &body,
    const std::string &content_type,
    UploadProgress progress) {
    return cli_->Post(path, body, content_type, progress);
    }
    inline protocols::http::Result HTTPClient::Post(const std::string &path, const protocols::http::Headers &headers,
    const std::string &body,
    const std::string &content_type,
    UploadProgress progress) {
    return cli_->Post(path, headers, body, content_type, progress);
    }
    inline protocols::http::Result HTTPClient::Post(const std::string &path, size_t content_length,
    ContentProvider content_provider,
    const std::string &content_type,
    UploadProgress progress) {
    return cli_->Post(path, content_length, std::move(content_provider),
    content_type, progress);
    }
    inline protocols::http::Result HTTPClient::Post(const std::string &path,
    ContentProviderWithoutLength content_provider,
    const std::string &content_type,
    UploadProgress progress) {
    return cli_->Post(path, std::move(content_provider), content_type, progress);
    }
    inline protocols::http::Result HTTPClient::Post(const std::string &path, const protocols::http::Headers &headers,
    size_t content_length,
    ContentProvider content_provider,
    const std::string &content_type,
    UploadProgress progress) {
    return cli_->Post(path, headers, content_length, std::move(content_provider),
    content_type, progress);
    }
    inline protocols::http::Result HTTPClient::Post(const std::string &path, const protocols::http::Headers &headers,
    ContentProviderWithoutLength content_provider,
    const std::string &content_type,
    UploadProgress progress) {
    return cli_->Post(path, headers, std::move(content_provider), content_type,
    progress);
    }
    inline protocols::http::Result HTTPClient::Post(const std::string &path, const Params &params) {
    return cli_->Post(path, params);
    }
    inline protocols::http::Result HTTPClient::Post(const std::string &path, const protocols::http::Headers &headers,
    const Params &params) {
    return cli_->Post(path, headers, params);
    }
    inline protocols::http::Result HTTPClient::Post(const std::string &path, const protocols::http::UploadFormDataItems &items, UploadProgress progress) 
    {
    return cli_->Post(path, items, progress);
    }
    inline protocols::http::Result HTTPClient::Post(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, UploadProgress progress) 
    {
    return cli_->Post(path, headers, items, progress);
    }
    inline protocols::http::Result HTTPClient::Post(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, const std::string &boundary, UploadProgress progress) 
    {
        return cli_->Post(path, headers, items, boundary, progress);
    }
    inline protocols::http::Result HTTPClient::Post(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, const protocols::http::FormDataProviderItems &provider_items, UploadProgress progress) 
    {
        return cli_->Post(path, headers, items, provider_items, progress);
    }

    inline protocols::http::Result HTTPClient::Post(const std::string &path, const protocols::http::Headers &headers, const std::string &body, const std::string &content_type, ContentReceiver content_receiver, DownloadProgress progress) 
    {
        return cli_->Post(path, headers, body, content_type, content_receiver, progress);
    }

    inline protocols::http::Result HTTPClient::Put(const std::string &path) 
    { 
        return cli_->Put(path); 
    }

    inline protocols::http::Result HTTPClient::Put(const std::string &path, const protocols::http::Headers &headers) 
    {
        return cli_->Put(path, headers);
    }

    inline protocols::http::Result HTTPClient::Put(const std::string &path, const char *body, size_t content_length, const std::string &content_type, UploadProgress progress) 
    {
        return cli_->Put(path, body, content_length, content_type, progress);
    }

    inline protocols::http::Result HTTPClient::Put(const std::string &path, const protocols::http::Headers &headers, const char *body, size_t content_length, const std::string &content_type, UploadProgress progress) 
    {
        return cli_->Put(path, headers, body, content_length, content_type, progress);
    }

    inline protocols::http::Result HTTPClient::Put(const std::string &path, const std::string &body, const std::string &content_type, UploadProgress progress) 
    {
        return cli_->Put(path, body, content_type, progress);
    }

    inline protocols::http::Result HTTPClient::Put(const std::string &path, const protocols::http::Headers &headers, const std::string &body, const std::string &content_type, UploadProgress progress) 
    {
        return cli_->Put(path, headers, body, content_type, progress);
    }

    inline protocols::http::Result HTTPClient::Put(const std::string &path, size_t content_length, ContentProvider content_provider, const std::string &content_type, UploadProgress progress) 
    {
        return cli_->Put(path, content_length, std::move(content_provider), content_type, progress);
    }

    inline protocols::http::Result HTTPClient::Put(const std::string &path, ContentProviderWithoutLength content_provider, const std::string &content_type, UploadProgress progress) 
    {
        return cli_->Put(path, std::move(content_provider), content_type, progress);
    }

    inline protocols::http::Result HTTPClient::Put(const std::string &path, const protocols::http::Headers &headers, size_t content_length, ContentProvider content_provider, const std::string &content_type, UploadProgress progress) 
    {
        return cli_->Put(path, headers, content_length, std::move(content_provider), content_type, progress);
    }

    inline protocols::http::Result HTTPClient::Put(const std::string &path, const protocols::http::Headers &headers, ContentProviderWithoutLength content_provider, const std::string &content_type, UploadProgress progress) 
    {
        return cli_->Put(path, headers, std::move(content_provider), content_type, progress);
    }

    inline protocols::http::Result HTTPClient::Put(const std::string &path, const Params &params) 
    {
        return cli_->Put(path, params);
    }

    inline protocols::http::Result HTTPClient::Put(const std::string &path, const protocols::http::Headers &headers, const Params &params) 
    {
        return cli_->Put(path, headers, params);
    }

    inline protocols::http::Result HTTPClient::Put(const std::string &path, const protocols::http::UploadFormDataItems &items, UploadProgress progress) 
    {
        return cli_->Put(path, items, progress);
    }

    inline protocols::http::Result HTTPClient::Put(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, UploadProgress progress) 
    {
        return cli_->Put(path, headers, items, progress);
    }

    inline protocols::http::Result HTTPClient::Put(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, const std::string &boundary, UploadProgress progress) 
    {
        return cli_->Put(path, headers, items, boundary, progress);
    }

    inline protocols::http::Result HTTPClient::Put(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, const protocols::http::FormDataProviderItems &provider_items, UploadProgress progress) 
    {
        return cli_->Put(path, headers, items, provider_items, progress);
    }

    inline protocols::http::Result HTTPClient::Put(const std::string &path, const protocols::http::Headers &headers, const std::string &body, const std::string &content_type, ContentReceiver content_receiver, DownloadProgress progress) 
    {
        return cli_->Put(path, headers, body, content_type, content_receiver, progress);
    }

    inline protocols::http::Result HTTPClient::Patch(const std::string &path) 
    {
        return cli_->Patch(path);
    }

    inline protocols::http::Result HTTPClient::Patch(const std::string &path, const protocols::http::Headers &headers) 
    {
        return cli_->Patch(path, headers);
    }

    inline protocols::http::Result HTTPClient::Patch(const std::string &path, const char *body, size_t content_length, const std::string &content_type, UploadProgress progress) 
    {
        return cli_->Patch(path, body, content_length, content_type, progress);
    }

    inline protocols::http::Result HTTPClient::Patch(const std::string &path, const protocols::http::Headers &headers, const char *body, size_t content_length, const std::string &content_type, UploadProgress progress) 
    {
        return cli_->Patch(path, headers, body, content_length, content_type, progress);
    }

    inline protocols::http::Result HTTPClient::Patch(const std::string &path, const std::string &body, const std::string &content_type, UploadProgress progress) 
    {
        return cli_->Patch(path, body, content_type, progress);
    }

    inline protocols::http::Result HTTPClient::Patch(const std::string &path, const protocols::http::Headers &headers, const std::string &body, const std::string &content_type, UploadProgress progress) 
    {
        return cli_->Patch(path, headers, body, content_type, progress);
    }

    inline protocols::http::Result HTTPClient::Patch(const std::string &path, size_t content_length, ContentProvider content_provider, const std::string &content_type, UploadProgress progress) 
    {
        return cli_->Patch(path, content_length, std::move(content_provider),
        content_type, progress);
    }

    inline protocols::http::Result HTTPClient::Patch(const std::string &path, ContentProviderWithoutLength content_provider, const std::string &content_type, UploadProgress progress) 
    {
        return cli_->Patch(path, std::move(content_provider), content_type, progress);
    }

    inline protocols::http::Result HTTPClient::Patch(const std::string &path, const protocols::http::Headers &headers, size_t content_length, ContentProvider content_provider, const std::string &content_type, UploadProgress progress) 
    {
        return cli_->Patch(path, headers, content_length, std::move(content_provider), content_type, progress);
    }

    inline protocols::http::Result HTTPClient::Patch(const std::string &path, const protocols::http::Headers &headers, ContentProviderWithoutLength content_provider, const std::string &content_type, UploadProgress progress) 
    {
        return cli_->Patch(path, headers, std::move(content_provider), content_type, progress);
    }

    inline protocols::http::Result HTTPClient::Patch(const std::string &path, const Params &params) 
    {
        return cli_->Patch(path, params);
    }

    inline protocols::http::Result HTTPClient::Patch(const std::string &path, const protocols::http::Headers &headers, const Params &params) 
    {
        return cli_->Patch(path, headers, params);
    }

    inline protocols::http::Result HTTPClient::Patch(const std::string &path, const protocols::http::UploadFormDataItems &items, UploadProgress progress) 
    {
        return cli_->Patch(path, items, progress);
    }

    inline protocols::http::Result HTTPClient::Patch(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, UploadProgress progress) 
    {
        return cli_->Patch(path, headers, items, progress);
    }

    inline protocols::http::Result HTTPClient::Patch(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, const std::string &boundary, UploadProgress progress) 
    {
        return cli_->Patch(path, headers, items, boundary, progress);
    }

    inline protocols::http::Result HTTPClient::Patch(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, const protocols::http::FormDataProviderItems &provider_items, UploadProgress progress) 
    {
        return cli_->Patch(path, headers, items, provider_items, progress);
    }

    inline protocols::http::Result HTTPClient::Patch(const std::string &path, const protocols::http::Headers &headers, const std::string &body, const std::string &content_type, ContentReceiver content_receiver, DownloadProgress progress) 
    {
        return cli_->Patch(path, headers, body, content_type, content_receiver, progress);
    }

    inline protocols::http::Result HTTPClient::Delete(const std::string &path, DownloadProgress progress) 
    {
        return cli_->Delete(path, progress);
    }

    inline protocols::http::Result HTTPClient::Delete(const std::string &path, const protocols::http::Headers &headers, DownloadProgress progress) 
    {
        return cli_->Delete(path, headers, progress);
    }

    inline protocols::http::Result HTTPClient::Delete(const std::string &path, const char *body, size_t content_length, const std::string &content_type, DownloadProgress progress) 
    {
        return cli_->Delete(path, body, content_length, content_type, progress);
    }

    inline protocols::http::Result HTTPClient::Delete(const std::string &path, const protocols::http::Headers &headers, const char *body, size_t content_length, const std::string &content_type, DownloadProgress progress) 
    {
        return cli_->Delete(path, headers, body, content_length, content_type, progress);
    }

    inline protocols::http::Result HTTPClient::Delete(const std::string &path, const std::string &body, const std::string &content_type, DownloadProgress progress) 
    {
        return cli_->Delete(path, body, content_type, progress);
    }

    inline protocols::http::Result HTTPClient::Delete(const std::string &path, const protocols::http::Headers &headers, const std::string &body, const std::string &content_type, DownloadProgress progress) 
    {
        return cli_->Delete(path, headers, body, content_type, progress);
    }

    inline protocols::http::Result HTTPClient::Delete(const std::string &path, const Params &params, DownloadProgress progress) 
    {
        return cli_->Delete(path, params, progress);
    }

    inline protocols::http::Result HTTPClient::Delete(const std::string &path, const protocols::http::Headers &headers, const Params &params, DownloadProgress progress) 
    {
        return cli_->Delete(path, headers, params, progress);
    }

    inline protocols::http::Result HTTPClient::Options(const std::string &path) 
    {
        return cli_->Options(path);
    }

    inline protocols::http::Result HTTPClient::Options(const std::string &path, const protocols::http::Headers &headers) 
    {
        return cli_->Options(path, headers);
    }

    inline bool HTTPClient::send(protocols::http::Request &req, protocols::http::Response &res, Error &error) 
    {
        return cli_->send(req, res, error);
    }

    inline protocols::http::Result HTTPClient::send(const protocols::http::Request &req) 
    { 
        return cli_->send(req); 
    }

    inline void HTTPClient::stop() { cli_->stop(); }

    inline std::string HTTPClient::host() const { return cli_->host(); }

    inline int HTTPClient::port() const { return cli_->port(); }

    inline size_t HTTPClient::is_socket_open() const { return cli_->is_socket_open(); }

    inline socket_t HTTPClient::socket() const { return cli_->socket(); }

    inline void HTTPClient::set_hostname_addr_map(std::map<std::string, std::string> addr_map) 
    {
        cli_->set_hostname_addr_map(std::move(addr_map));
    }

    inline void HTTPClient::set_default_headers(protocols::http::Headers headers) 
    {
        cli_->set_default_headers(std::move(headers));
    }

    inline void HTTPClient::set_header_writer(std::function<ssize_t(Stream &, protocols::http::Headers &)> const &writer) 
    {
        cli_->set_header_writer(writer);
    }

    inline void HTTPClient::set_address_family(int family) {
    cli_->set_address_family(family);
    }

    inline void HTTPClient::set_tcp_nodelay(bool on) { cli_->set_tcp_nodelay(on); }

    inline void HTTPClient::set_socket_options(SocketOptions socket_options) 
    {
        cli_->set_socket_options(std::move(socket_options));
    }

    inline void HTTPClient::set_connection_timeout(time_t sec, time_t usec) 
    {
        cli_->set_connection_timeout(sec, usec);
    }

    inline void HTTPClient::set_read_timeout(time_t sec, time_t usec) 
    {
        cli_->set_read_timeout(sec, usec);
    }

    inline void HTTPClient::set_write_timeout(time_t sec, time_t usec) 
    {
        cli_->set_write_timeout(sec, usec);
    }

    inline void HTTPClient::set_basic_auth(const std::string &username, const std::string &password) 
    {
        cli_->set_basic_auth(username, password);
    }

    inline void HTTPClient::set_bearer_token_auth(const std::string &token) 
    {
        cli_->set_bearer_token_auth(token);
    }

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
    inline void HTTPClient::set_digest_auth(const std::string &username,const std::string &password) 
    {
        cli_->set_digest_auth(username, password);
    }
#endif

    inline void HTTPClient::set_keep_alive(bool on) 
    { 
        cli_->set_keep_alive(on); 
    }

    inline void HTTPClient::set_follow_location(bool on) 
    {
        cli_->set_follow_location(on);
    }

    inline void HTTPClient::set_path_encode(bool on) { cli_->set_path_encode(on); }

    [[deprecated("Use set_path_encode instead")]]
    inline void HTTPClient::set_url_encode(bool on) 
    {
        cli_->set_path_encode(on);
    }

    inline void HTTPClient::set_compress(bool on) { cli_->set_compress(on); }

    inline void HTTPClient::set_decompress(bool on) { cli_->set_decompress(on); }

    inline void HTTPClient::set_interface(const std::string &intf) 
    {
        cli_->set_interface(intf);
    }

    inline void HTTPClient::set_proxy(const std::string &host, int port) 
    {
        cli_->set_proxy(host, port);
    }
    
    inline void HTTPClient::set_proxy_basic_auth(const std::string &username, const std::string &password) 
    {
        cli_->set_proxy_basic_auth(username, password);
    }

    inline void HTTPClient::set_proxy_bearer_token_auth(const std::string &token) 
    {
        cli_->set_proxy_bearer_token_auth(token);
    }

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
    inline void HTTPClient::set_proxy_digest_auth(const std::string &username, const std::string &password) 
    {
        cli_->set_proxy_digest_auth(username, password);
    }
#endif

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
    inline void HTTPClient::enable_server_certificate_verification(bool enabled) 
    {
        cli_->enable_server_certificate_verification(enabled);
    }

    inline void HTTPClient::enable_server_hostname_verification(bool enabled) 
    {
        cli_->enable_server_hostname_verification(enabled);
    }

    inline void HTTPClient::set_server_certificate_verifier( std::function<SSLVerifierResponse(SSL *ssl)> verifier) 
    {
        cli_->set_server_certificate_verifier(verifier);
    }
#endif

    inline void HTTPClient::set_logger(Logger logger) 
    {
        cli_->set_logger(std::move(logger));
    }

    inline void HTTPClient::set_error_logger(ErrorLogger error_logger) 
    {
        cli_->set_error_logger(std::move(error_logger));
    }

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
    inline void HTTPClient::set_ca_cert_path(const std::string &ca_cert_file_path, const std::string &ca_cert_dir_path) 
    {
        cli_->set_ca_cert_path(ca_cert_file_path, ca_cert_dir_path);
    }

    inline void HTTPClient::set_ca_cert_store(X509_STORE *ca_cert_store) 
    {
        if (is_ssl_) 
        {
            static_cast<SSLClient &>(*cli_).set_ca_cert_store(ca_cert_store);
        } 
        else 
        {
            cli_->set_ca_cert_store(ca_cert_store);
        }
    }

    inline void HTTPClient::load_ca_cert_store(const char *ca_cert, std::size_t size) 
    {
        set_ca_cert_store(cli_->create_ca_cert_store(ca_cert, size));
    }

    inline long HTTPClient::get_openssl_verify_result() const 
    {
        if (is_ssl_) 
        {
            return static_cast<SSLClient &>(*cli_).get_openssl_verify_result();
        }
        return -1; // NOTE: -1 doesn't match any of X509_V_ERR_???
    }

    inline SSL_CTX *HTTPClient::ssl_context() const 
    {
        if (is_ssl_) 
        { 
            return static_cast<SSLClient &>(*cli_).ssl_context(); 
        }
        return nullptr;
    }
#endif

}}}//qor::components::network
