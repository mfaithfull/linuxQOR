// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include <assert.h>
#include <regex>
#include "protohttpclient.h"
#include "src/components/protocols/http/multipart.h"

namespace qor{ namespace components{ namespace network{

    ProtoHTTPClient::ProtoHTTPClient()
    {        
    }

    protocols::http::Result ProtoHTTPClient::Get(const std::string &path, DownloadProgress progress) 
    {
        return Get(path, protocols::http::Headers(), std::move(progress));
    }

    protocols::http::Result ProtoHTTPClient::Get(const std::string &path, const Params &params, const protocols::http::Headers &headers, DownloadProgress progress) 
    {
        if (params.empty()) { return Get(path, headers); }

        std::string path_with_query = append_query_params(path, params);
        return Get(path_with_query, headers, std::move(progress));
    }

    protocols::http::Result ProtoHTTPClient::Get(const std::string &path, const protocols::http::Headers &headers, DownloadProgress progress) 
    {
        protocols::http::Request req;
        req.method = "GET";
        req.path = path;
        req.headers = headers;
        req.download_progress = std::move(progress);
        SetRequestTimeout(req);
        return send_(std::move(req));
    }

    protocols::http::Result ProtoHTTPClient::Get(const std::string &path, ContentReceiver content_receiver, DownloadProgress progress) 
    {
        return Get(path, protocols::http::Headers(), nullptr, std::move(content_receiver), std::move(progress));
    }

    protocols::http::Result ProtoHTTPClient::Get(const std::string &path, const protocols::http::Headers &headers, ContentReceiver content_receiver, DownloadProgress progress) 
    {
        return Get(path, headers, nullptr, std::move(content_receiver), std::move(progress));
    }

    protocols::http::Result ProtoHTTPClient::Get(const std::string &path, ResponseHandler response_handler, ContentReceiver content_receiver, DownloadProgress progress) 
    {
        return Get(path, protocols::http::Headers(), std::move(response_handler), std::move(content_receiver), std::move(progress));
    }

    protocols::http::Result ProtoHTTPClient::Get(const std::string &path, const protocols::http::Headers &headers, ResponseHandler response_handler, ContentReceiver content_receiver, DownloadProgress progress) 
    {
        protocols::http::Request req;
        req.method = "GET";
        req.path = path;
        req.headers = headers;
        req.response_handler = std::move(response_handler);
        req.content_receiver =
        [content_receiver](const char *data, size_t data_length,
        size_t /*offset*/, size_t /*total_length*/) 
        {
            return content_receiver(data, data_length);
        };
        req.download_progress = std::move(progress);
        SetRequestTimeout(req);

        return send_(std::move(req));
    }

    protocols::http::Result ProtoHTTPClient::Get(const std::string &path, const Params &params, const protocols::http::Headers &headers, ContentReceiver content_receiver, DownloadProgress progress) 
    {
        return Get(path, params, headers, nullptr, std::move(content_receiver), std::move(progress));
    }

    protocols::http::Result ProtoHTTPClient::Get(const std::string &path, const Params &params, const protocols::http::Headers &headers, ResponseHandler response_handler, ContentReceiver content_receiver, DownloadProgress progress) 
    {
        if (params.empty()) 
        {
            return Get(path, headers, std::move(response_handler),
            std::move(content_receiver), std::move(progress));
        }

        std::string path_with_query = append_query_params(path, params);
        return Get(path_with_query, headers, std::move(response_handler), std::move(content_receiver), std::move(progress));
    }

    protocols::http::Result ProtoHTTPClient::Head(const std::string &path) 
    {
        return Head(path, protocols::http::Headers());
    }

    protocols::http::Result ProtoHTTPClient::Head(const std::string &path, const protocols::http::Headers &headers) 
    {
        protocols::http::Request req;
        req.method = "HEAD";
        req.headers = headers;
        req.path = path;
        SetRequestTimeout(req);
        return send_(std::move(req));
    }

    protocols::http::Result ProtoHTTPClient::Post(const std::string &path) 
    {
        return Post(path, std::string(), std::string());
    }

    protocols::http::Result ProtoHTTPClient::Post(const std::string &path, const protocols::http::Headers &headers) 
    {
        return Post(path, headers, nullptr, 0, std::string());
    }

    protocols::http::Result ProtoHTTPClient::Post(const std::string &path, const char *body, size_t content_length, const std::string &content_type, UploadProgress progress) 
    {
        return Post(path, protocols::http::Headers(), body, content_length, content_type, progress);
    }

    protocols::http::Result ProtoHTTPClient::Post(const std::string &path, const std::string &body, const std::string &content_type, UploadProgress progress) 
    {
        return Post(path, protocols::http::Headers(), body, content_type, progress);
    }

    protocols::http::Result ProtoHTTPClient::Post(const std::string &path, const Params &params) 
    {
        return Post(path, protocols::http::Headers(), params);
    }

    protocols::http::Result ProtoHTTPClient::Post(const std::string &path, size_t content_length, ContentProvider content_provider, const std::string &content_type, UploadProgress progress) 
    {
        return Post(path, protocols::http::Headers(), content_length, std::move(content_provider), content_type, progress);
    }

    protocols::http::Result ProtoHTTPClient::Post(const std::string &path, ContentProviderWithoutLength content_provider, const std::string &content_type, UploadProgress progress) 
    {
        return Post(path, protocols::http::Headers(), std::move(content_provider), content_type, progress);
    }

    protocols::http::Result ProtoHTTPClient::Post(const std::string &path, const protocols::http::Headers &headers, const Params &params) 
    {
        auto query = params_to_query_str(params);
        return Post(path, headers, query, "application/x-www-form-urlencoded");
    }

    protocols::http::Result ProtoHTTPClient::Post(const std::string &path, const protocols::http::UploadFormDataItems &items, UploadProgress progress) 
    {
        return Post(path, protocols::http::Headers(), items, progress);
    }

    protocols::http::Result ProtoHTTPClient::Post(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, UploadProgress progress) 
    {
        const auto &boundary = protocols::http::make_multipart_data_boundary();
        const auto &content_type = protocols::http::serialize_multipart_formdata_get_content_type(boundary);
        const auto &body = protocols::http::serialize_multipart_formdata(items, boundary);
        return Post(path, headers, body, content_type, progress);
    }

    protocols::http::Result ProtoHTTPClient::Post(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, const std::string &boundary, UploadProgress progress) 
    {
        if (!protocols::http::is_multipart_boundary_chars_valid(boundary)) 
        {
            return protocols::http::Result{nullptr, Error::UnsupportedMultipartBoundaryChars};
        }

        const auto &content_type = protocols::http::serialize_multipart_formdata_get_content_type(boundary);
        const auto &body = protocols::http::serialize_multipart_formdata(items, boundary);
        return Post(path, headers, body, content_type, progress);
    }

    protocols::http::Result ProtoHTTPClient::Post(const std::string &path, const protocols::http::Headers &headers, const char *body, size_t content_length, const std::string &content_type, UploadProgress progress) 
    {
        return send_with_content_provider("POST", path, headers, body, content_length, nullptr, nullptr, content_type, progress);
    }

    protocols::http::Result ProtoHTTPClient::Post(const std::string &path, const protocols::http::Headers &headers, const std::string &body, const std::string &content_type, UploadProgress progress) 
    {
        return send_with_content_provider("POST", path, headers, body.data(), body.size(), nullptr, nullptr, content_type, progress);
    }

    protocols::http::Result ProtoHTTPClient::Post(const std::string &path, const protocols::http::Headers &headers, size_t content_length, ContentProvider content_provider, const std::string &content_type, UploadProgress progress) 
    {
        return send_with_content_provider("POST", path, headers, nullptr, content_length, std::move(content_provider), nullptr, content_type, progress);
    }

    protocols::http::Result ProtoHTTPClient::Post(const std::string &path, const protocols::http::Headers &headers, ContentProviderWithoutLength content_provider, const std::string &content_type, UploadProgress progress) 
    {
        return send_with_content_provider("POST", path, headers, nullptr, 0, nullptr, std::move(content_provider), content_type, progress);
    }

    protocols::http::Result ProtoHTTPClient::Post(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, const protocols::http::FormDataProviderItems &provider_items, UploadProgress progress) 
    {
        const auto &boundary = protocols::http::make_multipart_data_boundary();
        const auto &content_type = protocols::http::serialize_multipart_formdata_get_content_type(boundary);
        return send_with_content_provider("POST", path, headers, nullptr, 0, nullptr, get_multipart_content_provider(boundary, items, provider_items), content_type, progress);
    }

    protocols::http::Result ProtoHTTPClient::Post(const std::string &path, const protocols::http::Headers &headers, const std::string &body, const std::string &content_type, ContentReceiver content_receiver, DownloadProgress progress) 
    {
        protocols::http::Request req;
        req.method = "POST";
        req.path = path;
        req.headers = headers;
        req.body = body;
        req.content_receiver =
        [content_receiver](const char *data, size_t data_length,
        size_t /*offset*/, size_t /*total_length*/) {
        return content_receiver(data, data_length);
        };
        req.download_progress = std::move(progress);
        SetRequestTimeout(req);

        if (!content_type.empty()) { req.set_header("Content-Type", content_type); }

        return send_(std::move(req));
    }

    inline protocols::http::Result ProtoHTTPClient::Put(const std::string &path) 
    {
        return Put(path, std::string(), std::string());
    }

    inline protocols::http::Result ProtoHTTPClient::Put(const std::string &path, const protocols::http::Headers &headers) 
    {
        return Put(path, headers, nullptr, 0, std::string());
    }

    inline protocols::http::Result ProtoHTTPClient::Put(const std::string &path, const char *body, size_t content_length, const std::string &content_type, UploadProgress progress) 
    {
        return Put(path, protocols::http::Headers(), body, content_length, content_type, progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Put(const std::string &path, const std::string &body, const std::string &content_type, UploadProgress progress) 
    {
        return Put(path, protocols::http::Headers(), body, content_type, progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Put(const std::string &path, const Params &params) 
    {
        return Put(path, protocols::http::Headers(), params);
    }

    inline protocols::http::Result ProtoHTTPClient::Put(const std::string &path, size_t content_length,
    ContentProvider content_provider,
    const std::string &content_type,
    UploadProgress progress) {
    return Put(path, protocols::http::Headers(), content_length, std::move(content_provider),
    content_type, progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Put(const std::string &path,
    ContentProviderWithoutLength content_provider,
    const std::string &content_type,
    UploadProgress progress) {
    return Put(path, protocols::http::Headers(), std::move(content_provider), content_type,
    progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Put(const std::string &path, const protocols::http::Headers &headers,
    const Params &params) {
    auto query = params_to_query_str(params);
    return Put(path, headers, query, "application/x-www-form-urlencoded");
    }

    inline protocols::http::Result ProtoHTTPClient::Put(const std::string &path,
    const protocols::http::UploadFormDataItems &items,
    UploadProgress progress) {
    return Put(path, protocols::http::Headers(), items, progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Put(const std::string &path, const protocols::http::Headers &headers,
    const protocols::http::UploadFormDataItems &items, UploadProgress progress) {
    const auto &boundary = protocols::http::make_multipart_data_boundary();
    const auto &content_type =
    protocols::http::serialize_multipart_formdata_get_content_type(boundary);
    const auto &body = protocols::http::serialize_multipart_formdata(items, boundary);
    return Put(path, headers, body, content_type, progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Put(const std::string &path, const protocols::http::Headers &headers,
    const protocols::http::UploadFormDataItems &items,
    const std::string &boundary,
    UploadProgress progress) {
    if (!protocols::http::is_multipart_boundary_chars_valid(boundary)) {
    return protocols::http::Result{nullptr, Error::UnsupportedMultipartBoundaryChars};
    }

    const auto &content_type =
    protocols::http::serialize_multipart_formdata_get_content_type(boundary);
    const auto &body = protocols::http::serialize_multipart_formdata(items, boundary);
    return Put(path, headers, body, content_type, progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Put(const std::string &path, const protocols::http::Headers &headers,
    const char *body, size_t content_length,
    const std::string &content_type,
    UploadProgress progress) {
    return send_with_content_provider("PUT", path, headers, body, content_length,
    nullptr, nullptr, content_type, progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Put(const std::string &path, const protocols::http::Headers &headers,
    const std::string &body,
    const std::string &content_type,
    UploadProgress progress) {
    return send_with_content_provider("PUT", path, headers, body.data(),
    body.size(), nullptr, nullptr, content_type,
    progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Put(const std::string &path, const protocols::http::Headers &headers,
    size_t content_length,
    ContentProvider content_provider,
    const std::string &content_type,
    UploadProgress progress) {
    return send_with_content_provider("PUT", path, headers, nullptr,
    content_length, std::move(content_provider),
    nullptr, content_type, progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Put(const std::string &path, const protocols::http::Headers &headers,
    ContentProviderWithoutLength content_provider,
    const std::string &content_type,
    UploadProgress progress) {
    return send_with_content_provider("PUT", path, headers, nullptr, 0, nullptr,
    std::move(content_provider), content_type,
    progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Put(const std::string &path, const protocols::http::Headers &headers,
    const protocols::http::UploadFormDataItems &items,
    const protocols::http::FormDataProviderItems &provider_items,
    UploadProgress progress) {
    const auto &boundary = protocols::http::make_multipart_data_boundary();
    const auto &content_type =
    protocols::http::serialize_multipart_formdata_get_content_type(boundary);
    return send_with_content_provider(
    "PUT", path, headers, nullptr, 0, nullptr,
    get_multipart_content_provider(boundary, items, provider_items),
    content_type, progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Put(const std::string &path, const protocols::http::Headers &headers,
    const std::string &body,
    const std::string &content_type,
    ContentReceiver content_receiver,
    DownloadProgress progress) {
    protocols::http::Request req;
    req.method = "PUT";
    req.path = path;
    req.headers = headers;
    req.body = body;
    req.content_receiver =
    [content_receiver](const char *data, size_t data_length,
    size_t /*offset*/, size_t /*total_length*/) {
    return content_receiver(data, data_length);
    };
    req.download_progress = std::move(progress);
    SetRequestTimeout(req);

    if (!content_type.empty()) { req.set_header("Content-Type", content_type); }

    return send_(std::move(req));
    }

    inline protocols::http::Result ProtoHTTPClient::Patch(const std::string &path) 
    {
        return Patch(path, std::string(), std::string());
    }
/*
    inline protocols::http::Result ProtoHTTPClient::Patch(const std::string &path, const protocols::http::Headers &headers, UploadProgress progress) 
    {
        return Patch(path, headers, nullptr, 0, std::string(), progress);
    }
*/
    inline protocols::http::Result ProtoHTTPClient::Patch(const std::string &path, const char *body, size_t content_length, const std::string &content_type, UploadProgress progress) 
    {
        return Patch(path, protocols::http::Headers(), body, content_length, content_type, progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Patch(const std::string &path, const std::string &body, const std::string &content_type, UploadProgress progress) 
    {
        return Patch(path, protocols::http::Headers(), body, content_type, progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Patch(const std::string &path, const Params &params) {
    return Patch(path, protocols::http::Headers(), params);
    }

    inline protocols::http::Result ProtoHTTPClient::Patch(const std::string &path, size_t content_length,
    ContentProvider content_provider,
    const std::string &content_type,
    UploadProgress progress) {
    return Patch(path, protocols::http::Headers(), content_length, std::move(content_provider),
    content_type, progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Patch(const std::string &path,
    ContentProviderWithoutLength content_provider,
    const std::string &content_type,
    UploadProgress progress) {
    return Patch(path, protocols::http::Headers(), std::move(content_provider), content_type,
    progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Patch(const std::string &path, const protocols::http::Headers &headers,
    const Params &params) {
    auto query = params_to_query_str(params);
    return Patch(path, headers, query, "application/x-www-form-urlencoded");
    }

    inline protocols::http::Result ProtoHTTPClient::Patch(const std::string &path,
    const protocols::http::UploadFormDataItems &items,
    UploadProgress progress) {
    return Patch(path, protocols::http::Headers(), items, progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Patch(const std::string &path, const protocols::http::Headers &headers,
    const protocols::http::UploadFormDataItems &items,
    UploadProgress progress) {
    const auto &boundary = protocols::http::make_multipart_data_boundary();
    const auto &content_type =
    protocols::http::serialize_multipart_formdata_get_content_type(boundary);
    const auto &body = protocols::http::serialize_multipart_formdata(items, boundary);
    return Patch(path, headers, body, content_type, progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Patch(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, const std::string &boundary, UploadProgress progress) 
    {
        if (!protocols::http::is_multipart_boundary_chars_valid(boundary)) 
        {
            return protocols::http::Result{nullptr, Error::UnsupportedMultipartBoundaryChars};
        }

        const auto &content_type =
        protocols::http::serialize_multipart_formdata_get_content_type(boundary);
        const auto &body = protocols::http::serialize_multipart_formdata(items, boundary);
        return Patch(path, headers, body, content_type, progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Patch(const std::string &path, const protocols::http::Headers &headers,
    const char *body, size_t content_length,
    const std::string &content_type,
    UploadProgress progress) {
    return send_with_content_provider("PATCH", path, headers, body,
    content_length, nullptr, nullptr,
    content_type, progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Patch(const std::string &path, const protocols::http::Headers &headers,
    const std::string &body,
    const std::string &content_type,
    UploadProgress progress) {
    return send_with_content_provider("PATCH", path, headers, body.data(),
    body.size(), nullptr, nullptr, content_type,
    progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Patch(const std::string &path, const protocols::http::Headers &headers,
    size_t content_length,
    ContentProvider content_provider,
    const std::string &content_type,
    UploadProgress progress) {
    return send_with_content_provider("PATCH", path, headers, nullptr,
    content_length, std::move(content_provider),
    nullptr, content_type, progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Patch(const std::string &path, const protocols::http::Headers &headers,
    ContentProviderWithoutLength content_provider,
    const std::string &content_type,
    UploadProgress progress) {
    return send_with_content_provider("PATCH", path, headers, nullptr, 0, nullptr,
    std::move(content_provider), content_type,
    progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Patch(const std::string &path, const protocols::http::Headers &headers,
    const protocols::http::UploadFormDataItems &items,
    const protocols::http::FormDataProviderItems &provider_items,
    UploadProgress progress) {
    const auto &boundary = protocols::http::make_multipart_data_boundary();
    const auto &content_type =
    protocols::http::serialize_multipart_formdata_get_content_type(boundary);
    return send_with_content_provider(
    "PATCH", path, headers, nullptr, 0, nullptr,
    get_multipart_content_provider(boundary, items, provider_items),
    content_type, progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Patch(const std::string &path, const protocols::http::Headers &headers,
    const std::string &body,
    const std::string &content_type,
    ContentReceiver content_receiver,
    DownloadProgress progress) {
    protocols::http::Request req;
    req.method = "PATCH";
    req.path = path;
    req.headers = headers;
    req.body = body;
    req.content_receiver =
    [content_receiver](const char *data, size_t data_length,
    size_t /*offset*/, size_t /*total_length*/) {
    return content_receiver(data, data_length);
    };
    req.download_progress = std::move(progress);
    SetRequestTimeout(req);

    if (!content_type.empty()) { req.set_header("Content-Type", content_type); }

    return send_(std::move(req));
    }

    inline protocols::http::Result ProtoHTTPClient::Delete(const std::string &path,
    DownloadProgress progress) {
    return Delete(path,  protocols::http::Headers(), std::string(), std::string(), progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Delete(const std::string &path,
    const protocols::http::Headers &headers,
    DownloadProgress progress) {
    return Delete(path, headers, std::string(), std::string(), progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Delete(const std::string &path, const char *body,
    size_t content_length,
    const std::string &content_type,
    DownloadProgress progress) {
    return Delete(path, protocols::http::Headers(), body, content_length, content_type, progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Delete(const std::string &path,
    const std::string &body,
    const std::string &content_type,
    DownloadProgress progress) {
    return Delete(path, protocols::http::Headers(), body.data(), body.size(), content_type,
    progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Delete(const std::string &path,
    const protocols::http::Headers &headers,
    const std::string &body,
    const std::string &content_type,
    DownloadProgress progress) {
    return Delete(path, headers, body.data(), body.size(), content_type,
    progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Delete(const std::string &path, const Params &params,
    DownloadProgress progress) {
    return Delete(path, protocols::http::Headers(), params, progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Delete(const std::string &path,
    const protocols::http::Headers &headers, const Params &params,
    DownloadProgress progress) {
    auto query = params_to_query_str(params);
    return Delete(path, headers, query, "application/x-www-form-urlencoded",
    progress);
    }

    inline protocols::http::Result ProtoHTTPClient::Delete(const std::string &path,
    const protocols::http::Headers &headers, const char *body,
    size_t content_length,
    const std::string &content_type,
    DownloadProgress progress) {
    protocols::http::Request req;
    req.method = "DELETE";
    req.headers = headers;
    req.path = path;
    req.download_progress = std::move(progress);
    if (m_transport->GetMaxTimeout_msec() > 0) 
    {
        req.StartTimeout();
    }

    if (!content_type.empty()) { req.set_header("Content-Type", content_type); }
    req.body.assign(body, content_length);

    return send_(std::move(req));
    }

    inline protocols::http::Result ProtoHTTPClient::Options(const std::string &path) {
    return Options(path, protocols::http::Headers());
    }

    inline protocols::http::Result ProtoHTTPClient::Options(const std::string &path,
    const protocols::http::Headers &headers) {
    protocols::http::Request req;
    req.method = "OPTIONS";
    req.headers = headers;
    req.path = path;
    if (m_transport->GetMaxTimeout_msec() > 0) 
    {
        req.StartTimeout();
    }

    return send_(std::move(req));
    }

    ContentProviderWithoutLength ProtoHTTPClient::get_multipart_content_provider( const std::string &boundary, const protocols::http::UploadFormDataItems &items, const protocols::http::FormDataProviderItems &provider_items) const 
    {
        size_t cur_item = 0;
        size_t cur_start = 0;
        // cur_item and cur_start are copied to within the std::function and maintain
        // state between successive calls
        return [&, cur_item, cur_start](size_t offset, protocols::http::DataSink &sink) mutable -> bool 
        {
            if (!offset && !items.empty()) 
            {
                sink.os << protocols::http::serialize_multipart_formdata(items, boundary, false);
                return true;
            } 
            else if (cur_item < provider_items.size()) 
            {
                if (!cur_start) 
                {
                    const auto &begin = protocols::http::serialize_multipart_formdata_item_begin(provider_items[cur_item], boundary);
                    offset += begin.size();
                    cur_start = offset;
                    sink.os << begin;
                }

                protocols::http::DataSink cur_sink;
                auto has_data = true;
                cur_sink.write = sink.write;
                cur_sink.done = [&]() { has_data = false; };

                if (!provider_items[cur_item].provider(offset - cur_start, cur_sink)) 
                {
                    return false;
                }

                if (!has_data) 
                {
                    sink.os << protocols::http::serialize_multipart_formdata_item_end();
                    cur_item++;
                    cur_start = 0;
                }
                return true;
            } 
            else 
            {
                sink.os << protocols::http::serialize_multipart_formdata_finish(boundary);
                sink.done();
                return true;
            }
        };
    }

    bool ProtoHTTPClient::send(protocols::http::Request &req, protocols::http::Response &res, Error &error) 
    {
        std::lock_guard<std::recursive_mutex> request_mutex_guard(request_mutex_);
        auto ret = send_(req, res, error);
        if (error == Error::SSLPeerCouldBeClosed_) 
        {
            assert(!ret);
            ret = send_(req, res, error);
        }
        return ret;
    }

    bool ProtoHTTPClient::send_(protocols::http::Request &req, protocols::http::Response &res, Error &error)
    {
        if(m_transport->PrepareToSend())
        {
            request_writer.SetSink(m_transport->GetSink());
            request_writer.SetBuffer(m_transport->GetOutputBuffer());
            response_reader.SetBuffer(m_transport->GetInputBuffer());

            for (const auto &header : default_headers_) 
            {
                if (req.headers.find(header.first) == req.headers.end()) 
                {
                    req.headers.insert(header);
                }
            }

            auto ret = false;

            ret = m_transport->Process(req.GetStartTime(),[&](void* data) 
                {
                    return HandleRequest(data, req, res, /*close_connection*/true, error);
                });

            if (!ret) 
            {
                if (error == Error::Success) 
                {
                    error = Error::Unknown;
                    //output_error_log(error, &req);
                }
            }

            return ret;
        }
        return false;
    }

    protocols::http::Result ProtoHTTPClient::send(const protocols::http::Request &req) 
    {
        auto req2 = req;
        return send_(std::move(req2));
    }

    protocols::http::Result ProtoHTTPClient::send_(protocols::http::Request &&req) 
    {
        auto res = std::make_unique<protocols::http::Response>();
        auto error = Error::Success;
        auto ret = send(req, *res, error);
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
        return protocols::http::Result{ret ? std::move(res) : nullptr, error, std::move(req.headers), last_ssl_error_, last_openssl_error_};
#else
        return protocols::http::Result{ret ? std::move(res) : nullptr, error, std::move(req.headers)};
#endif
    }

    bool ProtoHTTPClient::HandleRequest(void* strm, protocols::http::Request &req, protocols::http::Response &res, bool close_connection, Error &error) 
    {
        if (req.path.empty()) 
        {
            error = Error::Connection;
            //output_error_log(error, &req);
            return false;
        }

        auto req_save = req;
        bool ret;

        /*TODO: Handle redirects
        if (!is_ssl() && !proxy_host_.empty() && proxy_port_ != -1) 
        {
            auto req2 = req;
            req2.path = "http://" + host_and_port_ + req.path;
            ret = process_request(strm, req2, res, close_connection, error);
            req = req2;
            req.path = req_save.path;
        } 
        else 
        {
            */
            ret = process_request(strm, req, res, close_connection, error);
        //}

        if (!ret) { return false; }

        if (res.get_header_value("Connection") == "close" || (res.version == "HTTP/1.0" && res.reason != "Connection established")) 
        {
            // TODO this requires a not-entirely-obvious chain of calls to be correct
            // for this to be safe.

            // This is safe to call because HandleRequest is only called by send_
            // which locks the request mutex during the process. It would be a bug
            // to call it from a different thread since it's a thread-safety issue
            // to do these things to the socket if another thread is using the socket.
            this->m_transport->Shutdown();
            /*
            std::lock_guard<std::mutex> guard(socket_mutex_);
            shutdown_ssl(socket_, true);
            shutdown_socket(socket_);
            close_socket(socket_);
            */
        }

        if (300 < res.status && res.status < 400 && m_transport->FollowLocation()) 
        {
            //TODO: Handle redirect
            //req = req_save;
            //ret = redirect(req, res, error);
        }

        return ret;
    }


    bool ProtoHTTPClient::PrepareRequest(protocols::http::Request &req, bool close_connection)
    {
        // Prepare additional headers
        if (close_connection) 
        {
            if (!req.has_header("Connection")) 
            {
                req.set_header("Connection", "close");
            }
        }

        if (!req.has_header("Host")) 
        {
            if(m_transport->IsUnixSocket())// For Unix socket connections, use "localhost" as Host header (similar to curl behavior)
            {
                req.set_header("Host", "localhost");
            } 
            else if (m_transport->IsSSL()) 
            {
                if (m_transport->Port() == 443) 
                {
                    req.set_header("Host", m_transport->GetHost());
                } 
                else 
                {
                    req.set_header("Host", m_transport->GetHostAndPort());
                }
            } 
            else 
            {
                if (m_transport->Port() == 80) 
                {
                    req.set_header("Host", m_transport->GetHost());
                } 
                else 
                {
                    req.set_header("Host", m_transport->GetHostAndPort());
                }
            }
        }

        if (!req.has_header("Accept")) { req.set_header("Accept", "*/*"); }

        if (!req.content_receiver) 
        {
            if (!req.has_header("Accept-Encoding")) 
            {
                std::string accept_encoding;
    #ifdef CPPHTTPLIB_BROTLI_SUPPORT
                accept_encoding = "br";
    #endif
    #ifdef CPPHTTPLIB_ZLIB_SUPPORT
                if (!accept_encoding.empty()) { accept_encoding += ", "; }
                accept_encoding += "gzip, deflate";
    #endif
    #ifdef CPPHTTPLIB_ZSTD_SUPPORT
                if (!accept_encoding.empty()) { accept_encoding += ", "; }
                accept_encoding += "zstd";
    #endif
                req.set_header("Accept-Encoding", accept_encoding);
            }

    #ifndef CPPHTTPLIB_NO_DEFAULT_USER_AGENT
            if (!req.has_header("User-Agent")) 
            {
                auto agent = std::string("cpp-httplib/") + CPPHTTPLIB_VERSION;
                req.set_header("User-Agent", agent);
            }
    #endif
        };

        if (req.body.empty()) 
        {
            if (req.GetContentProvider()) 
            {
                if (!req.IsChunkedContentProvider()) 
                {
                    if (!req.has_header("Content-Length")) 
                    {
                        auto length = std::to_string(req.GetContentLength());
                        req.set_header("Content-Length", length);
                    }
                }
            } 
            else 
            {
                if (req.method == "POST" || req.method == "PUT" || req.method == "PATCH") 
                {
                    req.set_header("Content-Length", "0");
                }
            }
        } 
        else 
        {
            if (!req.has_header("Content-Type")) 
            {
                req.set_header("Content-Type", "text/plain");
            }

            if (!req.has_header("Content-Length")) 
            {
                auto length = std::to_string(req.body.size());
                req.set_header("Content-Length", length);
            }
        }

        if (!basic_auth_password_.empty() || !basic_auth_username_.empty()) 
        {
            if (!req.has_header("Authorization")) 
            {
                req.headers.insert(make_basic_authentication_header(basic_auth_username_, basic_auth_password_, false));
            }
        }

        if (!proxy_basic_auth_username_.empty() && !proxy_basic_auth_password_.empty()) 
        {
            if (!req.has_header("Proxy-Authorization")) 
            {
                req.headers.insert(make_basic_authentication_header(proxy_basic_auth_username_, proxy_basic_auth_password_, true));
            }
        }

        if (!bearer_token_auth_token_.empty()) 
        {
            if (!req.has_header("Authorization")) 
            {
                req.headers.insert(make_bearer_token_authentication_header(bearer_token_auth_token_, false));
            }
        }

        if (!proxy_bearer_token_auth_token_.empty()) 
        {
            if (!req.has_header("Proxy-Authorization")) 
            {
                req.headers.insert(make_bearer_token_authentication_header(proxy_bearer_token_auth_token_, true));
            }
        }
        return true;
    }

    std::string ProtoHTTPClient::ExtractPathAndQuery(protocols::http::Request& req)
    {    
        std::string path_part, query_part;

        auto query_pos = req.path.find('?');
        if (query_pos != std::string::npos) 
        {
            path_part = req.path.substr(0, query_pos);
            query_part = req.path.substr(query_pos + 1);
        } 
        else 
        {
            path_part = req.path;
            query_part = "";
        }
        return EncodePathAndQuery(req, path_part, query_part);
    }

    std::string ProtoHTTPClient::EncodePathAndQuery(protocols::http::Request& req, const std::string& path_part, const std::string& query_part)
    {
        // Encode path and query
        auto path_with_query = path_encode_ ? encode_path(path_part) : path_part;

        parse_query_text(query_part, req.params);
        if (!req.params.empty()) 
        {
            path_with_query = append_query_params(path_with_query, req.params);
        }
        return path_with_query;
    }


    bool ProtoHTTPClient::ReadResponseLine(const protocols::http::Request &req, protocols::http::Response &res) const 
    {
        /*
        std::array<char, 2048> buf{};
        detail::stream_line_reader line_reader(strm, buf.data(), buf.size());

        if (!line_reader.getline()) 
        { 
            return false; 
        }

    #ifdef CPPHTTPLIB_ALLOW_LF_AS_LINE_TERMINATOR
        thread_local const std::regex re("(HTTP/1\\.[01]) (\\d{3})(?: (.*?))?\r?\n");
    #else
        thread_local const std::regex re("(HTTP/1\\.[01]) (\\d{3})(?: (.*?))?\r\n");
    #endif

        std::cmatch m;
        if (!std::regex_match(line_reader.ptr(), m, re)) 
        {
            return req.method == "CONNECT";
        }
        res.version = std::string(m[1]);
        res.status = std::stoi(std::string(m[2]));
        res.reason = std::string(m[3]);

        // Ignore '100 Continue'
        while (res.status == protocols::http::StatusCode::Continue_100) 
        {
            if (!line_reader.getline()) 
            { 
                return false; 
            } // CRLF
            if (!line_reader.getline()) 
            { 
                return false; 
            } // next response line

            if (!std::regex_match(line_reader.ptr(), m, re)) 
            { 
                return false; 
            }
            res.version = std::string(m[1]);
            res.status = std::stoi(std::string(m[2]));
            res.reason = std::string(m[3]);
        }
        */
        return true;
    }

    bool ProtoHTTPClient::process_request(void* strm, protocols::http::Request &req, protocols::http::Response &res, bool close_connection, Error &error)
    {
        if(!PrepareRequest(req, close_connection))
        {
            return false;
        }

        // Send request
        if (!request_writer.Write(req, ExtractPathAndQuery(req)))
        { 
            return false; 
        }

        if(!response_reader.Read(res))
        {
            return false;
        }
        /*TODO: Move to ResponseReader

        // Receive response and headers
        if (!read_response_line(strm, req, res) || !detail::read_headers(strm, res.headers)) 
        {
            error = Error::Read;
            //output_error_log(error, &req);
            return false;
        }

        // Body
        if ((res.status != protocols::http::StatusCode::NoContent_204) && req.method != "HEAD" && req.method != "CONNECT") 
        {
            auto redirect = 300 < res.status && res.status < 400 && res.status != protocols::http::StatusCode::NotModified_304 && m_transport->FollowLocation();

            if (req.response_handler && !redirect) 
            {
                if (!req.response_handler(res)) 
                {
                    error = Error::Canceled;
                    //output_error_log(error, &req);
                    return false;
                }
            }

            auto out = req.content_receiver ? static_cast<ContentReceiverWithProgress>(
            [&](const char *buf, size_t n, size_t off, size_t len) 
            {
                if (redirect) 
                { 
                    return true; 
                }
                auto ret = req.content_receiver(buf, n, off, len);
                if (!ret) 
                {
                    error = Error::Canceled;
                    //output_error_log(error, &req);
                }
                return ret;
            }) : static_cast<ContentReceiverWithProgress>(
            [&](const char *buf, size_t n, size_t , size_t ) 
            {
                assert(res.body.size() + n <= res.body.max_size());
                res.body.append(buf, n);
                return true;
            });

            auto progress = [&](size_t current, size_t total) 
            {
                if (!req.download_progress || redirect) 
                { 
                    return true; 
                }
                auto ret = req.download_progress(current, total);
                if (!ret) 
                {
                    error = Error::Canceled;
                    //output_error_log(error, &req);
                }
                return ret;
            };

            if (res.has_header("Content-Length")) 
            {
                if (!req.content_receiver) 
                {
                    auto len = res.get_header_value_u64("Content-Length");
                    if (len > res.body.max_size()) 
                    {
                        error = Error::Read;
                        //output_error_log(error, &req);
                        return false;
                    }
                    res.body.reserve(static_cast<size_t>(len));
                }
            }

            if (res.status != protocols::http::StatusCode::NotModified_304) 
            {
                int dummy_status;
                if (!detail::read_content(strm, res, (std::numeric_limits<size_t>::max)(), dummy_status, std::move(progress), std::move(out), decompress_)) 
                {
                    if (error != Error::Canceled) 
                    { 
                        error = Error::Read; 
                    }
                    //output_error_log(error, &req);
                    return false;
                }
            }
        }
        */
        // Log
        //output_log(req, res);

        return true;        
    }

}}}//qor::components::network

