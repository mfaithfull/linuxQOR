// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_COMPONENTS_NETWORK_CLIENTS_HTTP_CLIENTIMPL
#define QOR_PP_H_COMPONENTS_NETWORK_CLIENTS_HTTP_CLIENTIMPL

#include <string>
#include <chrono>
#include <functional>
#include <thread>
#include <mutex>

#include "src/components/protocols/http/result.h"
#include "src/components/protocols/http/response.h"
#include "src/components/protocols/http/headers.h"
#include "src/components/protocols/http/datasink.h"
#include "src/components/protocols/http/forms.h"
#include "src/components/protocols/http/request.h"

namespace qor{ namespace components{ namespace network{

    using DownloadProgress = std::function<bool(size_t current, size_t total)>;
    using UploadProgress = std::function<bool(size_t current, size_t total)>;
    using ContentReceiverWithProgress = std::function<bool(const char *data, size_t data_length, size_t offset, size_t total_length)>;
    using ContentReceiver = std::function<bool(const char *data, size_t data_length)>;
    using ResponseHandler = std::function<bool(const protocols::http::Response &response)>;
    using Params = std::multimap<std::string, std::string>;
    using ContentProvider = std::function<bool(size_t offset, size_t length,  protocols::http::DataSink &sink)>;
    using ContentProviderWithoutLength = std::function<bool(size_t offset,  protocols::http::DataSink &sink)>;

    class ClientImpl 
    {
    public:
        explicit ClientImpl(const std::string &host);
        explicit ClientImpl(const std::string &host, int port);
        explicit ClientImpl(const std::string &host, int port,
        const std::string &client_cert_path,
        const std::string &client_key_path);
        virtual ~ClientImpl();
        virtual bool is_valid() const;

        protocols::http::Result Get(const std::string &path, DownloadProgress progress = nullptr);
        protocols::http::Result Get(const std::string &path, ContentReceiver content_receiver, DownloadProgress progress = nullptr);
        protocols::http::Result Get(const std::string &path, ResponseHandler response_handler, ContentReceiver content_receiver, DownloadProgress progress = nullptr);
        protocols::http::Result Get(const std::string &path, const protocols::http::Headers &headers, DownloadProgress progress = nullptr);
        protocols::http::Result Get(const std::string &path, const protocols::http::Headers &headers, ContentReceiver content_receiver, DownloadProgress progress = nullptr);
        protocols::http::Result Get(const std::string &path, const protocols::http::Headers &headers, ResponseHandler response_handler, ContentReceiver content_receiver, DownloadProgress progress = nullptr);
        protocols::http::Result Get(const std::string &path, const Params &params, const protocols::http::Headers &headers, DownloadProgress progress = nullptr);
        protocols::http::Result Get(const std::string &path, const Params &params, const protocols::http::Headers &headers, ContentReceiver content_receiver, DownloadProgress progress = nullptr);
        protocols::http::Result Get(const std::string &path, const Params &params, const protocols::http::Headers &headers, ResponseHandler response_handler, ContentReceiver content_receiver, DownloadProgress progress = nullptr);

        protocols::http::Result Head(const std::string &path);
        protocols::http::Result Head(const std::string &path, const protocols::http::Headers &headers);

        protocols::http::Result Post(const std::string &path);
        protocols::http::Result Post(const std::string &path, const char *body, size_t content_length, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Post(const std::string &path, const std::string &body, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Post(const std::string &path, size_t content_length, ContentProvider content_provider, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Post(const std::string &path, ContentProviderWithoutLength content_provider, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Post(const std::string &path, const Params &params);
        protocols::http::Result Post(const std::string &path, const protocols::http::UploadFormDataItems &items, UploadProgress progress = nullptr);
        protocols::http::Result Post(const std::string &path, const protocols::http::Headers &headers);
        protocols::http::Result Post(const std::string &path, const protocols::http::Headers &headers, const char *body, size_t content_length, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Post(const std::string &path, const protocols::http::Headers &headers, const std::string &body, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Post(const std::string &path, const protocols::http::Headers &headers, size_t content_length, ContentProvider content_provider, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Post(const std::string &path, const protocols::http::Headers &headers, ContentProviderWithoutLength content_provider, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Post(const std::string &path, const protocols::http::Headers &headers, const Params &params);
        protocols::http::Result Post(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, UploadProgress progress = nullptr);
        protocols::http::Result Post(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, const std::string &boundary, UploadProgress progress = nullptr);
        protocols::http::Result Post(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, const protocols::http::FormDataProviderItems &provider_items, UploadProgress progress = nullptr);
        protocols::http::Result Post(const std::string &path, const protocols::http::Headers &headers, const std::string &body, const std::string &content_type, ContentReceiver content_receiver, DownloadProgress progress = nullptr);

        protocols::http::Result Put(const std::string &path);
        protocols::http::Result Put(const std::string &path, const char *body, size_t content_length, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Put(const std::string &path, const std::string &body, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Put(const std::string &path, size_t content_length, ContentProvider content_provider, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Put(const std::string &path, ContentProviderWithoutLength content_provider, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Put(const std::string &path, const Params &params);
        protocols::http::Result Put(const std::string &path, const protocols::http::UploadFormDataItems &items, UploadProgress progress = nullptr);
        protocols::http::Result Put(const std::string &path, const protocols::http::Headers &headers);
        protocols::http::Result Put(const std::string &path, const protocols::http::Headers &headers, const char *body, size_t content_length, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Put(const std::string &path, const protocols::http::Headers &headers, const std::string &body, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Put(const std::string &path, const protocols::http::Headers &headers, size_t content_length, ContentProvider content_provider, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Put(const std::string &path, const protocols::http::Headers &headers, ContentProviderWithoutLength content_provider, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Put(const std::string &path, const protocols::http::Headers &headers, const Params &params);
        protocols::http::Result Put(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, UploadProgress progress = nullptr);
        protocols::http::Result Put(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, const std::string &boundary, UploadProgress progress = nullptr);
        protocols::http::Result Put(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, const protocols::http::FormDataProviderItems &provider_items, UploadProgress progress = nullptr);
        protocols::http::Result Put(const std::string &path, const protocols::http::Headers &headers, const std::string &body, const std::string &content_type, ContentReceiver content_receiver, DownloadProgress progress = nullptr);

        protocols::http::Result Patch(const std::string &path);
        protocols::http::Result Patch(const std::string &path, const char *body, size_t content_length, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Patch(const std::string &path, const std::string &body, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Patch(const std::string &path, size_t content_length, ContentProvider content_provider, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Patch(const std::string &path, ContentProviderWithoutLength content_provider, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Patch(const std::string &path, const Params &params);
        protocols::http::Result Patch(const std::string &path, const protocols::http::UploadFormDataItems &items, UploadProgress progress = nullptr);
        protocols::http::Result Patch(const std::string &path, const protocols::http::Headers &headers, UploadProgress progress = nullptr);
        protocols::http::Result Patch(const std::string &path, const protocols::http::Headers &headers, const char *body, size_t content_length, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Patch(const std::string &path, const protocols::http::Headers &headers, const std::string &body, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Patch(const std::string &path, const protocols::http::Headers &headers, size_t content_length, ContentProvider content_provider, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Patch(const std::string &path, const protocols::http::Headers &headers, ContentProviderWithoutLength content_provider, const std::string &content_type, UploadProgress progress = nullptr);
        protocols::http::Result Patch(const std::string &path, const protocols::http::Headers &headers, const Params &params);
        protocols::http::Result Patch(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, UploadProgress progress = nullptr);
        protocols::http::Result Patch(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, const std::string &boundary, UploadProgress progress = nullptr);
        protocols::http::Result Patch(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, const protocols::http::FormDataProviderItems &provider_items, UploadProgress progress = nullptr);
        protocols::http::Result Patch(const std::string &path, const protocols::http::Headers &headers, const std::string &body, const std::string &content_type, ContentReceiver content_receiver, DownloadProgress progress = nullptr);

        protocols::http::Result Delete(const std::string &path, DownloadProgress progress = nullptr);
        protocols::http::Result Delete(const std::string &path, const char *body, size_t content_length, const std::string &content_type, DownloadProgress progress = nullptr);
        protocols::http::Result Delete(const std::string &path, const std::string &body, const std::string &content_type, DownloadProgress progress = nullptr);
        protocols::http::Result Delete(const std::string &path, const Params &params, DownloadProgress progress = nullptr);
        protocols::http::Result Delete(const std::string &path, const protocols::http::Headers &headers, DownloadProgress progress = nullptr);
        protocols::http::Result Delete(const std::string &path, const protocols::http::Headers &headers, const char *body, size_t content_length, const std::string &content_type, DownloadProgress progress = nullptr);
        protocols::http::Result Delete(const std::string &path, const protocols::http::Headers &headers, const std::string &body, const std::string &content_type, DownloadProgress progress = nullptr);
        protocols::http::Result Delete(const std::string &path, const protocols::http::Headers &headers, const Params &params, DownloadProgress progress = nullptr);

        protocols::http::Result Options(const std::string &path);
        protocols::http::Result Options(const std::string &path, const protocols::http::Headers &headers);

        bool send(protocols::http::Request &req, protocols::http::Response &res, Error &error);
        protocols::http::Result send(const protocols::http::Request &req);
        void stop();

        std::string host() const;
        int port() const;
        size_t is_socket_open() const;
        socket_t socket() const;

        void set_hostname_addr_map(std::map<std::string, std::string> addr_map);
        void set_default_headers(protocols::http::Headers headers);
        void set_header_writer(std::function<ssize_t(Stream &, protocols::http::Headers &)> const &writer);

        void set_address_family(int family);
        void set_tcp_nodelay(bool on);
        void set_ipv6_v6only(bool on);
        void set_socket_options(SocketOptions socket_options);

        void set_connection_timeout(time_t sec, time_t usec = 0);

        template <class Rep, class Period>
        void set_connection_timeout(const std::chrono::duration<Rep, Period> &duration);
        void set_read_timeout(time_t sec, time_t usec = 0);

        template <class Rep, class Period>
        void set_read_timeout(const std::chrono::duration<Rep, Period> &duration);

        void set_write_timeout(time_t sec, time_t usec = 0);

        template <class Rep, class Period>
        void set_write_timeout(const std::chrono::duration<Rep, Period> &duration);

        void set_max_timeout(time_t msec);

        template <class Rep, class Period>
        void set_max_timeout(const std::chrono::duration<Rep, Period> &duration);

        void set_basic_auth(const std::string &username, const std::string &password);
        void set_bearer_token_auth(const std::string &token);

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
        void set_digest_auth(const std::string &username,
        const std::string &password);
#endif

        void set_keep_alive(bool on);
        void set_follow_location(bool on);
        void set_path_encode(bool on);
        void set_compress(bool on);
        void set_decompress(bool on);
        void set_interface(const std::string &intf);
        void set_proxy(const std::string &host, int port);
        void set_proxy_basic_auth(const std::string &username, const std::string &password);
        void set_proxy_bearer_token_auth(const std::string &token);
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
        void set_proxy_digest_auth(const std::string &username,
        const std::string &password);
#endif

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
        void set_ca_cert_path(const std::string &ca_cert_file_path, const std::string &ca_cert_dir_path = std::string());
        void set_ca_cert_store(X509_STORE *ca_cert_store);
        X509_STORE *create_ca_cert_store(const char *ca_cert, std::size_t size) const;
#endif

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
        void enable_server_certificate_verification(bool enabled);
        void enable_server_hostname_verification(bool enabled);
        void set_server_certificate_verifier(
        std::function<SSLVerifierResponse(SSL *ssl)> verifier);
#endif

        void set_logger(Logger logger);
        void set_error_logger(ErrorLogger error_logger);

    protected:

        struct Socket {
            socket_t sock = INVALID_SOCKET;
            #ifdef CPPHTTPLIB_OPENSSL_SUPPORT
            SSL *ssl = nullptr;
            #endif

            bool is_open() const { return sock != INVALID_SOCKET; }
        };

        virtual bool create_and_connect_socket(Socket &socket, Error &error);

// All of:
//   shutdown_ssl
//   shutdown_socket
//   close_socket
// should ONLY be called when socket_mutex_ is locked.
// Also, shutdown_ssl and close_socket should also NOT be called concurrently
// with a DIFFERENT thread sending requests using that socket.
        virtual void shutdown_ssl(Socket &socket, bool shutdown_gracefully);
        void shutdown_socket(Socket &socket) const;
        void close_socket(Socket &socket);

        bool process_request(Stream &strm, protocols::http::Request &req, protocols::http::Response &res, bool close_connection, Error &error);
        bool write_content_with_provider(Stream &strm, const protocols::http::Request &req, Error &error) const;
        void copy_settings(const ClientImpl &rhs);
        void output_log(const protocols::http::Request &req, const protocols::http::Response &res) const;
        void output_error_log(const Error &err, const protocols::http::Request *req) const;

        // Socket endpoint information
        const std::string host_;
        const int port_;
        const std::string host_and_port_;

        // Current open socket
        Socket socket_;
        mutable std::mutex socket_mutex_;
        std::recursive_mutex request_mutex_;

        // These are all protected under socket_mutex
        size_t socket_requests_in_flight_ = 0;
        std::thread::id socket_requests_are_from_thread_ = std::thread::id();
        bool socket_should_be_closed_when_request_is_done_ = false;

        // Hostname-IP map
        std::map<std::string, std::string> addr_map_;

        // Default headers
        protocols::http::Headers default_headers_;

        // Header writer
        std::function<ssize_t(Stream &, protocols::http::Headers &)> header_writer_ = detail::write_headers;

        // Settings
        std::string client_cert_path_;
        std::string client_key_path_;

        time_t connection_timeout_sec_ = CPPHTTPLIB_CONNECTION_TIMEOUT_SECOND;
        time_t connection_timeout_usec_ = CPPHTTPLIB_CONNECTION_TIMEOUT_USECOND;
        time_t read_timeout_sec_ = CPPHTTPLIB_CLIENT_READ_TIMEOUT_SECOND;
        time_t read_timeout_usec_ = CPPHTTPLIB_CLIENT_READ_TIMEOUT_USECOND;
        time_t write_timeout_sec_ = CPPHTTPLIB_CLIENT_WRITE_TIMEOUT_SECOND;
        time_t write_timeout_usec_ = CPPHTTPLIB_CLIENT_WRITE_TIMEOUT_USECOND;
        time_t max_timeout_msec_ = CPPHTTPLIB_CLIENT_MAX_TIMEOUT_MSECOND;

        std::string basic_auth_username_;
        std::string basic_auth_password_;
        std::string bearer_token_auth_token_;
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
        std::string digest_auth_username_;
        std::string digest_auth_password_;
#endif

        bool keep_alive_ = false;
        bool follow_location_ = false;
        bool path_encode_ = true;
        int address_family_ = AF_UNSPEC;
        bool tcp_nodelay_ = CPPHTTPLIB_TCP_NODELAY;
        bool ipv6_v6only_ = CPPHTTPLIB_IPV6_V6ONLY;
        SocketOptions socket_options_ = nullptr;
        bool compress_ = false;
        bool decompress_ = true;
        std::string interface_;
        std::string proxy_host_;
        int proxy_port_ = -1;

        std::string proxy_basic_auth_username_;
        std::string proxy_basic_auth_password_;
        std::string proxy_bearer_token_auth_token_;
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
        std::string proxy_digest_auth_username_;
        std::string proxy_digest_auth_password_;
#endif

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
        std::string ca_cert_file_path_;
        std::string ca_cert_dir_path_;
        X509_STORE *ca_cert_store_ = nullptr;
#endif

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
        bool server_certificate_verification_ = true;
        bool server_hostname_verification_ = true;
        std::function<SSLVerifierResponse(SSL *ssl)> server_certificate_verifier_;
#endif

        mutable std::mutex logger_mutex_;
        Logger logger_;
        ErrorLogger error_logger_;

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
        int last_ssl_error_ = 0;
        unsigned long last_openssl_error_ = 0;
#endif

    private:
        bool send_(protocols::http::Request &req, protocols::http::Response &res, Error &error);
        protocols::http::Result send_(protocols::http::Request &&req);
        socket_t create_client_socket(Error &error) const;
        bool read_response_line(Stream &strm, const protocols::http::Request &req, protocols::http::Response &res) const;
        bool write_request(Stream &strm, protocols::http::Request &req, bool close_connection, Error &error);
        bool redirect(protocols::http::Request &req, protocols::http::Response &res, Error &error);
        bool create_redirect_client(const std::string &scheme, const std::string &host, int port, protocols::http::Request &req, protocols::http::Response &res, const std::string &path, const std::string &location, Error &error);

        template <typename ClientType> void setup_redirect_client(ClientType &client);

        bool handle_request(Stream &strm, protocols::http::Request &req, protocols::http::Response &res, bool close_connection, Error &error);
        std::unique_ptr<protocols::http::Response> send_with_content_provider( protocols::http::Request &req, const char *body, size_t content_length, ContentProvider content_provider, ContentProviderWithoutLength content_provider_without_length, const std::string &content_type, Error &error);
        protocols::http::Result send_with_content_provider( const std::string &method, const std::string &path, const protocols::http::Headers &headers, const char *body, size_t content_length, ContentProvider content_provider, ContentProviderWithoutLength content_provider_without_length, const std::string &content_type, UploadProgress progress);
        ContentProviderWithoutLength get_multipart_content_provider( const std::string &boundary, const protocols::http::UploadFormDataItems &items, const protocols::http::FormDataProviderItems &provider_items) const;
        std::string adjust_host_string(const std::string &host) const;
        virtual bool process_socket(const Socket &socket, std::chrono::time_point<std::chrono::steady_clock> start_time, std::function<bool(Stream &strm)> callback);
        virtual bool is_ssl() const;
    };

    template <class Rep, class Period>
    inline void ClientImpl::set_connection_timeout(const std::chrono::duration<Rep, Period> &duration) 
    {
        detail::duration_to_sec_and_usec(duration, [&](time_t sec, time_t usec) 
            {
                set_connection_timeout(sec, usec);
            });
    }

    template <class Rep, class Period>
    inline void ClientImpl::set_read_timeout(const std::chrono::duration<Rep, Period> &duration) 
    {
        detail::duration_to_sec_and_usec( duration, [&](time_t sec, time_t usec) 
            { 
                set_read_timeout(sec, usec); 
            });
    }

    template <class Rep, class Period>
    inline void ClientImpl::set_write_timeout(const std::chrono::duration<Rep, Period> &duration) 
    {
        detail::duration_to_sec_and_usec(duration, [&](time_t sec, time_t usec) 
            {
                set_write_timeout(sec, usec); 
            });
    }

    template <class Rep, class Period>
    inline void ClientImpl::set_max_timeout( const std::chrono::duration<Rep, Period> &duration) 
    {
        auto msec = std::chrono::duration_cast<std::chrono::milliseconds>(duration).count();
        set_max_timeout(msec);
    }

}}}//qor::components::network

#endif//QOR_PP_H_COMPONENTS_NETWORK_CLIENTS_HTTP_CLIENTIMPL
