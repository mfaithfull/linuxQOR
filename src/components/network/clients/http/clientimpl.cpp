// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include <assert.h>
#include "src/configuration/configuration.h"
#include "clientimpl.h"
#include "src/components/protocols/http/status.h"
#include "clientimpldetails.h"

namespace qor{ namespace components{ namespace network{
    
    // HTTP client implementation
    ClientImpl::ClientImpl(const std::string &host) : ClientImpl(host, 80, std::string(), std::string()) 
    {        
    }

    ClientImpl::ClientImpl(const std::string &host, int port) : ClientImpl(host, port, std::string(), std::string()) 
    {
    }

    inline ClientImpl::ClientImpl(const std::string &host, int port, const std::string &client_cert_path, const std::string &client_key_path) : host_(escape_abstract_namespace_unix_domain(host)), port_(port), host_and_port_(adjust_host_string(host_) + ":" + std::to_string(port)), client_cert_path_(client_cert_path), client_key_path_(client_key_path) 
    {
    }

    inline ClientImpl::~ClientImpl() 
    {
        // Wait until all the requests in flight are handled.
        size_t retry_count = 10;
        while (retry_count-- > 0) 
        {
            {
                std::lock_guard<std::mutex> guard(socket_mutex_);
                if (socket_requests_in_flight_ == 0) 
                { 
                    break; 
                }
            }
            std::this_thread::sleep_for(std::chrono::milliseconds{1});
        }

        std::lock_guard<std::mutex> guard(socket_mutex_);
        shutdown_socket(socket_);
        close_socket(socket_);
    }

    inline bool ClientImpl::is_valid() const 
    { 
        return true; 
    }

    inline void ClientImpl::copy_settings(const ClientImpl &rhs) 
    {
        client_cert_path_ = rhs.client_cert_path_;
        client_key_path_ = rhs.client_key_path_;
        connection_timeout_sec_ = rhs.connection_timeout_sec_;
        read_timeout_sec_ = rhs.read_timeout_sec_;
        read_timeout_usec_ = rhs.read_timeout_usec_;
        write_timeout_sec_ = rhs.write_timeout_sec_;
        write_timeout_usec_ = rhs.write_timeout_usec_;
        max_timeout_msec_ = rhs.max_timeout_msec_;
        basic_auth_username_ = rhs.basic_auth_username_;
        basic_auth_password_ = rhs.basic_auth_password_;
        bearer_token_auth_token_ = rhs.bearer_token_auth_token_;
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
        digest_auth_username_ = rhs.digest_auth_username_;
        digest_auth_password_ = rhs.digest_auth_password_;
#endif
        keep_alive_ = rhs.keep_alive_;
        follow_location_ = rhs.follow_location_;
        path_encode_ = rhs.path_encode_;
        address_family_ = rhs.address_family_;
        tcp_nodelay_ = rhs.tcp_nodelay_;
        ipv6_v6only_ = rhs.ipv6_v6only_;
        socket_options_ = rhs.socket_options_;
        compress_ = rhs.compress_;
        decompress_ = rhs.decompress_;
        interface_ = rhs.interface_;
        proxy_host_ = rhs.proxy_host_;
        proxy_port_ = rhs.proxy_port_;
        proxy_basic_auth_username_ = rhs.proxy_basic_auth_username_;
        proxy_basic_auth_password_ = rhs.proxy_basic_auth_password_;
        proxy_bearer_token_auth_token_ = rhs.proxy_bearer_token_auth_token_;
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
        proxy_digest_auth_username_ = rhs.proxy_digest_auth_username_;
        proxy_digest_auth_password_ = rhs.proxy_digest_auth_password_;
#endif
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
        ca_cert_file_path_ = rhs.ca_cert_file_path_;
        ca_cert_dir_path_ = rhs.ca_cert_dir_path_;
        ca_cert_store_ = rhs.ca_cert_store_;
#endif
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
        server_certificate_verification_ = rhs.server_certificate_verification_;
        server_hostname_verification_ = rhs.server_hostname_verification_;
        server_certificate_verifier_ = rhs.server_certificate_verifier_;
#endif
        logger_ = rhs.logger_;
        error_logger_ = rhs.error_logger_;
    }

    inline socket_t ClientImpl::create_client_socket(Error &error) const 
    {
        if (!proxy_host_.empty() && proxy_port_ != -1) 
        {
            return detail::create_client_socket( proxy_host_, std::string(), proxy_port_, address_family_, tcp_nodelay_, ipv6_v6only_, socket_options_, connection_timeout_sec_, connection_timeout_usec_, read_timeout_sec_, read_timeout_usec_, write_timeout_sec_, write_timeout_usec_, interface_, error);
        }

        // Check is custom IP specified for host_
        std::string ip;
        auto it = addr_map_.find(host_);
        if (it != addr_map_.end()) 
        { 
            ip = it->second; 
        }

        return detail::create_client_socket( host_, ip, port_, address_family_, tcp_nodelay_, ipv6_v6only_, socket_options_, connection_timeout_sec_, connection_timeout_usec_, read_timeout_sec_, read_timeout_usec_, write_timeout_sec_, write_timeout_usec_, interface_, error);
    }

    inline bool ClientImpl::create_and_connect_socket(Socket &socket, Error &error) 
    {
        auto sock = create_client_socket(error);
        if (sock == INVALID_SOCKET) 
        { 
            return false; 
        }
        socket.sock = sock;
        return true;
    }

    inline void ClientImpl::shutdown_ssl(Socket & /*socket*/, bool /*shutdown_gracefully*/) 
    {
        // If there are any requests in flight from threads other than us, then it's
        // a thread-unsafe race because individual ssl* objects are not thread-safe.
        assert(socket_requests_in_flight_ == 0 || socket_requests_are_from_thread_ == std::this_thread::get_id());
    }

    inline void ClientImpl::shutdown_socket(Socket &socket) const 
    {
        if (socket.sock == INVALID_SOCKET) 
        { 
            return; 
        }
        detail::shutdown_socket(socket.sock);
    }

    inline void ClientImpl::close_socket(Socket &socket) 
    {
        // If there are requests in flight in another thread, usually closing
        // the socket will be fine and they will simply receive an error when
        // using the closed socket, but it is still a bug since rarely the OS
        // may reassign the socket id to be used for a new socket, and then
        // suddenly they will be operating on a live socket that is different
        // than the one they intended!
        assert(socket_requests_in_flight_ == 0 || socket_requests_are_from_thread_ == std::this_thread::get_id());

        // It is also a bug if this happens while SSL is still active
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
        assert(socket.ssl == nullptr);
#endif
        if (socket.sock == INVALID_SOCKET) 
        { 
            return; 
        }
        detail::close_socket(socket.sock);
        socket.sock = INVALID_SOCKET;
    }

    inline bool ClientImpl::read_response_line(Stream &strm, const protocols::http::Request &req, protocols::http::Response &res) const 
    {
        std::array<char, 2048> buf{};

        detail::stream_line_reader line_reader(strm, buf.data(), buf.size());

        if (!line_reader.getline()) 
        { 
            return false; 
        }

#ifdef CPPHTTPLIB_ALLOW_LF_AS_LINE_TERMINATOR
        thread_local const std::regex re("(HTTP/1\\.[01]) (\\d{3})(?: (.*?))?\r?\n");
#else
        thread_local const std::regex re("(HTTP/1\\.[01]) (\\d{3})(?: (.*?))?\r\n");
#endif

        std::cmatch m;
        if (!std::regex_match(line_reader.ptr(), m, re)) 
        {
            return req.method == "CONNECT";
        }
        res.version = std::string(m[1]);
        res.status = std::stoi(std::string(m[2]));
        res.reason = std::string(m[3]);

        // Ignore '100 Continue'
        while (res.status == protocols::http::StatusCode::Continue_100) 
        {
            if (!line_reader.getline()) 
            { 
                return false; 
            } // CRLF

            if (!line_reader.getline()) 
            { 
                return false; 
            } // next response line

            if (!std::regex_match(line_reader.ptr(), m, re)) 
            { 
                return false; 
            }
            res.version = std::string(m[1]);
            res.status = std::stoi(std::string(m[2]));
            res.reason = std::string(m[3]);
        }

        return true;
    }

    inline bool ClientImpl::send(protocols::http::Request &req, protocols::http::Response &res, Error &error) 
    {
        std::lock_guard<std::recursive_mutex> request_mutex_guard(request_mutex_);
        auto ret = send_(req, res, error);
        if (error == Error::SSLPeerCouldBeClosed_) 
        {
            assert(!ret);
            ret = send_(req, res, error);
        }
        return ret;
    }

    inline bool ClientImpl::send_(protocols::http::Request &req, protocols::http::Response &res, Error &error) 
    {
        {
            std::lock_guard<std::mutex> guard(socket_mutex_);

            // Set this to false immediately - if it ever gets set to true by the end of
            // the request, we know another thread instructed us to close the socket.
            socket_should_be_closed_when_request_is_done_ = false;

            auto is_alive = false;
            if (socket_.is_open()) 
            {
                is_alive = detail::is_socket_alive(socket_.sock);

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
                if (is_alive && is_ssl()) 
                {
                    if (detail::is_ssl_peer_could_be_closed(socket_.ssl, socket_.sock)) 
                    {
                        is_alive = false;
                    }
                }
#endif

                if (!is_alive) 
                {
                    // Attempt to avoid sigpipe by shutting down non-gracefully if it seems
                    // like the other side has already closed the connection Also, there
                    // cannot be any requests in flight from other threads since we locked
                    // request_mutex_, so safe to close everything immediately
                    const bool shutdown_gracefully = false;
                    shutdown_ssl(socket_, shutdown_gracefully);
                    shutdown_socket(socket_);
                    close_socket(socket_);
                }
            }

            if (!is_alive) 
            {
                if (!create_and_connect_socket(socket_, error)) 
                {
                    output_error_log(error, &req);
                    return false;
                }

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
    // TODO: refactoring
    if (is_ssl()) {
    auto &scli = static_cast<SSLClient &>(*this);
    if (!proxy_host_.empty() && proxy_port_ != -1) {
    auto success = false;
    if (!scli.connect_with_proxy(socket_, req.start_time_, res, success,
    error)) {
    if (!success) { output_error_log(error, &req); }
    return success;
    }
    }

    if (!scli.initialize_ssl(socket_, error)) {
    output_error_log(error, &req);
    return false;
    }
    }
#endif
            }

            // Mark the current socket as being in use so that it cannot be closed by
            // anyone else while this request is ongoing, even though we will be
            // releasing the mutex.
            if (socket_requests_in_flight_ > 1) 
            {
                assert(socket_requests_are_from_thread_ == std::this_thread::get_id());
            }
            socket_requests_in_flight_ += 1;
            socket_requests_are_from_thread_ = std::this_thread::get_id();
        }

        for (const auto &header : default_headers_) 
        {
            if (req.headers.find(header.first) == req.headers.end()) 
            {
                req.headers.insert(header);
            }
        }

        auto ret = false;
        auto close_connection = !keep_alive_;

        auto se = detail::scope_exit([&]() 
            {
                // Briefly lock mutex in order to mark that a request is no longer ongoing
                std::lock_guard<std::mutex> guard(socket_mutex_);
                socket_requests_in_flight_ -= 1;
                if (socket_requests_in_flight_ <= 0) 
                {
                    assert(socket_requests_in_flight_ == 0);
                    socket_requests_are_from_thread_ = std::thread::id();
                }

                if (socket_should_be_closed_when_request_is_done_ || close_connection ||!ret) 
                {
                    shutdown_ssl(socket_, true);
                    shutdown_socket(socket_);
                    close_socket(socket_);
                }
            }
        );

        ret = process_socket(socket_, req.start_time_, [&](Stream &strm) 
            {
                return handle_request(strm, req, res, close_connection, error);
            }
        );

        if (!ret) 
        {
            if (error == Error::Success) 
            {
                error = Error::Unknown;
                output_error_log(error, &req);
            }
        }

        return ret;
    }

    inline protocols::http::Result ClientImpl::send(const protocols::http::Request &req) 
    {
        auto req2 = req;
        return send_(std::move(req2));
    }

    inline protocols::http::Result ClientImpl::send_(protocols::http::Request &&req) 
    {
        auto res = std::make_unique<protocols::http::Response>();
        auto error = Error::Success;
        auto ret = send(req, *res, error);
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
        return protocols::http::Result{ret ? std::move(res) : nullptr, error, std::move(req.headers), last_ssl_error_, last_openssl_error_};
#else
        return protocols::http::Result{ret ? std::move(res) : nullptr, error, std::move(req.headers)};
#endif
    }

    inline bool ClientImpl::handle_request(Stream &strm, protocols::http::Request &req, protocols::http::Response &res, bool close_connection, Error &error) 
    {
        if (req.path.empty()) 
        {
            error = Error::Connection;
            output_error_log(error, &req);
            return false;
        }

        auto req_save = req;
        bool ret;

        if (!is_ssl() && !proxy_host_.empty() && proxy_port_ != -1) 
        {
            auto req2 = req;
            req2.path = "http://" + host_and_port_ + req.path;
            ret = process_request(strm, req2, res, close_connection, error);
            req = req2;
            req.path = req_save.path;
        } 
        else 
        {
            ret = process_request(strm, req, res, close_connection, error);
        }

        if (!ret) { return false; }

        if (res.get_header_value("Connection") == "close" || res.version == "HTTP/1.0" && res.reason != "Connection established")) 
        {
            // TODO this requires a not-entirely-obvious chain of calls to be correct
            // for this to be safe.

            // This is safe to call because handle_request is only called by send_
            // which locks the request mutex during the process. It would be a bug
            // to call it from a different thread since it's a thread-safety issue
            // to do these things to the socket if another thread is using the socket.
            std::lock_guard<std::mutex> guard(socket_mutex_);
            shutdown_ssl(socket_, true);
            shutdown_socket(socket_);
            close_socket(socket_);
        }

        if (300 < res.status && res.status < 400 && follow_location_) 
        {
            req = req_save;
            ret = redirect(req, res, error);
        }

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
        if ((res.status == StatusCode::Unauthorized_401 ||
        res.status == StatusCode::ProxyAuthenticationRequired_407) &&
        req.authorization_count_ < 5) {
        auto is_proxy = res.status == StatusCode::ProxyAuthenticationRequired_407;
        const auto &username =
        is_proxy ? proxy_digest_auth_username_ : digest_auth_username_;
        const auto &password =
        is_proxy ? proxy_digest_auth_password_ : digest_auth_password_;

        if (!username.empty() && !password.empty()) {
        std::map<std::string, std::string> auth;
        if (detail::parse_www_authenticate(res, auth, is_proxy)) {
        Request new_req = req;
        new_req.authorization_count_ += 1;
        new_req.headers.erase(is_proxy ? "Proxy-Authorization"
        : "Authorization");
        new_req.headers.insert(detail::make_digest_authentication_header(
        req, auth, new_req.authorization_count_, detail::random_string(10),
        username, password, is_proxy));

        Response new_res;

        ret = send(new_req, new_res, error);
        if (ret) { res = new_res; }
        }
        }
        }
#endif

        return ret;
    }

    inline bool ClientImpl::redirect(protocols::http::Request &req, protocols::http::Response &res, Error &error) 
    {
        if (req.redirect_count_ == 0) 
        {
            error = Error::ExceedRedirectCount;
            output_error_log(error, &req);
            return false;
        }

        auto location = res.get_header_value("location");
        if (location.empty()) { return false; }

        thread_local const std::regex re(R"((?:(https?):)?(?://(?:\[([a-fA-F\d:]+)\]|([^:/?#]+))(?::(\d+))?)?([^?#]*)(\?[^#]*)?(?:#.*)?)");

        std::smatch m;
        if (!std::regex_match(location, m, re)) { return false; }

        auto scheme = is_ssl() ? "https" : "http";

        auto next_scheme = m[1].str();
        auto next_host = m[2].str();
        if (next_host.empty()) { next_host = m[3].str(); }
        auto port_str = m[4].str();
        auto next_path = m[5].str();
        auto next_query = m[6].str();

        auto next_port = port_;
        if (!port_str.empty()) 
        {
            next_port = std::stoi(port_str);
        } 
        else if (!next_scheme.empty()) 
        {
            next_port = next_scheme == "https" ? 443 : 80;
        }

        if (next_scheme.empty()) { next_scheme = scheme; }
        if (next_host.empty()) { next_host = host_; }
        if (next_path.empty()) { next_path = "/"; }

        auto path = decode_query_component(next_path, true) + next_query;

        // Same host redirect - use current client
        if (next_scheme == scheme && next_host == host_ && next_port == port_) 
        {
            return detail::redirect(*this, req, res, path, location, error);
        }

        // Cross-host/scheme redirect - create new client with robust setup
        return create_redirect_client(next_scheme, next_host, next_port, req, res, path, location, error);
    }

    // New method for robust redirect client creation
    inline bool ClientImpl::create_redirect_client( const std::string &scheme, const std::string &host, int port, protocols::http::Request &req, protocols::http::Response &res, const std::string &path, const std::string &location, Error &error) 
    {
        // Determine if we need SSL
        auto need_ssl = (scheme == "https");

        // Clean up request headers that are host/client specific
        // Remove headers that should not be carried over to new host
        auto headers_to_remove = std::vector<std::string>{"Host", "Proxy-Authorization", "Authorization"};

        for (const auto &header_name : headers_to_remove) 
        {
            auto it = req.headers.find(header_name);
            while (it != req.headers.end()) 
            {
                it = req.headers.erase(it);
                it = req.headers.find(header_name);
            }
        }

        // Create appropriate client type and handle redirect
        if (need_ssl) 
        {
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
        // Create SSL client for HTTPS redirect
        SSLClient redirect_client(host, port);

        // Setup basic client configuration first
        setup_redirect_client(redirect_client);

        // SSL-specific configuration for proxy environments
        if (!proxy_host_.empty() && proxy_port_ != -1) {
        // Critical: Disable SSL verification for proxy environments
        redirect_client.enable_server_certificate_verification(false);
        redirect_client.enable_server_hostname_verification(false);
        } else {
        // For direct SSL connections, copy SSL verification settings
        redirect_client.enable_server_certificate_verification(
        server_certificate_verification_);
        redirect_client.enable_server_hostname_verification(
        server_hostname_verification_);
        }

        // Handle CA certificate store and paths if available
        if (ca_cert_store_ && X509_STORE_up_ref(ca_cert_store_)) {
        redirect_client.set_ca_cert_store(ca_cert_store_);
        }
        if (!ca_cert_file_path_.empty()) {
        redirect_client.set_ca_cert_path(ca_cert_file_path_, ca_cert_dir_path_);
        }

        // Client certificates are set through constructor for SSLClient
        // NOTE: SSLClient constructor already takes client_cert_path and
        // client_key_path so we need to create it properly if client certs are
        // needed

        // Execute the redirect
        return detail::redirect(redirect_client, req, res, path, location, error);
#else
            // SSL not supported - set appropriate error
            error = Error::SSLConnection;
            output_error_log(error, &req);
            return false;
#endif
        } 
        else 
        {
            // HTTP redirect
            ClientImpl redirect_client(host, port);

            // Setup client with robust configuration
            setup_redirect_client(redirect_client);

            // Execute the redirect
            return detail::redirect(redirect_client, req, res, path, location, error);
        }
    }

    // New method for robust client setup (based on basic_manual_redirect.cpp logic)
    template <typename ClientType>
    inline void ClientImpl::setup_redirect_client(ClientType &client) 
    {
        // Copy basic settings first
        client.set_connection_timeout(connection_timeout_sec_);
        client.set_read_timeout(read_timeout_sec_, read_timeout_usec_);
        client.set_write_timeout(write_timeout_sec_, write_timeout_usec_);
        client.set_keep_alive(keep_alive_);
        client.set_follow_location(true); // Enable redirects to handle multi-step redirects
        client.set_path_encode(path_encode_);
        client.set_compress(compress_);
        client.set_decompress(decompress_);

        // Copy authentication settings BEFORE proxy setup
        if (!basic_auth_username_.empty()) 
        {
            client.set_basic_auth(basic_auth_username_, basic_auth_password_);
        }
        if (!bearer_token_auth_token_.empty()) 
        {
            client.set_bearer_token_auth(bearer_token_auth_token_);
        }
    #ifdef CPPHTTPLIB_OPENSSL_SUPPORT
        if (!digest_auth_username_.empty()) 
        {
            client.set_digest_auth(digest_auth_username_, digest_auth_password_);
        }
    #endif

        // Setup proxy configuration (CRITICAL ORDER - proxy must be set
        // before proxy auth)
        if (!proxy_host_.empty() && proxy_port_ != -1) 
        {
            // First set proxy host and port
            client.set_proxy(proxy_host_, proxy_port_);

            // Then set proxy authentication (order matters!)
            if (!proxy_basic_auth_username_.empty()) {
            client.set_proxy_basic_auth(proxy_basic_auth_username_,
            proxy_basic_auth_password_);
            }
            if (!proxy_bearer_token_auth_token_.empty()) {
            client.set_proxy_bearer_token_auth(proxy_bearer_token_auth_token_);
            }
    #ifdef CPPHTTPLIB_OPENSSL_SUPPORT
            if (!proxy_digest_auth_username_.empty()) 
            {
                client.set_proxy_digest_auth(proxy_digest_auth_username_,
                proxy_digest_auth_password_);
            }
    #endif
        }

        // Copy network and socket settings
        client.set_address_family(address_family_);
        client.set_tcp_nodelay(tcp_nodelay_);
        client.set_ipv6_v6only(ipv6_v6only_);
        if (socket_options_) { client.set_socket_options(socket_options_); }
        if (!interface_.empty()) { client.set_interface(interface_); }

        // Copy logging and headers
        if (logger_) { client.set_logger(logger_); }
        if (error_logger_) { client.set_error_logger(error_logger_); }

        // NOTE: DO NOT copy default_headers_ as they may contain stale Host headers
        // Each new client should generate its own headers based on its target host
    }

    inline bool ClientImpl::write_content_with_provider(Stream &strm, const protocols::http::Request &req, Error &error) const 
    {
    auto is_shutting_down = []() { return false; };

    if (req.is_chunked_content_provider_) 
    {
    // TODO: Brotli support
    std::unique_ptr<detail::compressor> compressor;
    #ifdef CPPHTTPLIB_ZLIB_SUPPORT
    if (compress_) {
    compressor = detail::make_unique<detail::gzip_compressor>();
    } else
    #endif
    {
    compressor = detail::make_unique<detail::nocompressor>();
    }

        return detail::write_content_chunked(strm, req.content_provider_, is_shutting_down, *compressor, error);
    } else {
    return detail::write_content_with_progress(
    strm, req.content_provider_, 0, req.content_length_, is_shutting_down,
    req.upload_progress, error);
    }
    }

    inline bool ClientImpl::write_request(Stream &strm, protocols::http::Request &req, bool close_connection, Error &error) 
    {
        // Prepare additional headers
        if (close_connection) 
        {
            if (!req.has_header("Connection")) 
            {
                req.set_header("Connection", "close");
            }
        }

        if (!req.has_header("Host")) 
        {
            // For Unix socket connections, use "localhost" as Host header (similar to curl behavior)
            if (address_family_ == AF_UNIX) 
            {
                req.set_header("Host", "localhost");
            } 
            else if (is_ssl()) 
            {
                if (port_ == 443) 
                {
                    req.set_header("Host", host_);
                } 
                else 
                {
                    req.set_header("Host", host_and_port_);
                }
            } 
            else 
            {
                if (port_ == 80) 
                {
                    req.set_header("Host", host_);
                } 
                else 
                {
                    req.set_header("Host", host_and_port_);
                }
            }
        }

        if (!req.has_header("Accept")) { req.set_header("Accept", "*/*"); }

        if (!req.content_receiver) 
        {
            if (!req.has_header("Accept-Encoding")) 
            {
                std::string accept_encoding;
    #ifdef CPPHTTPLIB_BROTLI_SUPPORT
                accept_encoding = "br";
    #endif
    #ifdef CPPHTTPLIB_ZLIB_SUPPORT
                if (!accept_encoding.empty()) { accept_encoding += ", "; }
                accept_encoding += "gzip, deflate";
    #endif
    #ifdef CPPHTTPLIB_ZSTD_SUPPORT
                if (!accept_encoding.empty()) { accept_encoding += ", "; }
                accept_encoding += "zstd";
    #endif
                req.set_header("Accept-Encoding", accept_encoding);
            }

    #ifndef CPPHTTPLIB_NO_DEFAULT_USER_AGENT
            if (!req.has_header("User-Agent")) 
            {
                auto agent = std::string("cpp-httplib/") + CPPHTTPLIB_VERSION;
                req.set_header("User-Agent", agent);
            }
    #endif
        };

        if (req.body.empty()) 
        {
            if (req.content_provider_) 
            {
                if (!req.is_chunked_content_provider_) 
                {
                    if (!req.has_header("Content-Length")) 
                    {
                        auto length = std::to_string(req.content_length_);
                        req.set_header("Content-Length", length);
                    }
                }
            } 
            else 
            {
                if (req.method == "POST" || req.method == "PUT" || req.method == "PATCH") 
                {
                    req.set_header("Content-Length", "0");
                }
            }
        } 
        else 
        {
            if (!req.has_header("Content-Type")) 
            {
                req.set_header("Content-Type", "text/plain");
            }

            if (!req.has_header("Content-Length")) 
            {
                auto length = std::to_string(req.body.size());
                req.set_header("Content-Length", length);
            }
        }

        if (!basic_auth_password_.empty() || !basic_auth_username_.empty()) 
        {
            if (!req.has_header("Authorization")) 
            {
                req.headers.insert(make_basic_authentication_header(basic_auth_username_, basic_auth_password_, false));
            }
        }

        if (!proxy_basic_auth_username_.empty() && !proxy_basic_auth_password_.empty()) 
        {
            if (!req.has_header("Proxy-Authorization")) 
            {
                req.headers.insert(make_basic_authentication_header(proxy_basic_auth_username_, proxy_basic_auth_password_, true));
            }
        }

        if (!bearer_token_auth_token_.empty()) 
        {
            if (!req.has_header("Authorization")) 
            {
                req.headers.insert(make_bearer_token_authentication_header(bearer_token_auth_token_, false));
            }
        }

        if (!proxy_bearer_token_auth_token_.empty()) 
        {
            if (!req.has_header("Proxy-Authorization")) 
            {
                req.headers.insert(make_bearer_token_authentication_header(proxy_bearer_token_auth_token_, true));
            }
        }

        // Request line and headers
        {
            detail::BufferStream bstrm;

            // Extract path and query from req.path
            std::string path_part, query_part;
            auto query_pos = req.path.find('?');
            if (query_pos != std::string::npos) 
            {
                path_part = req.path.substr(0, query_pos);
                query_part = req.path.substr(query_pos + 1);
            } 
            else 
            {
                path_part = req.path;
                query_part = "";
            }

            // Encode path and query
            auto path_with_query = path_encode_ ? detail::encode_path(path_part) : path_part;

            detail::parse_query_text(query_part, req.params);
            if (!req.params.empty()) 
            {
                path_with_query = append_query_params(path_with_query, req.params);
            }

            // Write request line and headers
            detail::write_request_line(bstrm, req.method, path_with_query);
            header_writer_(bstrm, req.headers);

            // Flush buffer
            auto &data = bstrm.get_buffer();
            if (!detail::write_data(strm, data.data(), data.size())) 
            {
                error = Error::Write;
                output_error_log(error, &req);
                return false;
            }
        }

        // Body
        if (req.body.empty()) 
        {
            return write_content_with_provider(strm, req, error);
        }

        if (req.upload_progress) 
        {
            auto body_size = req.body.size();
            size_t written = 0;
            auto data = req.body.data();

            while (written < body_size) 
            {
                size_t to_write = (std::min)(CPPHTTPLIB_SEND_BUFSIZ, body_size - written);
                if (!detail::write_data(strm, data + written, to_write)) 
                {
                    error = Error::Write;
                    output_error_log(error, &req);
                    return false;
                }
                written += to_write;

                if (!req.upload_progress(written, body_size)) 
                {
                    error = Error::Canceled;
                    output_error_log(error, &req);
                    return false;
                }
            }
        } 
        else 
        {
            if (!detail::write_data(strm, req.body.data(), req.body.size())) 
            {
                error = Error::Write;
                output_error_log(error, &req);
                return false;
            }
        }

        return true;
    }

    inline std::unique_ptr<protocols::http::Response> ClientImpl::send_with_content_provider( protocols::http::Request &req, const char *body, size_t content_length, ContentProvider content_provider, ContentProviderWithoutLength content_provider_without_length, const std::string &content_type, Error &error) 
    {
        if (!content_type.empty()) 
        { 
            req.set_header("Content-Type", content_type); 
        }

#ifdef CPPHTTPLIB_ZLIB_SUPPORT
        if (compress_) 
        { 
            req.set_header("Content-Encoding", "gzip"); 
        }
#endif

#ifdef CPPHTTPLIB_ZLIB_SUPPORT
        if (compress_ && !content_provider_without_length) 
        {
            // TODO: Brotli support
            detail::gzip_compressor compressor;

            if (content_provider) {
            auto ok = true;
            size_t offset = 0;
            DataSink data_sink;

            data_sink.write = [&](const char *data, size_t data_len) -> bool {
            if (ok) {
            auto last = offset + data_len == content_length;

            auto ret = compressor.compress(
            data, data_len, last,
            [&](const char *compressed_data, size_t compressed_data_len) {
            req.body.append(compressed_data, compressed_data_len);
            return true;
            });

            if (ret) {
            offset += data_len;
            } else {
            ok = false;
            }
            }
            return ok;
            };

            while (ok && offset < content_length) {
            if (!content_provider(offset, content_length - offset, data_sink)) {
            error = Error::Canceled;
            output_error_log(error, &req);
            return nullptr;
            }
            }
            } else {
            if (!compressor.compress(body, content_length, true,
            [&](const char *data, size_t data_len) {
            req.body.append(data, data_len);
            return true;
            })) {
            error = Error::Compression;
            output_error_log(error, &req);
            return nullptr;
            }
            }
        } else
#endif
        {
            if (content_provider) 
            {
                req.content_length_ = content_length;
                req.content_provider_ = std::move(content_provider);
                req.is_chunked_content_provider_ = false;
            } 
            else if (content_provider_without_length) 
            {
                req.content_length_ = 0;
                req.content_provider_ = detail::ContentProviderAdapter( std::move(content_provider_without_length));
                req.is_chunked_content_provider_ = true;
                req.set_header("Transfer-Encoding", "chunked");
            } 
            else 
            {
                req.body.assign(body, content_length);
            }
        }

        auto res = std::make_unique<protocols::http::Response>();
        return send(req, *res, error) ? std::move(res) : nullptr;
    }

    inline protocols::http::Result ClientImpl::send_with_content_provider(
    const std::string &method, const std::string &path, const protocols::http::Headers &headers,
    const char *body, size_t content_length, ContentProvider content_provider,
    ContentProviderWithoutLength content_provider_without_length,
    const std::string &content_type, UploadProgress progress) 
    {
    protocols::http::Request req;
    req.method = method;
    req.headers = headers;
    req.path = path;
    req.upload_progress = std::move(progress);
    if (max_timeout_msec_ > 0) {
    req.start_time_ = std::chrono::steady_clock::now();
    }

    auto error = Error::Success;

    auto res = send_with_content_provider(
    req, body, content_length, std::move(content_provider),
    std::move(content_provider_without_length), content_type, error);

    #ifdef CPPHTTPLIB_OPENSSL_SUPPORT
    return Result{std::move(res), error, std::move(req.headers), last_ssl_error_,
    last_openssl_error_};
    #else
    return protocols::http::Result{std::move(res), error, std::move(req.headers)};
    #endif
    }

    inline std::string ClientImpl::adjust_host_string(const std::string &host) const 
    {
        if (host.find(':') != std::string::npos) { return "[" + host + "]"; }
        return host;
    }

    inline void ClientImpl::output_log(const protocols::http::Request &req, const protocols::http::Response &res) const 
    {
        if (logger_) {
        std::lock_guard<std::mutex> guard(logger_mutex_);
        logger_(req, res);
        }
    }

    inline void ClientImpl::output_error_log(const Error &err, const protocols::http::Request *req) const 
    {
        if (error_logger_) {
        std::lock_guard<std::mutex> guard(logger_mutex_);
        error_logger_(err, req);
        }
    }

    inline bool ClientImpl::process_request(Stream &strm, protocols::http::Request &req, protocols::http::Response &res, bool close_connection, Error &error) 
    {
    // Send request
    if (!write_request(strm, req, close_connection, error)) { return false; }

    #ifdef CPPHTTPLIB_OPENSSL_SUPPORT
    if (is_ssl()) {
    auto is_proxy_enabled = !proxy_host_.empty() && proxy_port_ != -1;
    if (!is_proxy_enabled) {
    if (detail::is_ssl_peer_could_be_closed(socket_.ssl, socket_.sock)) {
    error = Error::SSLPeerCouldBeClosed_;
    output_error_log(error, &req);
    return false;
    }
    }
    }
    #endif

    // Receive response and headers
    if (!read_response_line(strm, req, res) ||
    !detail::read_headers(strm, res.headers)) {
    error = Error::Read;
    output_error_log(error, &req);
    return false;
    }

    // Body
    if ((res.status != protocols::http::StatusCode::NoContent_204) && req.method != "HEAD" && req.method != "CONNECT") 
    {
    auto redirect = 300 < res.status && res.status < 400 &&
    res.status != protocols::http::StatusCode::NotModified_304 &&
    follow_location_;

    if (req.response_handler && !redirect) {
    if (!req.response_handler(res)) {
    error = Error::Canceled;
    output_error_log(error, &req);
    return false;
    }
    }

    auto out =
    req.content_receiver
    ? static_cast<ContentReceiverWithProgress>(
    [&](const char *buf, size_t n, size_t off, size_t len) {
    if (redirect) { return true; }
    auto ret = req.content_receiver(buf, n, off, len);
    if (!ret) {
    error = Error::Canceled;
    output_error_log(error, &req);
    }
    return ret;
    })
    : static_cast<ContentReceiverWithProgress>(
    [&](const char *buf, size_t n, size_t /*off*/,
    size_t /*len*/) {
    assert(res.body.size() + n <= res.body.max_size());
    res.body.append(buf, n);
    return true;
    });

    auto progress = [&](size_t current, size_t total) {
    if (!req.download_progress || redirect) { return true; }
    auto ret = req.download_progress(current, total);
    if (!ret) {
    error = Error::Canceled;
    output_error_log(error, &req);
    }
    return ret;
    };

    if (res.has_header("Content-Length")) {
    if (!req.content_receiver) {
    auto len = res.get_header_value_u64("Content-Length");
    if (len > res.body.max_size()) {
    error = Error::Read;
    output_error_log(error, &req);
    return false;
    }
    res.body.reserve(static_cast<size_t>(len));
    }
    }

    if (res.status != protocols::http::StatusCode::NotModified_304) {
    int dummy_status;
    if (!detail::read_content(strm, res, (std::numeric_limits<size_t>::max)(),
    dummy_status, std::move(progress),
    std::move(out), decompress_)) {
    if (error != Error::Canceled) { error = Error::Read; }
    output_error_log(error, &req);
    return false;
    }
    }
    }

    // Log
    output_log(req, res);

    return true;
    }

    inline ContentProviderWithoutLength ClientImpl::get_multipart_content_provider( const std::string &boundary, const protocols::http::UploadFormDataItems &items, const protocols::http::FormDataProviderItems &provider_items) const 
    {
    size_t cur_item = 0;
    size_t cur_start = 0;
    // cur_item and cur_start are copied to within the std::function and maintain
    // state between successive calls
    return [&, cur_item, cur_start](size_t offset, protocols::http::DataSink &sink) mutable -> bool 
    {
    if (!offset && !items.empty()) {
    sink.os << detail::serialize_multipart_formdata(items, boundary, false);
    return true;
    } else if (cur_item < provider_items.size()) {
    if (!cur_start) {
    const auto &begin = detail::serialize_multipart_formdata_item_begin(
    provider_items[cur_item], boundary);
    offset += begin.size();
    cur_start = offset;
    sink.os << begin;
    }

    protocols::http::DataSink cur_sink;
    auto has_data = true;
    cur_sink.write = sink.write;
    cur_sink.done = [&]() { has_data = false; };

    if (!provider_items[cur_item].provider(offset - cur_start, cur_sink)) {
    return false;
    }

    if (!has_data) {
    sink.os << detail::serialize_multipart_formdata_item_end();
    cur_item++;
    cur_start = 0;
    }
    return true;
    } else {
    sink.os << detail::serialize_multipart_formdata_finish(boundary);
    sink.done();
    return true;
    }
    };
    }

    inline bool ClientImpl::process_socket( const Socket &socket, std::chrono::time_point<std::chrono::steady_clock> start_time, std::function<bool(Stream &strm)> callback) 
    {
        return detail::process_client_socket(socket.sock, read_timeout_sec_, read_timeout_usec_, write_timeout_sec_, write_timeout_usec_, max_timeout_msec_, start_time, std::move(callback));
    }

    inline bool ClientImpl::is_ssl() const { return false; }

    inline protocols::http::Result ClientImpl::Get(const std::string &path, DownloadProgress progress) 
    {
        return Get(path, protocols::http::Headers(), std::move(progress));
    }

    inline protocols::http::Result ClientImpl::Get(const std::string &path, const Params &params, const protocols::http::Headers &headers, DownloadProgress progress) 
    {
        if (params.empty()) { return Get(path, headers); }

        std::string path_with_query = append_query_params(path, params);
        return Get(path_with_query, headers, std::move(progress));
    }

    inline protocols::http::Result ClientImpl::Get(const std::string &path, const protocols::http::Headers &headers, DownloadProgress progress) 
    {
        protocols::http::Request req;
        req.method = "GET";
        req.path = path;
        req.headers = headers;
        req.download_progress = std::move(progress);
        if (max_timeout_msec_ > 0) 
        {
            req.start_time_ = std::chrono::steady_clock::now();
        }

        return send_(std::move(req));
    }

    inline protocols::http::Result ClientImpl::Get(const std::string &path, ContentReceiver content_receiver, DownloadProgress progress) 
    {
        return Get(path, protocols::http::Headers(), nullptr, std::move(content_receiver), std::move(progress));
    }

    inline protocols::http::Result ClientImpl::Get(const std::string &path, const protocols::http::Headers &headers, ContentReceiver content_receiver, DownloadProgress progress) 
    {
        return Get(path, headers, nullptr, std::move(content_receiver), std::move(progress));
    }

    inline protocols::http::Result ClientImpl::Get(const std::string &path, ResponseHandler response_handler, ContentReceiver content_receiver, DownloadProgress progress) 
    {
        return Get(path, protocols::http::Headers(), std::move(response_handler), std::move(content_receiver), std::move(progress));
    }

    inline protocols::http::Result ClientImpl::Get(const std::string &path, const protocols::http::Headers &headers, ResponseHandler response_handler, ContentReceiver content_receiver, DownloadProgress progress) 
    {
        protocols::http::Request req;
        req.method = "GET";
        req.path = path;
        req.headers = headers;
        req.response_handler = std::move(response_handler);
        req.content_receiver =
        [content_receiver](const char *data, size_t data_length,
        size_t /*offset*/, size_t /*total_length*/) 
        {
            return content_receiver(data, data_length);
        };
        req.download_progress = std::move(progress);
        if (max_timeout_msec_ > 0) {
            req.start_time_ = std::chrono::steady_clock::now();
        }

        return send_(std::move(req));
    }

    inline protocols::http::Result ClientImpl::Get(const std::string &path, const Params &params, const protocols::http::Headers &headers, ContentReceiver content_receiver, DownloadProgress progress) 
    {
        return Get(path, params, headers, nullptr, std::move(content_receiver), std::move(progress));
    }

    inline protocols::http::Result ClientImpl::Get(const std::string &path, const Params &params, const protocols::http::Headers &headers, ResponseHandler response_handler, ContentReceiver content_receiver, DownloadProgress progress) 
    {
        if (params.empty()) 
        {
            return Get(path, headers, std::move(response_handler),
            std::move(content_receiver), std::move(progress));
        }

        std::string path_with_query = append_query_params(path, params);
        return Get(path_with_query, headers, std::move(response_handler), std::move(content_receiver), std::move(progress));
    }

    inline protocols::http::Result ClientImpl::Head(const std::string &path) 
    {
        return Head(path, protocols::http::Headers());
    }

    inline protocols::http::Result ClientImpl::Head(const std::string &path, const protocols::http::Headers &headers) 
    {
        protocols::http::Request req;
        req.method = "HEAD";
        req.headers = headers;
        req.path = path;
        if (max_timeout_msec_ > 0) 
        {
            req.start_time_ = std::chrono::steady_clock::now();
        }

        return send_(std::move(req));
    }

    inline protocols::http::Result ClientImpl::Post(const std::string &path) 
    {
        return Post(path, std::string(), std::string());
    }

    inline protocols::http::Result ClientImpl::Post(const std::string &path, const protocols::http::Headers &headers) 
    {
        return Post(path, headers, nullptr, 0, std::string());
    }

    inline protocols::http::Result ClientImpl::Post(const std::string &path, const char *body, size_t content_length, const std::string &content_type, UploadProgress progress) 
    {
        return Post(path, protocols::http::Headers(), body, content_length, content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Post(const std::string &path, const std::string &body, const std::string &content_type, UploadProgress progress) 
    {
        return Post(path, protocols::http::Headers(), body, content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Post(const std::string &path, const Params &params) 
    {
        return Post(path, protocols::http::Headers(), params);
    }

    inline protocols::http::Result ClientImpl::Post(const std::string &path, size_t content_length, ContentProvider content_provider, const std::string &content_type, UploadProgress progress) 
    {
        return Post(path, protocols::http::Headers(), content_length, std::move(content_provider), content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Post(const std::string &path, ContentProviderWithoutLength content_provider, const std::string &content_type, UploadProgress progress) 
    {
        return Post(path, protocols::http::Headers(), std::move(content_provider), content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Post(const std::string &path, const protocols::http::Headers &headers, const Params &params) 
    {
        auto query = detail::params_to_query_str(params);
        return Post(path, headers, query, "application/x-www-form-urlencoded");
    }

    inline protocols::http::Result ClientImpl::Post(const std::string &path, const protocols::http::UploadFormDataItems &items, UploadProgress progress) 
    {
        return Post(path, protocols::http::Headers(), items, progress);
    }

    inline protocols::http::Result ClientImpl::Post(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, UploadProgress progress) 
    {
        const auto &boundary = detail::make_multipart_data_boundary();
        const auto &content_type = detail::serialize_multipart_formdata_get_content_type(boundary);
        const auto &body = detail::serialize_multipart_formdata(items, boundary);
        return Post(path, headers, body, content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Post(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, const std::string &boundary, UploadProgress progress) 
    {
        if (!detail::is_multipart_boundary_chars_valid(boundary)) 
        {
            return protocols::http::Result{nullptr, Error::UnsupportedMultipartBoundaryChars};
        }

        const auto &content_type = detail::serialize_multipart_formdata_get_content_type(boundary);
        const auto &body = detail::serialize_multipart_formdata(items, boundary);
        return Post(path, headers, body, content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Post(const std::string &path, const protocols::http::Headers &headers, const char *body, size_t content_length, const std::string &content_type, UploadProgress progress) 
    {
        return send_with_content_provider("POST", path, headers, body, content_length, nullptr, nullptr, content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Post(const std::string &path, const protocols::http::Headers &headers, const std::string &body, const std::string &content_type, UploadProgress progress) 
    {
        return send_with_content_provider("POST", path, headers, body.data(), body.size(), nullptr, nullptr, content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Post(const std::string &path, const protocols::http::Headers &headers, size_t content_length, ContentProvider content_provider, const std::string &content_type, UploadProgress progress) 
    {
        return send_with_content_provider("POST", path, headers, nullptr, content_length, std::move(content_provider), nullptr, content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Post(const std::string &path, const protocols::http::Headers &headers, ContentProviderWithoutLength content_provider, const std::string &content_type, UploadProgress progress) 
    {
        return send_with_content_provider("POST", path, headers, nullptr, 0, nullptr, std::move(content_provider), content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Post(const std::string &path, const protocols::http::Headers &headers, const protocols::http::UploadFormDataItems &items, const protocols::http::FormDataProviderItems &provider_items, UploadProgress progress) 
    {
        const auto &boundary = detail::make_multipart_data_boundary();
        const auto &content_type = detail::serialize_multipart_formdata_get_content_type(boundary);
        return send_with_content_provider("POST", path, headers, nullptr, 0, nullptr, get_multipart_content_provider(boundary, items, provider_items), content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Post(const std::string &path, const protocols::http::Headers &headers, const std::string &body, const std::string &content_type, ContentReceiver content_receiver, DownloadProgress progress) 
    {
        protocols::http::Request req;
        req.method = "POST";
        req.path = path;
        req.headers = headers;
        req.body = body;
        req.content_receiver =
        [content_receiver](const char *data, size_t data_length,
        size_t /*offset*/, size_t /*total_length*/) {
        return content_receiver(data, data_length);
        };
        req.download_progress = std::move(progress);

        if (max_timeout_msec_ > 0) {
        req.start_time_ = std::chrono::steady_clock::now();
        }

        if (!content_type.empty()) { req.set_header("Content-Type", content_type); }

        return send_(std::move(req));
    }

    inline protocols::http::Result ClientImpl::Put(const std::string &path) 
    {
        return Put(path, std::string(), std::string());
    }

    inline protocols::http::Result ClientImpl::Put(const std::string &path, const protocols::http::Headers &headers) 
    {
        return Put(path, headers, nullptr, 0, std::string());
    }

    inline protocols::http::Result ClientImpl::Put(const std::string &path, const char *body, size_t content_length, const std::string &content_type, UploadProgress progress) 
    {
        return Put(path, protocols::http::Headers(), body, content_length, content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Put(const std::string &path, const std::string &body, const std::string &content_type, UploadProgress progress) 
    {
        return Put(path, protocols::http::Headers(), body, content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Put(const std::string &path, const Params &params) 
    {
        return Put(path, protocols::http::Headers(), params);
    }

    inline protocols::http::Result ClientImpl::Put(const std::string &path, size_t content_length,
    ContentProvider content_provider,
    const std::string &content_type,
    UploadProgress progress) {
    return Put(path, protocols::http::Headers(), content_length, std::move(content_provider),
    content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Put(const std::string &path,
    ContentProviderWithoutLength content_provider,
    const std::string &content_type,
    UploadProgress progress) {
    return Put(path, protocols::http::Headers(), std::move(content_provider), content_type,
    progress);
    }

    inline protocols::http::Result ClientImpl::Put(const std::string &path, const protocols::http::Headers &headers,
    const Params &params) {
    auto query = detail::params_to_query_str(params);
    return Put(path, headers, query, "application/x-www-form-urlencoded");
    }

    inline protocols::http::Result ClientImpl::Put(const std::string &path,
    const protocols::http::UploadFormDataItems &items,
    UploadProgress progress) {
    return Put(path, protocols::http::Headers(), items, progress);
    }

    inline protocols::http::Result ClientImpl::Put(const std::string &path, const protocols::http::Headers &headers,
    const protocols::http::UploadFormDataItems &items, UploadProgress progress) {
    const auto &boundary = detail::make_multipart_data_boundary();
    const auto &content_type =
    detail::serialize_multipart_formdata_get_content_type(boundary);
    const auto &body = detail::serialize_multipart_formdata(items, boundary);
    return Put(path, headers, body, content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Put(const std::string &path, const protocols::http::Headers &headers,
    const protocols::http::UploadFormDataItems &items,
    const std::string &boundary,
    UploadProgress progress) {
    if (!detail::is_multipart_boundary_chars_valid(boundary)) {
    return protocols::http::Result{nullptr, Error::UnsupportedMultipartBoundaryChars};
    }

    const auto &content_type =
    detail::serialize_multipart_formdata_get_content_type(boundary);
    const auto &body = detail::serialize_multipart_formdata(items, boundary);
    return Put(path, headers, body, content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Put(const std::string &path, const protocols::http::Headers &headers,
    const char *body, size_t content_length,
    const std::string &content_type,
    UploadProgress progress) {
    return send_with_content_provider("PUT", path, headers, body, content_length,
    nullptr, nullptr, content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Put(const std::string &path, const protocols::http::Headers &headers,
    const std::string &body,
    const std::string &content_type,
    UploadProgress progress) {
    return send_with_content_provider("PUT", path, headers, body.data(),
    body.size(), nullptr, nullptr, content_type,
    progress);
    }

    inline protocols::http::Result ClientImpl::Put(const std::string &path, const protocols::http::Headers &headers,
    size_t content_length,
    ContentProvider content_provider,
    const std::string &content_type,
    UploadProgress progress) {
    return send_with_content_provider("PUT", path, headers, nullptr,
    content_length, std::move(content_provider),
    nullptr, content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Put(const std::string &path, const protocols::http::Headers &headers,
    ContentProviderWithoutLength content_provider,
    const std::string &content_type,
    UploadProgress progress) {
    return send_with_content_provider("PUT", path, headers, nullptr, 0, nullptr,
    std::move(content_provider), content_type,
    progress);
    }

    inline protocols::http::Result ClientImpl::Put(const std::string &path, const protocols::http::Headers &headers,
    const protocols::http::UploadFormDataItems &items,
    const protocols::http::FormDataProviderItems &provider_items,
    UploadProgress progress) {
    const auto &boundary = detail::make_multipart_data_boundary();
    const auto &content_type =
    detail::serialize_multipart_formdata_get_content_type(boundary);
    return send_with_content_provider(
    "PUT", path, headers, nullptr, 0, nullptr,
    get_multipart_content_provider(boundary, items, provider_items),
    content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Put(const std::string &path, const protocols::http::Headers &headers,
    const std::string &body,
    const std::string &content_type,
    ContentReceiver content_receiver,
    DownloadProgress progress) {
    protocols::http::Request req;
    req.method = "PUT";
    req.path = path;
    req.headers = headers;
    req.body = body;
    req.content_receiver =
    [content_receiver](const char *data, size_t data_length,
    size_t /*offset*/, size_t /*total_length*/) {
    return content_receiver(data, data_length);
    };
    req.download_progress = std::move(progress);

    if (max_timeout_msec_ > 0) {
    req.start_time_ = std::chrono::steady_clock::now();
    }

    if (!content_type.empty()) { req.set_header("Content-Type", content_type); }

    return send_(std::move(req));
    }

    inline protocols::http::Result ClientImpl::Patch(const std::string &path) {
    return Patch(path, std::string(), std::string());
    }

    inline protocols::http::Result ClientImpl::Patch(const std::string &path, const protocols::http::Headers &headers,
    UploadProgress progress) {
    return Patch(path, headers, nullptr, 0, std::string(), progress);
    }

    inline protocols::http::Result ClientImpl::Patch(const std::string &path, const char *body,
    size_t content_length,
    const std::string &content_type,
    UploadProgress progress) {
    return Patch(path, protocols::http::Headers(), body, content_length, content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Patch(const std::string &path,
    const std::string &body,
    const std::string &content_type,
    UploadProgress progress) {
    return Patch(path, protocols::http::Headers(), body, content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Patch(const std::string &path, const Params &params) {
    return Patch(path, protocols::http::Headers(), params);
    }

    inline protocols::http::Result ClientImpl::Patch(const std::string &path, size_t content_length,
    ContentProvider content_provider,
    const std::string &content_type,
    UploadProgress progress) {
    return Patch(path, protocols::http::Headers(), content_length, std::move(content_provider),
    content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Patch(const std::string &path,
    ContentProviderWithoutLength content_provider,
    const std::string &content_type,
    UploadProgress progress) {
    return Patch(path, protocols::http::Headers(), std::move(content_provider), content_type,
    progress);
    }

    inline protocols::http::Result ClientImpl::Patch(const std::string &path, const protocols::http::Headers &headers,
    const Params &params) {
    auto query = detail::params_to_query_str(params);
    return Patch(path, headers, query, "application/x-www-form-urlencoded");
    }

    inline protocols::http::Result ClientImpl::Patch(const std::string &path,
    const protocols::http::UploadFormDataItems &items,
    UploadProgress progress) {
    return Patch(path, protocols::http::Headers(), items, progress);
    }

    inline protocols::http::Result ClientImpl::Patch(const std::string &path, const protocols::http::Headers &headers,
    const protocols::http::UploadFormDataItems &items,
    UploadProgress progress) {
    const auto &boundary = detail::make_multipart_data_boundary();
    const auto &content_type =
    detail::serialize_multipart_formdata_get_content_type(boundary);
    const auto &body = detail::serialize_multipart_formdata(items, boundary);
    return Patch(path, headers, body, content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Patch(const std::string &path, const protocols::http::Headers &headers,
    const protocols::http::UploadFormDataItems &items,
    const std::string &boundary,
    UploadProgress progress) {
    if (!detail::is_multipart_boundary_chars_valid(boundary)) {
    return protocols::http::Result{nullptr, Error::UnsupportedMultipartBoundaryChars};
    }

    const auto &content_type =
    detail::serialize_multipart_formdata_get_content_type(boundary);
    const auto &body = detail::serialize_multipart_formdata(items, boundary);
    return Patch(path, headers, body, content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Patch(const std::string &path, const protocols::http::Headers &headers,
    const char *body, size_t content_length,
    const std::string &content_type,
    UploadProgress progress) {
    return send_with_content_provider("PATCH", path, headers, body,
    content_length, nullptr, nullptr,
    content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Patch(const std::string &path, const protocols::http::Headers &headers,
    const std::string &body,
    const std::string &content_type,
    UploadProgress progress) {
    return send_with_content_provider("PATCH", path, headers, body.data(),
    body.size(), nullptr, nullptr, content_type,
    progress);
    }

    inline protocols::http::Result ClientImpl::Patch(const std::string &path, const protocols::http::Headers &headers,
    size_t content_length,
    ContentProvider content_provider,
    const std::string &content_type,
    UploadProgress progress) {
    return send_with_content_provider("PATCH", path, headers, nullptr,
    content_length, std::move(content_provider),
    nullptr, content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Patch(const std::string &path, const protocols::http::Headers &headers,
    ContentProviderWithoutLength content_provider,
    const std::string &content_type,
    UploadProgress progress) {
    return send_with_content_provider("PATCH", path, headers, nullptr, 0, nullptr,
    std::move(content_provider), content_type,
    progress);
    }

    inline protocols::http::Result ClientImpl::Patch(const std::string &path, const protocols::http::Headers &headers,
    const protocols::http::UploadFormDataItems &items,
    const protocols::http::FormDataProviderItems &provider_items,
    UploadProgress progress) {
    const auto &boundary = detail::make_multipart_data_boundary();
    const auto &content_type =
    detail::serialize_multipart_formdata_get_content_type(boundary);
    return send_with_content_provider(
    "PATCH", path, headers, nullptr, 0, nullptr,
    get_multipart_content_provider(boundary, items, provider_items),
    content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Patch(const std::string &path, const protocols::http::Headers &headers,
    const std::string &body,
    const std::string &content_type,
    ContentReceiver content_receiver,
    DownloadProgress progress) {
    protocols::http::Request req;
    req.method = "PATCH";
    req.path = path;
    req.headers = headers;
    req.body = body;
    req.content_receiver =
    [content_receiver](const char *data, size_t data_length,
    size_t /*offset*/, size_t /*total_length*/) {
    return content_receiver(data, data_length);
    };
    req.download_progress = std::move(progress);

    if (max_timeout_msec_ > 0) {
    req.start_time_ = std::chrono::steady_clock::now();
    }

    if (!content_type.empty()) { req.set_header("Content-Type", content_type); }

    return send_(std::move(req));
    }

    inline protocols::http::Result ClientImpl::Delete(const std::string &path,
    DownloadProgress progress) {
    return Delete(path, Headers(), std::string(), std::string(), progress);
    }

    inline protocols::http::Result ClientImpl::Delete(const std::string &path,
    const protocols::http::Headers &headers,
    DownloadProgress progress) {
    return Delete(path, headers, std::string(), std::string(), progress);
    }

    inline protocols::http::Result ClientImpl::Delete(const std::string &path, const char *body,
    size_t content_length,
    const std::string &content_type,
    DownloadProgress progress) {
    return Delete(path, protocols::http::Headers(), body, content_length, content_type, progress);
    }

    inline protocols::http::Result ClientImpl::Delete(const std::string &path,
    const std::string &body,
    const std::string &content_type,
    DownloadProgress progress) {
    return Delete(path, protocols::http::Headers(), body.data(), body.size(), content_type,
    progress);
    }

    inline protocols::http::Result ClientImpl::Delete(const std::string &path,
    const protocols::http::Headers &headers,
    const std::string &body,
    const std::string &content_type,
    DownloadProgress progress) {
    return Delete(path, headers, body.data(), body.size(), content_type,
    progress);
    }

    inline protocols::http::Result ClientImpl::Delete(const std::string &path, const Params &params,
    DownloadProgress progress) {
    return Delete(path, Headers(), params, progress);
    }

    inline protocols::http::Result ClientImpl::Delete(const std::string &path,
    const protocols::http::Headers &headers, const Params &params,
    DownloadProgress progress) {
    auto query = detail::params_to_query_str(params);
    return Delete(path, headers, query, "application/x-www-form-urlencoded",
    progress);
    }

    inline protocols::http::Result ClientImpl::Delete(const std::string &path,
    const protocols::http::Headers &headers, const char *body,
    size_t content_length,
    const std::string &content_type,
    DownloadProgress progress) {
    protocols::http::Request req;
    req.method = "DELETE";
    req.headers = headers;
    req.path = path;
    req.download_progress = std::move(progress);
    if (max_timeout_msec_ > 0) {
    req.start_time_ = std::chrono::steady_clock::now();
    }

    if (!content_type.empty()) { req.set_header("Content-Type", content_type); }
    req.body.assign(body, content_length);

    return send_(std::move(req));
    }

    inline protocols::http::Result ClientImpl::Options(const std::string &path) {
    return Options(path, protocols::http::Headers());
    }

    inline protocols::http::Result ClientImpl::Options(const std::string &path,
    const protocols::http::Headers &headers) {
    protocols::http::Request req;
    req.method = "OPTIONS";
    req.headers = headers;
    req.path = path;
    if (max_timeout_msec_ > 0) {
    req.start_time_ = std::chrono::steady_clock::now();
    }

    return send_(std::move(req));
    }

    inline void ClientImpl::stop() {
    std::lock_guard<std::mutex> guard(socket_mutex_);

    // If there is anything ongoing right now, the ONLY thread-safe thing we can
    // do is to shutdown_socket, so that threads using this socket suddenly
    // discover they can't read/write any more and error out. Everything else
    // (closing the socket, shutting ssl down) is unsafe because these actions are
    // not thread-safe.
    if (socket_requests_in_flight_ > 0) {
    shutdown_socket(socket_);

    // Aside from that, we set a flag for the socket to be closed when we're
    // done.
    socket_should_be_closed_when_request_is_done_ = true;
    return;
    }

    // Otherwise, still holding the mutex, we can shut everything down ourselves
    shutdown_ssl(socket_, true);
    shutdown_socket(socket_);
    close_socket(socket_);
    }

    inline std::string ClientImpl::host() const { return host_; }

    inline int ClientImpl::port() const { return port_; }

    inline size_t ClientImpl::is_socket_open() const {
    std::lock_guard<std::mutex> guard(socket_mutex_);
    return socket_.is_open();
    }

    inline socket_t ClientImpl::socket() const { return socket_.sock; }

    inline void ClientImpl::set_connection_timeout(time_t sec, time_t usec) {
    connection_timeout_sec_ = sec;
    connection_timeout_usec_ = usec;
    }

    inline void ClientImpl::set_read_timeout(time_t sec, time_t usec) {
    read_timeout_sec_ = sec;
    read_timeout_usec_ = usec;
    }

    inline void ClientImpl::set_write_timeout(time_t sec, time_t usec) {
    write_timeout_sec_ = sec;
    write_timeout_usec_ = usec;
    }

    inline void ClientImpl::set_max_timeout(time_t msec) {
    max_timeout_msec_ = msec;
    }

    inline void ClientImpl::set_basic_auth(const std::string &username,
    const std::string &password) {
    basic_auth_username_ = username;
    basic_auth_password_ = password;
    }

    inline void ClientImpl::set_bearer_token_auth(const std::string &token) {
    bearer_token_auth_token_ = token;
    }

    #ifdef CPPHTTPLIB_OPENSSL_SUPPORT
    inline void ClientImpl::set_digest_auth(const std::string &username,
    const std::string &password) {
    digest_auth_username_ = username;
    digest_auth_password_ = password;
    }
    #endif

    inline void ClientImpl::set_keep_alive(bool on) { keep_alive_ = on; }

    inline void ClientImpl::set_follow_location(bool on) { follow_location_ = on; }

    inline void ClientImpl::set_path_encode(bool on) { path_encode_ = on; }

    inline void
    ClientImpl::set_hostname_addr_map(std::map<std::string, std::string> addr_map) {
    addr_map_ = std::move(addr_map);
    }

    inline void ClientImpl::set_default_headers(protocols::http::Headers headers) {
    default_headers_ = std::move(headers);
    }

    inline void ClientImpl::set_header_writer(
    std::function<ssize_t(Stream &, protocols::http::Headers &)> const &writer) {
    header_writer_ = writer;
    }

    inline void ClientImpl::set_address_family(int family) {
    address_family_ = family;
    }

    inline void ClientImpl::set_tcp_nodelay(bool on) { tcp_nodelay_ = on; }

    inline void ClientImpl::set_ipv6_v6only(bool on) { ipv6_v6only_ = on; }

    inline void ClientImpl::set_socket_options(SocketOptions socket_options) {
    socket_options_ = std::move(socket_options);
    }

    inline void ClientImpl::set_compress(bool on) { compress_ = on; }

    inline void ClientImpl::set_decompress(bool on) { decompress_ = on; }

    inline void ClientImpl::set_interface(const std::string &intf) {
    interface_ = intf;
    }

    inline void ClientImpl::set_proxy(const std::string &host, int port) {
    proxy_host_ = host;
    proxy_port_ = port;
    }

    inline void ClientImpl::set_proxy_basic_auth(const std::string &username,
    const std::string &password) {
    proxy_basic_auth_username_ = username;
    proxy_basic_auth_password_ = password;
    }

    inline void ClientImpl::set_proxy_bearer_token_auth(const std::string &token) {
    proxy_bearer_token_auth_token_ = token;
    }

    #ifdef CPPHTTPLIB_OPENSSL_SUPPORT
    inline void ClientImpl::set_proxy_digest_auth(const std::string &username,
    const std::string &password) {
    proxy_digest_auth_username_ = username;
    proxy_digest_auth_password_ = password;
    }

    inline void ClientImpl::set_ca_cert_path(const std::string &ca_cert_file_path,
    const std::string &ca_cert_dir_path) {
    ca_cert_file_path_ = ca_cert_file_path;
    ca_cert_dir_path_ = ca_cert_dir_path;
    }

    inline void ClientImpl::set_ca_cert_store(X509_STORE *ca_cert_store) {
    if (ca_cert_store && ca_cert_store != ca_cert_store_) {
    ca_cert_store_ = ca_cert_store;
    }
    }

    inline X509_STORE *ClientImpl::create_ca_cert_store(const char *ca_cert,
    std::size_t size) const {
    auto mem = BIO_new_mem_buf(ca_cert, static_cast<int>(size));
    auto se = detail::scope_exit([&] { BIO_free_all(mem); });
    if (!mem) { return nullptr; }

    auto inf = PEM_X509_INFO_read_bio(mem, nullptr, nullptr, nullptr);
    if (!inf) { return nullptr; }

    auto cts = X509_STORE_new();
    if (cts) {
    for (auto i = 0; i < static_cast<int>(sk_X509_INFO_num(inf)); i++) {
    auto itmp = sk_X509_INFO_value(inf, i);
    if (!itmp) { continue; }

    if (itmp->x509) { X509_STORE_add_cert(cts, itmp->x509); }
    if (itmp->crl) { X509_STORE_add_crl(cts, itmp->crl); }
    }
    }

    sk_X509_INFO_pop_free(inf, X509_INFO_free);
    return cts;
    }

    inline void ClientImpl::enable_server_certificate_verification(bool enabled) {
    server_certificate_verification_ = enabled;
    }

    inline void ClientImpl::enable_server_hostname_verification(bool enabled) {
    server_hostname_verification_ = enabled;
    }

    inline void ClientImpl::set_server_certificate_verifier(
    std::function<SSLVerifierResponse(SSL *ssl)> verifier) {
    server_certificate_verifier_ = verifier;
    }
    #endif

    inline void ClientImpl::set_logger(Logger logger) {
    logger_ = std::move(logger);
    }

    inline void ClientImpl::set_error_logger(ErrorLogger error_logger) {
    error_logger_ = std::move(error_logger);
    }

}}}//qor::components::network
