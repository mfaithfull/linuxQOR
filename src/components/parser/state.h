// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_COMPONENTS_PARSER_STATE
#define QOR_PP_H_COMPONENTS_PARSER_STATE

#include "src/framework/workflow/workflow.h"
#include "result.h"
#include "node.h"
#include "tokens.h"

namespace qor { namespace components { namespace parser {

    class Context;

    class qor_pp_module_interface(QOR_PARSER) ParserState : public workflow::State
    {
    public:

        ParserState(workflow::Workflow* workflow, Context* context);

        Result m_result;

    protected:
        
        Context* m_context;
        Node* m_parent;
    };

    class qor_pp_module_interface(QOR_PARSER) AcceptAll : public ParserState
    {
    public:

        AcceptAll(workflow::Workflow* workflow, Context* context);

    };

    class Specific : public ParserState
    {
    public:

        Specific(workflow::Workflow* workflow, Context* context, byte matchingOctet, eToken token);
    private:
        byte m_matchingOctet;
        eToken m_token;
    };

    class CR : public Specific
    { public: CR(workflow::Workflow* workflow, Context* context) : Specific(workflow, context, 0x0D, eToken::CarriageReturn){} };

    class LF : public Specific
    { public: LF(workflow::Workflow* workflow, Context* context) : Specific(workflow, context, 0x0A, eToken::LineFeed){} };

    class HTAB : public Specific
    { public: HTAB(workflow::Workflow* workflow, Context* context) : Specific(workflow, context, 0x09, eToken::HorizontalTab){} };

    class DQUOTE : public Specific
    { public: DQUOTE(workflow::Workflow* workflow, Context* context) : Specific(workflow, context, 0x22, eToken::DoubleQuote){} };

    class SP : public Specific
    { public: SP(workflow::Workflow* workflow, Context* context) : Specific(workflow, context, 0x20, eToken::Space){} };

    class OneOfARange : public ParserState
    {
    public:

        OneOfARange(workflow::Workflow* workflow, Context* context, byte firstOctet, byte lastOctet, eToken token);

    private:
        byte m_first;
        byte m_last;
        eToken m_token;
    };

    class DIGIT : public OneOfARange
    { public: DIGIT(workflow::Workflow* workflow, Context* context) : OneOfARange(workflow, context, 0x30, 0x39, eToken::Digit){} };

    class VCHAR : public OneOfARange
    { public: VCHAR(workflow::Workflow* workflow, Context* context) : OneOfARange(workflow, context, 0x21, 0x7e, eToken::VisibleChar){} };


    class AnyOneOf : public ParserState
    {
    public:

        AnyOneOf(workflow::Workflow* workflow, Context* context, const ParserState& head, const ParserState& tail, eToken token) : ParserState(workflow,context),
            m_head(head), m_tail(tail), m_token(token), m_internalState(0)
        {
            Enter = [workflow, this, context]()
            {
                workflow->PushState(m_head);
            };

            Resume = [workflow, this, context]()
            {
                switch(m_internalState)
                {
                case 0:
                    if(m_head.m_result.code == Result::SUCCESS)
                    {
                        m_result.code = Result::SUCCESS;
                        m_result.first = m_head.m_result.first;
                        m_result.length = m_head.m_result.length;
                        m_result.token = m_token;
                        workflow->PopState();
                    }
                    else
                    {
                        m_internalState = 1;
                        workflow->PushState(m_tail);                            
                    }
                    break;
                case 1:
                    if(m_tail.m_result.code == Result::SUCCESS)
                    {
                        m_result.code = Result::SUCCESS;
                        m_result.first = m_tail.m_result.first;
                        m_result.length = m_tail.m_result.length;
                        m_result.token = m_token;
                        workflow->PopState();
                    }
                    else
                    {
                        m_result.code = Result::FAILURE;
                        workflow->PopState();
                    }
                    break;
                }
            };
        }

    private:
        
        unsigned int m_internalState;
        ParserState m_head;
        ParserState m_tail;
        eToken m_token;
    };

    class CTL : public AnyOneOf
    { public : CTL(workflow::Workflow* workflow, Context* context) : 
        AnyOneOf(workflow, context, 
            OneOfARange(workflow, context, 0x00, 0x1f, eToken::Lexical), 
            Specific(workflow, context, 0x7f, eToken::Lexical),
            eToken::Control
        ){} 
    };

    class HEXDIGIT : public AnyOneOf
    { public : HEXDIGIT(workflow::Workflow* workflow, Context* context) :
        AnyOneOf(workflow, context,
            DIGIT(workflow, context),
            OneOfARange(workflow, context, 'A', 'F', eToken::Lexical),
            eToken::HexDigit
        ){}
    };

    class WSP : public AnyOneOf
    { public: WSP(workflow::Workflow* workflow, Context* context) :
        AnyOneOf(workflow, context,
            SP(workflow, context),
            HTAB(workflow, context),
            eToken::WhiteSpace
        ){}
    };

    class ZeroOrMore : public ParserState
    {
    public:

        ZeroOrMore(workflow::Workflow* workflow, Context* context, const ParserState& head, eToken token) : ParserState(workflow,context),
            m_head(head), m_token(token), m_first(true)
        {
            Enter = [workflow, this, context]()
            {
                workflow->PushState(m_head);
            };

            Resume = [workflow, this, context]()
            {
                m_result.code = Result::SUCCESS;                
                m_result.token = m_token;
                if(m_head.m_result.code == Result::SUCCESS)
                {
                    if(m_first)
                    {
                        m_result.first = m_head.m_result.first;
                        m_first = false;
                    }
                    m_result.length += m_head.m_result.length;
                    //TODO: reset head
                    workflow->PushState(m_head);
                }
                else
                {
                    workflow->PopState();
                }
            };
        }

    private:
        
        ParserState m_head;
        bool m_first;
        eToken m_token;
    };

    class Sequence : public ParserState
    {
    public:

        Sequence(workflow::Workflow* workflow, Context* context, const ParserState& head, const ParserState& tail, eToken token) : ParserState(workflow,context),
            m_head(head), m_tail(tail), m_token(token), m_internalState(0)
        {
            Enter = [workflow, this, context]()
            {
                workflow->PushState(m_head);
            };

            Resume = [workflow, this, context]()
            {
                switch(m_internalState)
                {
                case 0:
                    if(m_head.m_result.code != Result::SUCCESS)
                    {
                        m_result.code = m_head.m_result.code;
                        m_result.length = 0;
                        workflow->PopState();
                    }
                    else
                    {
                        m_result.first = m_head.m_result.first;
                        m_result.length += m_head.m_result.length;                        
                        m_internalState = 1;
                        workflow->PushState(m_tail);                            
                    }
                    break;
                case 1:
                    if(m_tail.m_result.code == Result::SUCCESS)
                    {
                        m_result.length += m_tail.m_result.length;   
                        m_result.token = m_token;                                             
                        workflow->PopState();
                    }
                    else
                    {
                        m_result.code = Result::FAILURE;
                        workflow->PopState();
                    }
                    break;
                }
            };
        }

    private:
        
        unsigned int m_internalState;
        ParserState m_head;
        ParserState m_tail;
        eToken m_token;
    };

    class CRLF : public Sequence
    { public : CRLF(workflow::Workflow* workflow, Context* context) :
        Sequence(workflow, context, CR(workflow, context), LF(workflow, context), eToken::CarriageReturnLineFeed){}
    };

    class LWSP : public ZeroOrMore
    { public : LWSP(workflow::Workflow* workflow, Context* context) :
        ZeroOrMore(workflow, context,
            AnyOneOf(workflow, context,
                WSP(workflow, context),
                CRLF(workflow, context),
                eToken::Lexical
            ),
            eToken::LinearWhiteSpace
        ){}
    };

    class BIT : public AnyOneOf
    { public : BIT(workflow::Workflow* workflow, Context* context) :
        AnyOneOf(workflow, context,
            Specific(workflow, context, '0', eToken::Lexical),
            Specific(workflow, context, '1', eToken::Lexical),
            eToken::Bit
        ){}
    };

    class CHAR : public OneOfARange
    { public : CHAR(workflow::Workflow* workflow, Context* context) :
        OneOfARange(workflow, context, 0x01, 0x7F, eToken::Char){}
    };

    class ALPHA : public AnyOneOf
    { public: ALPHA(workflow::Workflow* workflow, Context* context) :
        AnyOneOf(workflow, context,
            OneOfARange(workflow, context, 0x41, 0x5A, eToken::Lexical),
            OneOfARange(workflow, context, 0x61, 0x7A, eToken::Lexical),
            eToken::Alpha
        ){}
    };

}}}//qor::components::parser

#endif//QOR_PP_H_COMPONENTS_PARSER_STATE