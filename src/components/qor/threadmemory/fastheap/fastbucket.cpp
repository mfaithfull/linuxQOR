// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"
#include <string.h>
#include "fastbucket.h"
#include "../threadheap/threadheap.h"

namespace qor{ namespace components{ namespace threadmemory{

    void* FastBucket::operator new(size_t sz)
    {
        return new_ref<ThreadHeap>()->Allocate(sz);
    }

    void FastBucket::operator delete(void* allocation)
    {
        new_ref<ThreadHeap>()->Free(reinterpret_cast<byte*>(allocation));
    }

    FastBucket::FastBucket(size_t pageUnits) : m_pageUnits(pageUnits)
    , m_basePage(nullptr), m_ToSPage(nullptr), m_items(0), m_pages(0) {}

    FastBucket::~FastBucket()
    {
        StackPage* page = m_ToSPage;
        while (page)
        {
            m_ToSPage = page->Previous();
            delete page;
            page = m_ToSPage;
        }
    }

    size_t FastBucket::PageSize() const
    {
        return (m_pageUnits * StackPage::c_pageSize);
    }

    size_t FastBucket::AllocatedItems() const
    {
        return m_items;
    }

    size_t FastBucket::AllocatedPages() const
    {
        return m_pages;
    }

    size_t FastBucket::AllocatedSpace() const
    {
        size_t Space = 0;
        StackPage* page = m_basePage;
        while (page)
        {
            Space += page->TotalSizeBytes();
            page = page->Next();
        }
        return Space;
    }

    void FastBucket::SetSize(size_t pageUnits)
    {
        m_pageUnits = pageUnits;
    }

    void FastBucket::Initialise()
    {
        if (m_ToSPage == nullptr)
        {
            m_ToSPage = m_basePage = new StackPage(m_pageUnits);
            m_pages = 1;
        }
    }

    void FastBucket::PushPage(void)
    {
        m_ToSPage->SetNext(new StackPage(m_pageUnits));
        m_ToSPage->Next()->SetPrevious(m_ToSPage);
        m_ToSPage = m_ToSPage->Next();
        m_pages++;
    }

    void FastBucket::PopPage(void)
    {
        m_ToSPage = m_ToSPage->Previous();
        m_ToSPage->Next()->SetPrevious(nullptr);
        delete m_ToSPage->Next();
        m_ToSPage->SetNext(nullptr);
        m_pages--;
    }

    void* FastBucket::Allocate(size_t byteCount)
    {
        m_ToSPage->Initialise();
        void* mem = m_ToSPage->Allocate(byteCount);

        if (mem == nullptr && (byteCount < (m_pageUnits * StackPage::c_pageSize)))
        {
            PushPage();
            m_ToSPage->Initialise();
            mem = m_ToSPage->Allocate(byteCount);

            if(mem == nullptr)
            {
                mem = new_ref<ThreadHeap>()->Allocate(byteCount);
            }
        }

        if (mem != nullptr)
        {
            m_items++;
        }
        return mem;
    }

    bool FastBucket::Free(void* memory, size_t byteCount)
    {
        //Shortcut to page
        StackPage* page = *(reinterpret_cast< StackPage** >((reinterpret_cast< unsigned char* >(memory)) - sizeof(StackPage**)));

        if (page && page->Free(memory, byteCount) )
        {
            --m_items;
            if (page->AllocatedItemsCount() == 0 && m_pages > 1 )
            {
                StackPage* prev = page->Previous();
                StackPage* next = page->Next();

                if (page == m_ToSPage)
                {
                    m_ToSPage = m_ToSPage->Previous();
                    if (m_ToSPage)
                    {
                        m_ToSPage->SetNext(nullptr);
                    }
                }
                else if (page == m_basePage)
                {
                    m_basePage = m_basePage->Next();
                    if (m_basePage != nullptr)
                    {
                        m_basePage->SetPrevious(nullptr);
                    }
                }
                else
                {
                    if (prev)
                    {
                        prev->SetNext(next);
                        page->SetPrevious(nullptr);
                    }
                    if (next)
                    {
                        next->SetPrevious(prev);
                        page->SetNext(nullptr);
                    }
                }
                delete page;
                m_pages--;
            }
            if (m_pages == 0)
            {
                m_ToSPage = nullptr;
                m_basePage = nullptr;
            }
            return true;
        }
        else
        {
            throw memoryexception("Memory to delete %X not found in Fast Heap.");
        }
    }

}}}//qor::components::threadmemory

