// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_FRAMEWORK_TASK_DETAIL_WHEN_ALL_TASK
#define QOR_PP_H_FRAMEWORK_TASK_DETAIL_WHEN_ALL_TASK

#include <coroutine>
#include <cassert>

#include "src/framework/task/awaitabletraits.h"

#include "whenallcounter.h"
#include "voidvalue.h"

namespace qor{	namespace detail{

	template<typename TASK_CONTAINER>
	class WhenAllReadyAwaitable;

	template<typename RESULT>
	class WhenAllTask;

	template<typename RESULT>
	class WhenAllTaskPromise final
	{
	public:

		using coroutine_handle_t = std::coroutine_handle<WhenAllTaskPromise<RESULT>>;

		WhenAllTaskPromise() noexcept {}

		auto get_return_object() noexcept
		{
			return coroutine_handle_t::from_promise(*this);
		}

		std::suspend_always initial_suspend() noexcept
		{
			return{};
		}

		auto final_suspend() noexcept
		{
			class completion_notifier
			{
			public:

				bool await_ready() const noexcept { return false; }

				void await_suspend(coroutine_handle_t coro) const noexcept
				{
					coro.promise().m_counter->notify_awaitable_completed();
				}

				void await_resume() const noexcept {}

			};

			return completion_notifier{};
		}

		void unhandled_exception() noexcept
		{
			m_exception = std::current_exception();
		}

		void return_void() noexcept
		{
			// We should have either suspended at co_yield point or
			// an exception was thrown before running off the end of
			// the coroutine.
			assert(false);
		}

#if CPPCORO_COMPILER_MSVC
		// HACK: This is needed to work around a bug in MSVC 2017.7/2017.8.
		// See comment in make_when_all_task below.
		template<typename Awaitable>
		Awaitable&& await_transform(Awaitable&& awaitable)
		{
			return static_cast<Awaitable&&>(awaitable);
		}

		struct get_promise_t {};
		static constexpr get_promise_t get_promise = {};

		auto await_transform(get_promise_t)
		{
			class awaiter
			{
			public:
				awaiter(WhenAllTaskPromise* promise) noexcept : m_promise(promise) {}
				bool await_ready() noexcept {
					return true;
				}
				void await_suspend(std::coroutine_handle<>) noexcept {}
				WhenAllTaskPromise& await_resume() noexcept
				{
					return *m_promise;
				}
			private:
				WhenAllTaskPromise* m_promise;
			};
			return awaiter{ this };
		}
#endif


		auto yield_value(RESULT&& result) noexcept
		{
			m_result = std::addressof(result);
			return final_suspend();
		}

		void start(WhenAllCounter& counter) noexcept
		{
			m_counter = &counter;
			coroutine_handle_t::from_promise(*this).resume();
		}

		RESULT& result() &
		{
			rethrow_if_exception();
			return *m_result;
		}

		RESULT&& result() &&
		{
			rethrow_if_exception();
			return std::forward<RESULT>(*m_result);
		}

	private:

		void rethrow_if_exception()
		{
			if (m_exception)
			{
				std::rethrow_exception(m_exception);
			}
		}

		WhenAllCounter* m_counter;
		std::exception_ptr m_exception;
		std::add_pointer_t<RESULT> m_result;

	};

	template<>
	class WhenAllTaskPromise<void> final
	{
	public:

		using coroutine_handle_t = std::coroutine_handle<WhenAllTaskPromise<void>>;

		WhenAllTaskPromise() noexcept
		{}

		auto get_return_object() noexcept
		{
			return coroutine_handle_t::from_promise(*this);
		}

		std::suspend_always initial_suspend() noexcept
		{
			return{};
		}

		auto final_suspend() noexcept
		{
			class completion_notifier
			{
			public:

				bool await_ready() const noexcept { return false; }

				void await_suspend(coroutine_handle_t coro) const noexcept
				{
					coro.promise().m_counter->notify_awaitable_completed();
				}

				void await_resume() const noexcept {}

			};

			return completion_notifier{};
		}

		void unhandled_exception() noexcept
		{
			m_exception = std::current_exception();
		}

		void return_void() noexcept
		{
		}

		void start(WhenAllCounter& counter) noexcept
		{
			m_counter = &counter;
			coroutine_handle_t::from_promise(*this).resume();
		}

		void result()
		{
			if (m_exception)
			{
				std::rethrow_exception(m_exception);
			}
		}

	private:

		WhenAllCounter* m_counter;
		std::exception_ptr m_exception;

	};

	template<typename RESULT>
	class WhenAllTask final
	{
	public:

		using promise_type = WhenAllTaskPromise<RESULT>;

		using coroutine_handle_t = typename promise_type::coroutine_handle_t;

		WhenAllTask(coroutine_handle_t coroutine) noexcept
			: m_coroutine(coroutine)
		{}

		WhenAllTask(WhenAllTask&& other) noexcept
			: m_coroutine(std::exchange(other.m_coroutine, coroutine_handle_t{}))
		{}

		~WhenAllTask()
		{
			if (m_coroutine) m_coroutine.destroy();
		}

		WhenAllTask(const WhenAllTask&) = delete;
		WhenAllTask& operator=(const WhenAllTask&) = delete;

		decltype(auto) result() &
		{
			return m_coroutine.promise().result();
		}

		decltype(auto) result() &&
		{
			return std::move(m_coroutine.promise()).result();
		}

		decltype(auto) non_void_result() &
		{
			if constexpr (std::is_void_v<decltype(this->result())>)
			{
				this->result();
				return void_value{};
			}
			else
			{
				return this->result();
			}
		}

		decltype(auto) non_void_result() &&
		{
			if constexpr (std::is_void_v<decltype(this->result())>)
			{
				std::move(*this).result();
				return void_value{};
			}
			else
			{
				return std::move(*this).result();
			}
		}

	private:

		template<typename TASK_CONTAINER>
		friend class WhenAllReadyAwaitable;

		void start(WhenAllCounter& counter) noexcept
		{
			m_coroutine.promise().start(counter);
		}

		coroutine_handle_t m_coroutine;

	};

	template< typename AWAITABLE, typename RESULT = typename awaitable_of<AWAITABLE&&>::await_result_t, std::enable_if_t<!std::is_void_v<RESULT>, int> = 0>
	WhenAllTask<RESULT> make_when_all_task(AWAITABLE awaitable)
	{
#if CPPCORO_COMPILER_MSVC
		// HACK: Workaround another bug in MSVC where the expression 'co_yield co_await x' seems
		// to completely ignore the co_yield an never calls promise.yield_value().
		// The coroutine seems to be resuming the 'co_await' after the 'co_yield'
		// rather than before the 'co_yield'.
		// This bug is present in VS 2017.7 and VS 2017.8.
		auto& promise = co_await WhenAllTaskPromise<RESULT>::get_promise;
		co_await promise.yield_value(co_await std::forward<AWAITABLE>(awaitable));
#else
		co_yield co_await static_cast<AWAITABLE&&>(awaitable);
#endif
	}

	template< typename AWAITABLE, typename RESULT = typename awaitable_of<AWAITABLE&&>::await_result_t, std::enable_if_t<std::is_void_v<RESULT>, int> = 0>
	WhenAllTask<void> make_when_all_task(AWAITABLE awaitable)
	{
		co_await static_cast<AWAITABLE&&>(awaitable);
	}

	template< typename AWAITABLE, typename RESULT = typename awaitable_of<AWAITABLE&>::await_result_t, std::enable_if_t<!std::is_void_v<RESULT>, int> = 0>
	WhenAllTask<RESULT> make_when_all_task(std::reference_wrapper<AWAITABLE> awaitable)
	{
#if CPPCORO_COMPILER_MSVC
		// HACK: Workaround another bug in MSVC where the expression 'co_yield co_await x' seems
		// to completely ignore the co_yield and never calls promise.yield_value().
		// The coroutine seems to be resuming the 'co_await' after the 'co_yield'
		// rather than before the 'co_yield'.
		// This bug is present in VS 2017.7 and VS 2017.8.
		auto& promise = co_await WhenAllTaskPromise<RESULT>::get_promise;
		co_await promise.yield_value(co_await awaitable.get());
#else
		co_yield co_await awaitable.get();
#endif
	}

	template< typename AWAITABLE, typename RESULT = typename awaitable_of<AWAITABLE&>::await_result_t, std::enable_if_t<std::is_void_v<RESULT>, int> = 0>
	WhenAllTask<void> make_when_all_task(std::reference_wrapper<AWAITABLE> awaitable)
	{
		co_await awaitable.get();
	}

}}//qor::detail

#endif//QOR_PP_H_FRAMEWORK_TASK_DETAIL_WHEN_ALL_TASK
