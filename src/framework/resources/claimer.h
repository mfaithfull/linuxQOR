// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_FRAMEWORK_RESOURCE_CLAIMER
#define QOR_PP_H_FRAMEWORK_RESOURCE_CLAIMER

#include "resourcehub.h"
#include "src/qor/delegate/bindmember.h"

namespace qor{ namespace framework{

    //Responds to resource updates with the purpose of claiming a specific type of resource on a specific path
    //Can be waited on to synchronously claim a resource before proceeding
    template<class ResourceType>
    class Claimer
    {
    public:

        Claimer(ref_of<ResourceHub>::type hub, platform::Path& path)
        {
            m_resource = nullptr;
            hub->SubscribeForAllByPath(path.ToString(), bindMemberFunction(&Claimer<ResourceType>::Callback, this));
            hub->AddPath(path);
        }

        Claimer(ref_of<ResourceHub>::type hub, platform::FileIndex& file)
        {
            m_resource = nullptr;
            hub->SubscribeForAllByPath(file.ToString(), bindMemberFunction(&Claimer<ResourceType>::Callback, this));
            hub->AddFile(file);
        }

        bool Callback(Resource* res, ResourceStatus status)
        {
            if(res)
            {
                if(res->Type() == res::Path::StaticType() && status == Named)
                {
                    res->Locate();
                    return true;
                }
                if(res->Type() == res::Path::StaticType() && status == Located)
                {
                    res::Path* path = dynamic_cast<res::Path*>(res);
                    if(path)
                    {
                        path->IncludeSubFolders();
                        path->Claim();
                    }
                    return true;
                }

                if(res->Type() == res::File::StaticType() && status == Named)
                {
                    res->Locate();
                    return true;
                }

                if(res->Type() == res::File::StaticType() && status == Located)
                {
                    res->Claim();
                    return true;
                }

                if(res->Type() == ResourceType::StaticType() && status == Named)
                {
                    res->Locate();
                    return true;
                }

                if(res->Type() == ResourceType::StaticType() && status == Located)
                {
                    res->Claim();
                    return true;
                }

                if(res->Type() == ResourceType::StaticType() && status == Claimed)
                {
                    m_resource = dynamic_cast<ResourceType*>(res);
                    if(m_resource)
                    {
                        std::lock_guard<std::mutex> lock(m_mutex);
                        m_cond.notify_one();
                    }
                    return false;
                }

            }
            return true;
        }

        ResourceType* GetResouce()
        {
            return m_resource;
        }

        void WaitForResouce(ResourceType*& res)
        {
            std::unique_lock<std::mutex> lock(m_mutex);
            m_cond.wait(lock);
            res = m_resource;
        }

    private:
        std::mutex m_mutex;
        std::condition_variable m_cond;
        ResourceType* m_resource;

    };

}}//qor::framework

#endif//QOR_PP_H_FRAMEWORK_RESOURCE_CLAIMER