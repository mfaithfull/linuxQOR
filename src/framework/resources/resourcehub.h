// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_FRAMEWORK_RESOURCES_RESOURCEHUB
#define QOR_PP_H_FRAMEWORK_RESOURCES_RESOURCEHUB

#include <string>
#include <map>
#include <functional>
#include <deque>

#include "src/framework/thread/currentthread.h"
#include "src/qor/factory/factory.h"
#include "src/qor/injection/typeidentity.h"
#include "src/qor/factory/externalfactory.h"
#include "src/qor/reference/newref.h"
#include "src/framework/role/ifeature.h"
#include "src/framework/thread/threadpool.h"

#include "manager.h"
#include "container.h"
#include "types/pathresource.h"
#include "types/fileresource.h"
#include "types/json/jsonresource.h"

#ifndef QOR_PP_IMPLEMENTS_RESOURCEHUB
namespace qor{ bool qor_pp_import ImplementsResourceHub();}
#endif
qor_pp_module_will_provide(QOR_RESOURCES, ResourceHub)

namespace qor{ namespace framework{
        
    //Manage resources and subcriptions for recieving updates about them
    class qor_pp_module_interface(QOR_RESOURCES) ResourceHub : public IFeature, public ResourceManager
    {

    public:

        ResourceHub();
        virtual ~ResourceHub() noexcept(true)
        {
        }

        virtual void Setup();
        virtual void Shutdown();

        void UseThreadPool(ref_of<ThreadPool>::type threadPool);
        //Automatically collect the run location of the executable if possible. Also the launch location/current folder
        //  Any user home folder and Application Data folder assigned or preferred by the OS.

        virtual void BeginBatch(Resource* batchKey);
        virtual void EndBatch(Resource* batchKey);
        virtual void AddPath(const platform::Path& path, Resource* batchKey = nullptr);//Add a Path resource, return a URI by which it will be indexed
        virtual void AddFile(const platform::FileIndex& file, Resource* batchKey = nullptr);//Add a File resource, return a URI by which it will be indexed
        virtual void AddJSON(const platform::FileIndex& file, Resource* batchKey = nullptr);
        
        void SubscribeForNamesByPath(const std::string& uriPathPart, const std::function<bool(Resource*)>& onNamedcallback);
        void SubscribeForLocationsByPath(const std::string& uriPathPart, const std::function<bool(Resource*)>& onLocatedcallback);
        void SubscribeForClaimsByPath(const std::string& uriPathPart, const std::function<bool(Resource*)>& onClaimedcallback);
        void SubscribeForAvaialbilityByPath(const std::string& uriPathPart, const std::function<bool(Resource*)>& onAvailablecallback);
        void SubscribeForRemovalByPath(const std::string& uriPathPart, const std::function<bool(Resource*)>& onRemovedcallback);
        void SubscribeForAllByPath(const std::string& uriPathPart, const std::function<bool(Resource*, ResourceStatus)>& onStatuscallback);

        void SubscribeForNamesByType(const char* type, const std::function<bool(Resource*)>& onNamedcallback);
        void SubscribeForLocationsByType(const char* type, const std::function<bool(Resource*)>& onLocatedcallback);
        void SubscribeForClaimsByType(const char* type, const std::function<bool(Resource*)>& onClaimedcallback);
        void SubscribeForAvailabilityByType(const char* type, const std::function<bool(Resource*)>& onAvailabilitycallback);
        void SubscribeForRemovalByType(const char* type, const std::function<bool(Resource*)>& onRemovedcallback);
        void SubscribeForAllByType(const char* type, const std::function<bool(Resource*, ResourceStatus)>& onStatuscallback);

    protected:
        virtual void OnNamed(Resource* res);
        virtual void OnLocated(Resource* res);
        virtual void OnClaimed(Resource* res);
        virtual void OnAvailable(Resource* res);
        virtual void OnRemoved(Resource* res);

        //Stages of Resource provision:
            //Named - given a URI
            //Located - confirmed to exist and be potentially accessible
            //Claimed - downloaded/cached/locked
            //Available - loaded and available as a Model. An image, a Font, A DOM, in memory DB, or maybe just a string.
        
        //At each stage from Located to Available notifications get sent out and further processing can be stopped, delayed or prioritised.
        //There will need to be some form of callback interface for this
        
        //Models in the cache will need a way to be claimed/locked by clients, also waited on and requested Vanquo style would be good.
        //This is especially useful where models are just proxies for resources that remain on disk for example due to size.
        //One of the possible responses to the Claimed notification should be to make a proxy availble as a Model.
        //If we implement full Vanquo request forwarding then the user can run as many resource hubs as they like. 
        //They will all collaborate if we can give them a way to find one another. That will require a UDP client and server as we as 
        //something shared between the in process instances and host local instances. Broadcast signals should be enough between threads.
        //A Pipe/Unix Socket will be needed between processes.
        //Resource requests for a URI containing host, process and thread data go out
        //Listeners record the the sender as known resource owner/user.
        //Respond if they have the resource or know who has/had it and when.
        //Announce when a sharable resource becomes available.
        //Announce the assignment of a resource they currently own to another owner and record where it went as it's last known owner.
        //If the last known owner is determined to be down then a request is made to the primary resource holder to seize it. e.g. lock the file/record
        //If they do they become the owner and Announce

        //We should use the resource hub for translations resources as well as traditional UI fonts and images.

        //mime-types become important here. Resources in the cache might need an identifiable mime type so that they can be retrieved
        //We might provide or detect the mime-type in order to load a resource in the first place.

        //If so we aught to be able to make more types available by plugging them into the resource hub. 
        //Each will need a name, some kind of recongizer that works and a loader/parser for the model.

    protected:

        typedef std::pair< const char*, std::function<bool(Resource*)> > typeSubscription;
        typedef std::pair< std::string, std::function<bool(Resource*, ResourceStatus)> > typeallSubscription;

        typedef std::pair< std::string, std::function<bool(Resource*)> > pathSubscription;
        typedef std::pair< std::string, std::function<bool(Resource*, ResourceStatus)> > pathallSubscription;

        std::vector< pathSubscription > m_namesByPathSubscriptions;
        std::recursive_mutex m_namesByPathSubscriptionsMutex;

        std::vector< pathSubscription > m_locationsByPathSubscriptions;
        std::recursive_mutex m_locationsByPathSubscriptionsMutex;

        std::vector< pathSubscription > m_claimsByPathSubscriptions;
        std::recursive_mutex m_claimsByPathSubscriptionsMutex;

        std::vector< pathSubscription > m_availabilityByPathSubscriptions;
        std::recursive_mutex m_availabilityByPathSubscriptionsMutex;

        std::vector< pathSubscription > m_removalsByPathSubscriptions;
        std::recursive_mutex m_removalsByPathSubscriptionsMutex;

        std::vector< pathallSubscription > m_allByPathSubscriptions;
        std::recursive_mutex m_allByPathSubscriptionsMutex;

        std::vector< typeSubscription > m_namesByTypeSubscriptions;
        std::recursive_mutex m_namesByTypeSubscriptionsMutex;

        std::vector< typeSubscription > m_locationsByTypeSubscriptions;
        std::recursive_mutex m_locationsByTypeSubscriptionsMutex;

        std::vector< typeSubscription > m_claimsByTypeSubscriptions;
        std::recursive_mutex m_claimsByTypeSubscriptionsMutex;

        std::vector< typeSubscription > m_availabilityByTypeSubscriptions;
        std::recursive_mutex m_availabilityByTypeSubscriptionsMutex;

        std::vector< typeSubscription > m_removalByTypeSubscriptions;
        std::recursive_mutex m_removalByTypeSubscriptionsMutex;

        std::vector< typeallSubscription > m_allByTypeSubscriptions;
        std::recursive_mutex m_allByTypeSubscriptionsMutex;
        
        std::map<std::string, res::Path*> m_paths;        
        std::recursive_mutex m_pathsMutex;

        std::map<std::string, res::File*> m_files;
        std::recursive_mutex m_filesMutex;

        std::map<std::string, res::JSON*> m_json;
        std::recursive_mutex m_jsonMutex;

        ByTypeContainer m_containers;

        Resource* m_batch;
        std::recursive_mutex m_batchMutex;

        void UpdateSubscribersToAll(Resource* res, ResourceStatus status, const std::string& uri, std::vector<pathallSubscription>& subs, std::recursive_mutex& mtx);        
        void UpdateSubscribers(Resource* res, const std::string& uri, std::vector<pathSubscription>& subs, std::recursive_mutex& mtx);
        void UpdateByTypeSubscribersToAll(Resource* res, ResourceStatus status, const std::string& uri, std::vector<typeallSubscription>& subs, std::recursive_mutex& mtx);
        void UpdateByTypeSubscribers(Resource* res, std::vector<typeSubscription>& subs, std::recursive_mutex& mtx);
        bool AdoptResource(Resource* res);
        void DisposeResource(Resource* res);

    };

    }//framework

    qor_pp_declare_factory_of(framework::ResourceHub, ExternalFactory);
    constexpr GUID ResourceHubGUID = {0x347d6ff9, 0x9f76, 0x4a4c, {0xb8, 0x73, 0xef, 0x26, 0x18, 0x9e, 0x50, 0x31}};
    qor_pp_declare_guid_of(framework::ResourceHub,ResourceHubGUID);

}//qor

#endif//QOR_PP_H_FRAMEWORK_RESOURCES_RESOURCEHUB
