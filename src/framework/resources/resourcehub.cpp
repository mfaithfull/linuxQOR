// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include "src/framework/role/role.h"
#include "src/framework/signals/signal.h"
#define QOR_PP_IMPLEMENTS_RESOURCEHUB
#include "resourcehub.h"
#include "types/pathresource.h"
#include "types/json/jsonresource.h"

qor_pp_module_provide(QOR_RESOURCES, ResourceHub)

namespace qor{ namespace framework{

    ResourceHub::ResourceHub() : m_batch(nullptr)
    {
    }

    void ResourceHub::Setup()
    {
        if(m_threadPool.IsNull())
        {
            continuable("Please configure the Resource Hub by calling `UseThreadPool(ref_of<ThreadPool> tp);`. Hub will not be active.");
            return;
        }
        Start();
    }
    
    void ResourceHub::Shutdown()
    {
        if(m_threadPool.IsNotNull())
        {
            Stop();
            m_threadPool.Dispose();
        }
    }

    void ResourceHub::UseThreadPool(ref_of<ThreadPool>::type threadPool)
    {
        m_threadPool = threadPool;
    }

    void ResourceHub::BeginBatch(Resource* batchKey)
    {        
        m_batchMutex.lock();
        m_batch = batchKey;
    }

    void ResourceHub::EndBatch(Resource* batchKey)
    {
        if(batchKey == m_batch)
        {            
            m_batch = nullptr;
            m_batchMutex.unlock();
        }
    }

    void ResourceHub::AddPath(const qor::platform::Path& path, Resource* batchKey)
    {
        new res::Path(this, path, batchKey);        
    }

    void ResourceHub::AddFile(const qor::platform::FileIndex& index, Resource* batchKey)
    {
        new res::File(this, index, batchKey);        
    }

    void ResourceHub::AddJSON(const platform::FileIndex& file, Resource* batchKey)
    {
        new res::JSON(this, file, batchKey);
    }

    void ResourceHub::SubscribeForNamesByType(const char* type, const std::function<bool(Resource*)>& onNamedcallback)
    {
        m_namesByTypeSubscriptionsMutex.lock();
        m_namesByTypeSubscriptions.push_back( typeSubscription {type, onNamedcallback} );
        m_namesByTypeSubscriptionsMutex.unlock();
    }

    void ResourceHub::SubscribeForLocationsByType(const char* type, const std::function<bool(Resource*)>& onLocatedcallback)
    {
        m_locationsByTypeSubscriptionsMutex.lock();
        m_locationsByTypeSubscriptions.push_back( typeSubscription {type, onLocatedcallback} );
        m_locationsByTypeSubscriptionsMutex.unlock();
    }

    void ResourceHub::SubscribeForClaimsByType(const char* type, const std::function<bool(Resource*)>& onClaimedcallback)
    {
        m_claimsByTypeSubscriptionsMutex.lock();
        m_claimsByTypeSubscriptions.push_back( typeSubscription {type, onClaimedcallback} );
        m_claimsByTypeSubscriptionsMutex.unlock();

    }

    void ResourceHub::SubscribeForAvailabilityByType(const char* type, const std::function<bool(Resource*)>& onAvailabilitycallback)
    {
        m_availabilityByTypeSubscriptionsMutex.lock();
        m_availabilityByTypeSubscriptions.push_back( typeSubscription {type, onAvailabilitycallback} );
        m_availabilityByTypeSubscriptionsMutex.unlock();
    }

    void ResourceHub::SubscribeForRemovalByType(const char* type, const std::function<bool(Resource*)>& onRemovedcallback)
    {
        m_removalByTypeSubscriptionsMutex.lock();
        m_removalByTypeSubscriptions.push_back( typeSubscription {type, onRemovedcallback} );
        m_removalByTypeSubscriptionsMutex.unlock();
    }

    void ResourceHub::SubscribeForAllByType(const char* type, const std::function<bool(Resource*, ResourceStatus)>& onStatuscallback)
    {
        m_allByTypeSubscriptionsMutex.lock();
        m_allByTypeSubscriptions.push_back( typeallSubscription {type, onStatuscallback} );
        m_allByTypeSubscriptionsMutex.unlock();
    }

    void ResourceHub::SubscribeForNamesByPath(const std::string& uriPathPart, const std::function<bool(Resource*)>& onNamedcallback)
    {
        m_namesByPathSubscriptionsMutex.lock();
        m_namesByPathSubscriptions.push_back( pathSubscription {uriPathPart, onNamedcallback} );
        m_namesByPathSubscriptionsMutex.unlock();
    }

    void ResourceHub::SubscribeForLocationsByPath(const std::string& uriPathPart, const std::function<bool(Resource*)>& onLocatedcallback)
    {
        m_locationsByPathSubscriptionsMutex.lock();
        m_locationsByPathSubscriptions.push_back( pathSubscription {uriPathPart, onLocatedcallback} );
        m_locationsByPathSubscriptionsMutex.unlock();
    }

    void ResourceHub::SubscribeForClaimsByPath(const std::string& uriPathPart, const std::function<bool(Resource*)>& onClaimedcallback)
    {
        m_claimsByPathSubscriptionsMutex.lock();
        m_claimsByPathSubscriptions.push_back( pathSubscription {uriPathPart, onClaimedcallback});
        m_claimsByPathSubscriptionsMutex.unlock();
    }

    void ResourceHub::SubscribeForAvaialbilityByPath(const std::string& uriPathPart, const std::function<bool(Resource*)>& onAvailablecallback)
    {
        m_availabilityByPathSubscriptionsMutex.lock();
        m_availabilityByPathSubscriptions.push_back( pathSubscription {uriPathPart, onAvailablecallback});
        m_availabilityByPathSubscriptionsMutex.unlock();
    }

    void ResourceHub::SubscribeForRemovalByPath(const std::string& uriPathPart, const std::function<bool(Resource*)>& onRemovedcallback)
    {
        m_removalsByPathSubscriptionsMutex.lock();
        m_removalsByPathSubscriptions.push_back( pathSubscription {uriPathPart, onRemovedcallback});
        m_removalsByPathSubscriptionsMutex.unlock();
    }

    void ResourceHub::SubscribeForAllByPath(const std::string& uriPathPart, const std::function<bool(Resource*, ResourceStatus)>& onStatuscallback)
    {
        m_allByPathSubscriptionsMutex.lock();
        m_allByPathSubscriptions.push_back( pathallSubscription {uriPathPart, onStatuscallback});
        m_allByPathSubscriptionsMutex.unlock();
    }

    void ResourceHub::UpdateSubscribersToAll(Resource* res, ResourceStatus status, const std::string& uri, std::vector<pathallSubscription>& subs, std::recursive_mutex& mtx)
    {
        mtx.lock();

        for( auto it = subs.rbegin(); it != subs.rend();)
        {
            if(uri.find(it->first) != std::string::npos)
            {
                if(!it->second(res,status))
                {
                    it = decltype(it)(subs.erase( std::next(it).base()));
                }
                else
                {
                    ++it;
                }
            }
        }
        mtx.unlock();
    }

    void ResourceHub::UpdateByTypeSubscribersToAll(Resource* res, ResourceStatus status, const std::string& uri, std::vector<typeallSubscription>& subs, std::recursive_mutex& mtx)
    {
        mtx.lock();
        for(auto it = subs.rbegin(); it != subs.rend();)
        {
            if(res->Type() == it->first)
            {
                if(!it->second(res, status))
                {
                    it = decltype(it)(subs.erase(std::next(it).base()));
                }
                else
                {
                    ++it;
                }
            }
            else
            {
                ++it;
            }
        }
        mtx.unlock();
    }

    void ResourceHub::UpdateSubscribers(Resource* res, const std::string& uri, std::vector<pathSubscription>& subs, std::recursive_mutex& mtx)
    {
        mtx.lock();
        for( auto it = subs.rbegin(); it != subs.rend();)
        {
            if(uri.find(it->first) != std::string::npos)
            {
                if(!it->second(res))
                {
                    it = decltype(it)(subs.erase( std::next(it).base()));
                }
                else
                {
                    ++it;
                }
            }
            else
            {
                ++it;
            }
        }
        mtx.unlock();
    }

    void ResourceHub::UpdateByTypeSubscribers(Resource* res, std::vector<typeSubscription>& subs, std::recursive_mutex& mtx)
    {
        mtx.lock();
        for(auto it = subs.rbegin(); it != subs.rend();)
        {
            if(res->Type() == it->first)
            {
                if(!it->second(res))
                {
                    it = decltype(it)(subs.erase(std::next(it).base()));
                }
                else
                {
                    ++it;
                }
            }
            else
            {
                ++it;
            }
        }
        mtx.unlock();
    }

    bool ResourceHub::AdoptResource(Resource* res)
    {
        std::string uri = res->URI();
        if(res->Type() == res::Path::StaticType())
        {
            m_pathsMutex.lock();
            m_paths.emplace(uri, dynamic_cast<res::Path*>(res));
            m_pathsMutex.unlock();
            return true;
        }
        else if(res->Type() == res::File::StaticType())                    
        {
            m_filesMutex.lock();
            m_files.emplace(uri, dynamic_cast<res::File*>(res));
            m_filesMutex.unlock();
            return true;
        }
        else if(res->Type() == res::JSON::StaticType())
        {
            m_jsonMutex.lock();
            m_json.emplace(uri, dynamic_cast<res::JSON*>(res));
            m_jsonMutex.unlock();
            return true;
        }
        return false;
    }

    void ResourceHub::DisposeResource(Resource* res)
    {
        std::string uri = res->URI();
        if(res->Type() == res::Path::StaticType())
        {
            m_pathsMutex.lock();
            auto it = m_paths.find(uri);
            if(it != m_paths.end())
            {
                m_paths.erase(it);
            }
            m_pathsMutex.unlock();                        
        }
        else if(res->Type() == res::File::StaticType())
        {
            m_filesMutex.lock();
            auto it = m_files.find(uri);
            if(it != m_files.end())
            {
                m_files.erase(it);
            }
            m_filesMutex.unlock();
        }
        delete res;
    }

    void ResourceHub::OnNamed(Resource* res)
    {
        if(res)
        {
            std::string uri = res->URI();
            if(AdoptResource(res))
            {                
                //TODO: Get actual path part, dropping type.
                UpdateSubscribersToAll(res, Named, uri, m_allByPathSubscriptions, m_allByPathSubscriptionsMutex);
                UpdateSubscribers(res, uri, m_namesByPathSubscriptions, m_namesByPathSubscriptionsMutex);
                UpdateByTypeSubscribersToAll(res, Named, uri, m_allByTypeSubscriptions, m_allByTypeSubscriptionsMutex);
                UpdateByTypeSubscribers(res, m_namesByTypeSubscriptions, m_namesByTypeSubscriptionsMutex);
            }
            else
            {   
                std::string resType(res->Type());
                warning("Unknown resource {0} of type {1} will be deleted as no manager was found for it.", uri, resType);
                delete res;                
            }
        }
    }

    void ResourceHub::OnLocated(Resource* res)
    {
        if(res)
        {
            std::string uri = res->URI();            
            //TODO: Get actual path part, dropping type.
            UpdateSubscribersToAll(res, Located, uri, m_allByPathSubscriptions, m_allByPathSubscriptionsMutex);
            UpdateSubscribers(res, uri, m_locationsByPathSubscriptions, m_locationsByPathSubscriptionsMutex);
            UpdateByTypeSubscribersToAll(res, Located, uri, m_allByTypeSubscriptions, m_allByTypeSubscriptionsMutex);
            UpdateByTypeSubscribers(res, m_namesByTypeSubscriptions, m_namesByTypeSubscriptionsMutex);
        }
    }
    
    void ResourceHub::OnClaimed(Resource* res)
    {
        if(res)
        {
            std::string uri = res->URI();            
            //TODO: Get actual path part, dropping type.
            UpdateSubscribersToAll(res, Claimed, uri, m_allByPathSubscriptions, m_allByPathSubscriptionsMutex);
            UpdateSubscribers(res, uri, m_claimsByPathSubscriptions, m_claimsByPathSubscriptionsMutex);
            UpdateByTypeSubscribersToAll(res, Claimed, uri, m_allByTypeSubscriptions, m_allByTypeSubscriptionsMutex);
            UpdateByTypeSubscribers(res, m_namesByTypeSubscriptions, m_namesByTypeSubscriptionsMutex);
        }
    }

    void ResourceHub::OnAvailable(Resource* res)
    {
        if(res)
        {
            std::string uri = res->URI();            
            //TODO: Get actual path part, dropping type.
            UpdateSubscribersToAll(res, Available, uri, m_allByPathSubscriptions, m_allByPathSubscriptionsMutex);
            UpdateSubscribers(res, uri, m_availabilityByPathSubscriptions, m_availabilityByPathSubscriptionsMutex);
            UpdateByTypeSubscribersToAll(res, Available, uri, m_allByTypeSubscriptions, m_allByTypeSubscriptionsMutex);
            UpdateByTypeSubscribers(res, m_namesByTypeSubscriptions, m_namesByTypeSubscriptionsMutex);
        }
    }

    void ResourceHub::OnRemoved(Resource* res)
    {
        if(res)
        {
            std::string uri = res->URI();            
            //TODO: Get actual path part, dropping type.
            UpdateSubscribersToAll(res, Removed, uri, m_allByPathSubscriptions, m_allByPathSubscriptionsMutex);
            UpdateSubscribers(res, uri, m_removalsByPathSubscriptions, m_removalsByPathSubscriptionsMutex);
            UpdateByTypeSubscribersToAll(res, Removed, uri, m_allByTypeSubscriptions, m_allByTypeSubscriptionsMutex);
            UpdateByTypeSubscribers(res, m_namesByTypeSubscriptions, m_namesByTypeSubscriptionsMutex);
            DisposeResource(res);
        }
    }

}}//qor::framework