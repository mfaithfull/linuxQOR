
// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"
#include "src/framework/thread/currentthread.h"
#include "src/qor/reference/newref.h"
#include "ttfinitial.h"

using namespace qor::components::serial;

namespace qor { namespace framework { namespace res {

    TTFInitialState::TTFInitialState(Deserializer* deserializer) : workflow::State(deserializer), m_initialOffsetTable{0}, m_tableDirectory(nullptr), m_tableIndex(0)
    {
        Enter = [this]()
        {
            m_offsetTableState = new_ref<TTFOffsetTableState>(GetDeserializer(), &m_initialOffsetTable);
            Workflow()->PushState(m_offsetTableState);
        };

        Resume = [this]()
        {
            if(m_tableDirectory == nullptr)
            {
                m_tableDirectory = new table_directory[m_initialOffsetTable.numTables];
            }
            if(m_tableIndex < m_initialOffsetTable.numTables)
            {
                m_tableDirectory[m_tableIndex] = {0};
                Workflow()->PushState(
                    new_ref<TTFTableDirState>(GetDeserializer(), &m_tableDirectory[m_tableIndex]));
                m_tableIndex++;
            }
            else
            {
                Workflow()->SetState(new_ref<TTFBlobState>(GetDeserializer(), &m_blob));
            }
        };
        
    }

    TTFOffsetTableState::TTFOffsetTableState(Deserializer* deserializer, offset_subtable* ptd) :
        StructureDeserializer<offset_subtable>::base(deserializer, arch::Endian::big, ptd), m_initialOffsetTable(ptd)
    {
    }

    TTFTableDirState::TTFTableDirState(Deserializer* deserializer, table_directory* ptd) : 
        StructureDeserializer<table_directory>::base(deserializer, arch::Endian::big, ptd), m_tableDirectory(ptd)
    {
    }

    TTFBlobState::TTFBlobState(qor::components::serial::Deserializer* deserializer, std::vector<byte>* pv) : workflow::State(deserializer), m_blob(pv)
    {
        Enter = [this]()
        {            
            if(GetContext()->GetOctet(m_data))
            {
                m_blob->emplace_back(*m_data);
                GetContext()->ConsumeOctet();
            }
            else
            {
                Workflow()->PopState();
            }
        };
    }
    
}}}//qor::framework::res

/*
                if(m_tableIndex > 0)
                {
                    char tag[4];
                    memcpy(&tag[0], &m_tableDirectory[m_tableIndex-1].tag, 4);
                    if(strncmp("pamc", tag, 4) == 0)
                    {
                        //Set the read position via the context
                        //run the parser for the cmap table
                    }
                    else if(strncmp("GISD", tag, 4) == 0)
                    {                        
                        

                        GetContext()->SetPosition(m_tableDirectory[m_tableIndex].offset);
                        Workflow()->PushState(
                            new_ref<TTFGISDHeader>(GetDeserializer(), &m_gisd_header, return_pos)
                                components::serial::StructState<gsid_struct, 0, qor_reflection::detail::fields_count<std::remove_cvref_t<gsid_struct>>()>
                                >(GetDeserializer(), arch::Endian::big, &m_gsid_data));
                        
                    }
                }
*/