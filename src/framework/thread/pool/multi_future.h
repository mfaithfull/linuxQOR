// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_FRAMEWORK_THREADPOOL_MULTIFUTURE
#define QOR_PP_H_FRAMEWORK_THREADPOOL_MULTIFUTURE

namespace qor { namespace framework{

    //A helper template to facilitate waiting for and/or getting the results of multiple futures at once.
    template <typename T>
    class [[nodiscard]] multi_future : public std::vector<std::future<T>>
    {
    public:
        
        using std::vector<std::future<T>>::vector;      // Inherit all constructors from the base class `std::vector`

        //Get the results from all the futures stored in this `multi_future`, rethrowing any stored exceptions.
        //If the futures return `void`, this function returns `void` as well. Otherwise, it returns a vector containing the results.
        [[nodiscard]] std::conditional_t<std::is_void_v<T>, void, std::vector<T>> get()
        {
            if constexpr (std::is_void_v<T>)
            {
                for (std::future<T>& future : *this)
                    future.get();
                return;
            }
            else
            {
                std::vector<T> results;
                results.reserve(this->size());
                for (std::future<T>& future : *this)
                    results.push_back(future.get());
                return results;
            }
        }

        //Check how many of the futures stored in this `multi_future` are ready.
        //return The number of ready futures.
        [[nodiscard]] std::size_t ready_count() const
        {
            std::size_t count = 0;
            for (const std::future<T>& future : *this)
            {
                if (future.wait_for(std::chrono::duration<double>::zero()) == std::future_status::ready)
                    ++count;
            }
            return count;
        }

        //Check if all the futures stored in this `multi_future` are valid.
        //return `true` if all futures are valid, `false` if at least one of the futures is not valid.
        [[nodiscard]] bool valid() const noexcept
        {
            bool is_valid = true;
            for (const std::future<T>& future : *this)
            {
                is_valid = is_valid && future.valid();
            }
            return is_valid;
        }

        //Wait for all the futures stored in this `multi_future`.
        void wait() const
        {
            for (const std::future<T>& future : *this)
            {
                future.wait();
            }
        }

        //Wait for all the futures stored in this `multi_future`, but stop waiting after the specified duration has passed. This function first waits for the first future for the desired duration. If that future is ready before the duration expires, this function waits for the second future for whatever remains of the duration. It continues similarly until the duration expires.
        //R An arithmetic type representing the number of ticks to wait.
        //P A `std::ratio` representing the length of each tick in seconds.
        //return `true` if all futures have been waited for before the duration expired, `false` otherwise.
        template <typename R, typename P>
        bool WaitFor(const std::chrono::duration<R, P>& duration) const
        {
            const std::chrono::time_point<std::chrono::steady_clock> start_time = std::chrono::steady_clock::now();
            for (const std::future<T>& future : *this)
            {
                future.wait_for(duration - (std::chrono::steady_clock::now() - start_time));
                if (duration < std::chrono::steady_clock::now() - start_time)
                {
                    return false;
                }
            }
            return true;
        }

        //Wait for all the futures stored in this `multi_future`, but stop waiting after the specified time point has been reached. This function first waits for the first future until the desired time point. If that future is ready before the time point is reached, this function waits for the second future until the desired time point. It continues similarly until the time point is reached.
        //C The type of the clock used to measure time.
        //D An `std::chrono::duration` type used to indicate the time point.
        //timeout_time The time point at which to stop waiting.
        //return `true` if all futures have been waited for before the time point was reached, `false` otherwise.
        template <typename C, typename D>
        bool WaitUntil(const std::chrono::time_point<C, D>& timeout_time) const
        {
            for (const std::future<T>& future : *this)
            {
                future.WaitUntil(timeout_time);
                if (timeout_time < std::chrono::steady_clock::now())
                {
                    return false;
                }
            }
            return true;
        }

    };
    
}}//qor::framework

#endif//QOR_PP_H_FRAMEWORK_THREADPOOL_MULTIFUTURE
