// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_FRAMEWORK_THREADPOOL_COUNTINGSEMPHORE
#define QOR_PP_H_FRAMEWORK_THREADPOOL_COUNTINGSEMPHORE

    //inline header. Must be included within qor::framework namespace

    //A polyfill for `std::counting_semaphore`, to be used if C++20 features are not available. A `counting_semaphore` is a synchronization primitive that allows more than one concurrent access to the same resource. The number of concurrent accessors is limited by the semaphore's counter, which is decremented when a thread acquires the semaphore and incremented when a thread releases the semaphore. If the counter is zero, a thread trying to acquire the semaphore will be blocked until another thread releases the semaphore.
    // LeastMaxValue The least maximum value of the counter. (In this implementation, it is also the actual maximum value.)
    template <std::ptrdiff_t LeastMaxValue = std::numeric_limits<std::ptrdiff_t>::max()>
    class [[nodiscard]] counting_semaphore
    {
        static_assert(LeastMaxValue >= 0, "The least maximum value for a counting semaphore must not be negative.");

    public:

        //Construct a new counting semaphore with the given initial counter value.
        // desired The initial counter value.
        constexpr explicit counting_semaphore(const std::ptrdiff_t desired) : counter(desired) {}

        // The copy and move constructors and assignment operators are deleted. The semaphore cannot be copied or moved.
        counting_semaphore(const counting_semaphore&) = delete;
        counting_semaphore(counting_semaphore&&) = delete;
        counting_semaphore& operator=(const counting_semaphore&) = delete;
        counting_semaphore& operator=(counting_semaphore&&) = delete;
        ~counting_semaphore() = default;

        // Returns the internal counter's maximum possible value, which in this implementation is equal to `LeastMaxValue`.
        [[nodiscard]] static constexpr std::ptrdiff_t max() noexcept
        {
            return LeastMaxValue;
        }

        //Atomically decrements the internal counter by 1 if it is greater than 0; otherwise blocks until it is greater than 0 and can successfully decrement the internal counter.
        void acquire()
        {
            std::unique_lock lock(mutex);
            cv.wait(lock,
                [this]
                {
                    return counter > 0;
                });
            --counter;
        }

        //Atomically increments the internal counter. Any thread(s) waiting for the counter to be greater than 0, such as due to being blocked in `acquire()`, will subsequently be unblocked.
        //update The amount to increment the internal counter by. Defaults to 1.
        void release(const std::ptrdiff_t update = 1)
        {
            {
                const std::scoped_lock lock(mutex);
                counter += update;
            }
            cv.notify_all();
        }

        //Tries to atomically decrement the internal counter by 1 if it is greater than 0; no blocking occurs regardless.
        //return `true` if decremented the internal counter, `false` otherwise.
        bool try_acquire()
        {
            std::scoped_lock lock(mutex);
            if (counter > 0)
            {
                --counter;
                return true;
            }
            return false;
        }

        // Tries to atomically decrement the internal counter by 1 if it is greater than 0; otherwise blocks until it is greater than 0 and can successfully decrement the internal counter, or the `rel_time` duration has been exceeded.
        // Rep An arithmetic type representing the number of ticks to wait.
        // Period An `std::ratio` representing the length of each tick in seconds.
        // rel_time The duration the function must wait. Note that the function may wait for longer.
        // return `true` if decremented the internal counter, `false` otherwise.
        template <class Rep, class Period>
        bool try_acquire_for(const std::chrono::duration<Rep, Period>& rel_time)
        {
            std::unique_lock lock(mutex);
            if (!cv.wait_for(lock, rel_time,
                    [this]
                    {
                        return counter > 0;
                    }))
                return false;
            --counter;
            return true;
        }

        // Tries to atomically decrement the internal counter by 1 if it is greater than 0; otherwise blocks until it is greater than 0 and can successfully decrement the internal counter, or the `abs_time` time point has been passed.
        // Clock The type of the clock used to measure time.
        // Duration An `std::chrono::duration` type used to indicate the time point.
        // abs_time The earliest time the function must wait until. Note that the function may wait for longer.
        // `true` if decremented the internal counter, `false` otherwise.
        template <class Clock, class Duration>
        bool try_acquire_until(const std::chrono::time_point<Clock, Duration>& abs_time)
        {
            std::unique_lock lock(mutex);
            if (!cv.wait_until(lock, abs_time,
                    [this]
                    {
                        return counter > 0;
                    }))
                return false;
            --counter;
            return true;
        }

    private:

        std::ptrdiff_t counter;         //The semaphore's counter.
        std::condition_variable cv;     //A condition variable used to wait for the counter.
        mutable std::mutex mutex;       //A mutex used to synchronize access to the counter.
    };
 
    //A polyfill for `std::binary_semaphore`, to be used if C++20 features are not available.
    using binary_semaphore = counting_semaphore<1>;

#endif//QOR_PP_H_FRAMEWORK_THREADPOOL_COUNTINGSEMPHORE
