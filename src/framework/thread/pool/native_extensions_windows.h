// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_FRAMEWORK_THREADPOOL_NATIVEEXTENSIONS_WINDOWS
#define QOR_PP_H_FRAMEWORK_THREADPOOL_NATIVEEXTENSIONS_WINDOWS

#include <windows.h>
#undef min
#undef max

namespace qor { namespace framework{

    //An enum containing pre-defined OS-specific process priority values for portability.
    enum class os_process_priority
    {
        idle = IDLE_PRIORITY_CLASS,
        below_normal = BELOW_NORMAL_PRIORITY_CLASS,
        normal = NORMAL_PRIORITY_CLASS,
        above_normal = ABOVE_NORMAL_PRIORITY_CLASS,
        high = HIGH_PRIORITY_CLASS,
        realtime = REALTIME_PRIORITY_CLASS
    };

    //An enum containing pre-defined OS-specific thread priority values for portability.

    enum class os_thread_priority
    {
        idle = THREAD_PRIORITY_IDLE,
        lowest = THREAD_PRIORITY_LOWEST,
        below_normal = THREAD_PRIORITY_BELOW_NORMAL,
        normal = THREAD_PRIORITY_NORMAL,
        above_normal = THREAD_PRIORITY_ABOVE_NORMAL,
        highest = THREAD_PRIORITY_HIGHEST,
        realtime = THREAD_PRIORITY_TIME_CRITICAL
    };

    //Get the processor affinity of the current process using the current platform's native API. This should work on Windows and Linux, but is not possible on macOS as the native API does not allow it.
    //return An `std::optional` object, optionally containing the processor affinity of the current process as an `std::vector<bool>` where each element corresponds to a logical processor. If the returned object does not contain a value, then the affinity could not be determined. On macOS, this function always returns `std::nullopt`.

    [[nodiscard]] inline std::optional<std::vector<bool>> get_os_process_affinity()
    {
        DWORD_PTR process_mask = 0;
        DWORD_PTR system_mask = 0;
        if (GetProcessAffinityMask(GetCurrentProcess(), &process_mask, &system_mask) == 0)
            return std::nullopt;
    #ifdef __cpp_lib_int_pow2
        const std::size_t num_cpus = static_cast<std::size_t>(std::bit_width(system_mask));
    #else
        std::size_t num_cpus = 0;
        if (system_mask != 0)
        {
            num_cpus = 1;
            while ((system_mask >>= 1U) != 0U)
                ++num_cpus;
        }
    #endif
        std::vector<bool> affinity(num_cpus);
        for (std::size_t i = 0; i < num_cpus; ++i)
            affinity[i] = ((process_mask & (1ULL << i)) != 0ULL);
        return affinity;     
    }

    //Set the processor affinity of the current process using the current platform's native API. This should work on Windows and Linux, but is not possible on macOS as the native API does not allow it.
    //affinity The processor affinity to set, as an `std::vector<bool>` where each element corresponds to a logical processor.
    //return `true` if the affinity was set successfully, `false` otherwise. On macOS, this function always returns `false`.
    inline bool set_os_process_affinity(const std::vector<bool>& affinity)
    {
        DWORD_PTR process_mask = 0;
        for (std::size_t i = 0; i < std::min<std::size_t>(affinity.size(), sizeof(DWORD_PTR) * 8); ++i)
            process_mask |= (affinity[i] ? (1ULL << i) : 0ULL);
        return SetProcessAffinityMask(GetCurrentProcess(), process_mask) != 0;
    }

    //Get the priority of the current process using the current platform's native API. This should work on Windows, Linux, and macOS.
    //return An `std::optional` object, optionally containing the priority of the current process, as a member of the enum `os_process_priority`. If the returned object does not contain a value, then either the priority could not be determined, or it is not one of the pre-defined values and therefore cannot be represented in a portable way.
    [[nodiscard]] inline std::optional<os_process_priority> get_os_process_priority()
    {
        const DWORD priority = GetPriorityClass(GetCurrentProcess());
        if (priority == 0)
            return std::nullopt;
        return static_cast<os_process_priority>(priority);
    }

    //Set the priority of the current process using the current platform's native API. This should work on Windows, Linux, and macOS. However, note that higher priorities might require elevated permissions.
    //priority The priority to set. Must be a value from the enum `os_process_priority`.
    //return `true` if the priority was set successfully, `false` otherwise. Usually, `false` means that the user does not have the necessary permissions to set the desired priority.

    inline bool set_os_process_priority(const os_process_priority priority)
    {
        return SetPriorityClass(GetCurrentProcess(), static_cast<DWORD>(priority)) != 0;
    }

}}//qor::framework

#endif//QOR_PP_H_FRAMEWORK_THREADPOOL_NATIVEEXTENSIONS_WINDOWS
