// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

/***********************************************************************
*
* Copyright (c) 2016-2021 Barbara Geller
* Copyright (c) 2016-2021 Ansel Sermersheim
*
* This file is part of CsSignal.
*
* CsSignal is free software, released under the BSD 2-Clause license.
* For license details refer to LICENSE provided with this project.
*
* CopperSpice is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
*
* https://opensource.org/licenses/BSD-2-Clause
*
***********************************************************************/

#ifndef QOR_PP_H_DOSIGNAL
#define QOR_PP_H_DOSIGNAL

#include "src/qor/memory/memory.h"
#include "signalbase.h"
#include "pendingslot.h"
#include "slotbase.h"

namespace qor
{
    template<class Sender, class SignalClass, class ...SignalArgTypes, class ...Ts>
    void activate(Sender& sender, void (SignalClass::* signal)(SignalArgTypes...), Ts &&... Vs)
    {
        // ensure signal args are passed
        static_assert(std::is_convertible<std::tuple<Ts...>, std::tuple<SignalArgTypes...>>::value, "activate():  Signal parameter mismatch.");

        detail::Bento<void (SignalClass::*)(SignalArgTypes...)> signal_Bento(signal);

        // save the addresss of sender
        const SignalBase* senderPtr = &sender;

        // store the signal data, false indicates the data will not be copied
        detail::TeaCup_Data<SignalArgTypes...> dataPack(false, std::forward<Ts>(Vs)...);

        SignalBase* priorSender = SlotBase::get_threadLocal_currentSender();
        SlotBase::get_threadLocal_currentSender() = &sender;

        detail::BentoAbstract* priorSignal = SignalBase::get_threadLocal_currentSignal();
        SignalBase::get_threadLocal_currentSignal() = &signal_Bento;

        // threading and queuedConnections
        auto senderListHandle = sender.m_connectList.lock_read();

        for (const auto& connection : *senderListHandle) 
        {

            if (*(connection.signalMethod) != signal_Bento) 
            {
                // no match in connectionList for this signal
                continue;
            }

            SlotBase* receiver = const_cast<SlotBase*>(connection.receiver);

            // const reference to a unique ptr
            const std::unique_ptr<const detail::BentoAbstract/*, qor_std_deleter<const detail::BentoAbstract>*/ >& slot_Bento = connection.slotMethod;

            bool receiverInSameThread = receiver->compareThreads();

            int old_activateBusy = sender.m_activateBusy;
            sender.m_activateBusy++;

            try 
            {

                if ((connection.type == ConnectionKind::AutoConnection && !receiverInSameThread) || (connection.type == ConnectionKind::QueuedConnection)) 
                {
                    // passing true indicates the data will be copied (stored on the heap)
                    PendingSlot tempObj(
                        &sender, 
                        signal_Bento.clone(), 
                        receiver, 
                        slot_Bento->clone(),
                        std::make_unique< detail::TeaCup_Data<SignalArgTypes...> >(true, std::forward< Ts >(Vs)...) );

                    receiver->queueSlot(std::move(tempObj), ConnectionKind::QueuedConnection);

                }
                else if (connection.type == ConnectionKind::BlockingQueuedConnection) 
                {

                    // passing false indicates the data will not be copied
                    PendingSlot tempObj(&sender, signal_Bento.clone(), receiver, slot_Bento->clone(),
                    std::make_unique<detail::TeaCup_Data<SignalArgTypes...>>(false, std::forward<Ts>(Vs)...));

                    receiver->queueSlot(std::move(tempObj), ConnectionKind::BlockingQueuedConnection);

                }
                else if (connection.type == ConnectionKind::DirectConnection || connection.type == ConnectionKind::AutoConnection) 
                {
                    // direct connection

                    // invoke calls the actual method
                    slot_Bento->invoke(receiver, &dataPack);
                }

                std::lock_guard<std::mutex> lock(SignalBase::get_mutex_beingDestroyed());   // should be a read lock

                if (SignalBase::get_beingDestroyed().count(senderPtr)) 
                {
                    // sender has been destroyed
                    SlotBase::get_threadLocal_currentSender() = priorSender;
                    SignalBase::get_threadLocal_currentSignal() = priorSignal;

                    if (old_activateBusy == 0) 
                    {
                        SignalBase::get_beingDestroyed().erase(senderPtr);
                    }

                    return;
                }

            }
            catch (...) 
            {
                SlotBase::get_threadLocal_currentSender() = priorSender;
                SignalBase::get_threadLocal_currentSignal() = priorSignal;

                std::lock_guard<std::mutex> lock(SignalBase::get_mutex_beingDestroyed());   // should be a read lock

                if (SignalBase::get_beingDestroyed().count(senderPtr)) {
                    // sender has been destroyed, all done

                    if (old_activateBusy == 0) {
                        SignalBase::get_beingDestroyed().erase(senderPtr);
                    }

                    return;

                }
                else 
                {
                    sender.handleException(std::current_exception());
                    SlotBase::get_threadLocal_currentSender() = &sender;
                }
            }

            try 
            {
                sender.m_activateBusy--;

            }
            catch (std::exception&) 
            {
                SlotBase::get_threadLocal_currentSender() = priorSender;
                SignalBase::get_threadLocal_currentSignal() = priorSignal;

                std::throw_with_nested(std::invalid_argument("activate(): Failed to obtain sender lock"));
            }
        }

        SlotBase::get_threadLocal_currentSender() = priorSender;
        SignalBase::get_threadLocal_currentSignal() = priorSignal;
    }

    // signal & slot method ptr
    template<class Sender, class SignalClass, class ...SignalArgs, class Receiver, class SlotClass, class ...SlotArgs, class SlotReturn>
    bool connect(const Sender& sender, void (SignalClass::* signalMethod)(SignalArgs...), const Receiver& receiver, SlotReturn(SlotClass::* slotMethod)(SlotArgs...), ConnectionKind type, bool uniqueConnection)
    {

        /* is the sender an rvalue reference
           static_assert(! std::is_rvalue_reference<Sender &&>::value,
                          "connect():  Sender can not be an rvalue");

           is the receiver an rvalue reference
           static_assert(! std::is_rvalue_reference<Receiver &&>::value,
                          "connect():  Receiver can not be an rvalue");
        */

        // (1) Sender must be the same class as SignalClass OR (2) Sender is a child of SignalClass
        static_assert(std::is_base_of<SignalClass, Sender>::value, "connect():  Signal was not a child class of Sender");

        // (1) Receiver must be the same class as SlotClass OR (2) Receiver is a child of SlotClass
        static_assert(std::is_base_of<SlotClass, Receiver>::value, "connect():  Slot was not a child class of Receiver");

        // compare signal and slot paramerter list
        static_assert(detail::cs_check_connect_args<void (*)(SignalArgs...), void (*)(SlotArgs...) >::value, "connect():  Incompatible signal/slot arguments");

        if (signalMethod == nullptr) 
        {
            throw std::invalid_argument("connect() Can not connect, signal is null");
        }

        if (slotMethod == nullptr) 
        {
            throw std::invalid_argument("connect(): Can not connect, slot is null");
        }

        std::unique_ptr<detail::Bento<void (SignalClass::*)(SignalArgs...)>/*, qor_std_deleter<detail::Bento<void (SignalClass::*)(SignalArgs...)> >*/>
                  signalMethod_Bento(new detail::Bento<void (SignalClass::*)(SignalArgs...)>(signalMethod));

        std::unique_ptr<detail::Bento<SlotReturn (SlotClass::*)(SlotArgs...)>/*, qor_std_deleter<detail::Bento<SlotReturn (SlotClass::*)(SlotArgs...)> >*/>
                  slotMethod_Bento(new detail::Bento<SlotReturn (SlotClass::*)(SlotArgs...)>(slotMethod));

        /*std::unique_ptr<detail::Bento<void (SignalClass::*)(SignalArgs...)>, qor_std_deleter<detail::Bento<void (SignalClass::*)(SignalArgs...)> > > signalMethod_Bento(
            reinterpret_cast<detail::Bento<void (SignalClass::*)(SignalArgs...)>>(source_of< detail::Bento<void (SignalClass::*)(SignalArgs...)> >::type::Source(sizeof(signalMethod))));

        std::unique_ptr<detail::Bento<SlotReturn(SlotClass::*)(SlotArgs...)>, qor_std_deleter<detail::Bento<SlotReturn(SlotClass::*)(SlotArgs...)> > > slotMethod_Bento(
            reinterpret_cast<detail::Bento<SlotReturn(SlotClass::*)(SlotArgs...)>>(source_of< detail::Bento<SlotReturn(SlotClass::*)(SlotArgs...)> >::type::Source(sizeof(slotMethod))));
        */
        auto senderListHandle = sender.m_connectList.lock_write();

        if (uniqueConnection) 
        {
            // ensure the connection is not added twice
            for (auto& item : *senderListHandle) 
            {

                if (item.receiver != &receiver) 
                {
                    continue;
                }

                if (*(item.signalMethod) != *(signalMethod_Bento)) 
                {
                    continue;
                }

                if (*(item.slotMethod) != *(slotMethod_Bento)) 
                {
                    continue;
                }

                // connection already exists
                return false;
            }
        }

        sender.addConnection(std::move(signalMethod_Bento), &receiver, std::move(slotMethod_Bento), type, senderListHandle);

        return true;
    }

    // signal method ptr, slot lambda
    template<class Sender, class SignalClass, class ...SignalArgs, class Receiver, class T>
    bool connect(const Sender& sender, void (SignalClass::* signalMethod)(SignalArgs...), const Receiver& receiver, T slotLambda, ConnectionKind type, bool uniqueConnection)
    {
        // Sender must be the same class as SignalClass and Sender is a child of SignalClass
        detail::cs_testConnect_SenderSignal<Sender, SignalClass>();

        // compare signal and slot paramerter list
        detail::cs_testConnect_SignalSlotArgs_1<T, SignalArgs...>();

        if (signalMethod == nullptr) 
        {
            throw std::invalid_argument("connect(): Can not connect, signal is null");
        }

        std::unique_ptr<detail::Bento<void (SignalClass::*)(SignalArgs...)>/*, qor_std_deleter<detail::Bento<void (SignalClass::*)(SignalArgs...)> >*/>
        signalMethod_Bento(new detail::Bento<void (SignalClass::*)(SignalArgs...)>(signalMethod));

        std::unique_ptr<detail::Bento<T>/*, qor_std_deleter<detail::Bento<T> >*/> slotLambda_Bento(new detail::Bento<T>(slotLambda));        
        /*
        std::unique_ptr< detail::Bento<void (SignalClass::*)(SignalArgs...)>, qor_std_deleter<detail::Bento<void (SignalClass::*)(SignalArgs...)> > >
            signalMethod_Bento(
                allocator_of< detail::Bento<void (SignalClass::*)(SignalArgs...)> >::type::template Allocate< detail::Bento<void (SignalClass::*)(SignalArgs...)> >(1, signalMethod)
            );

        std::unique_ptr<detail::Bento<T>, qor_std_deleter<detail::Bento<T> > >
            slotLambda_Bento(
                allocator_of< detail::Bento<T> >::type::template Allocate< detail::Bento<T> >(1, slotLambda)
            );
        */
        auto senderListHandle = sender.m_connectList.lock_write();

        if (uniqueConnection) 
        {
            // ensure the connection is not added twice
            for (auto& item : *senderListHandle) 
            {
                if (item.receiver != &receiver) 
                {
                    continue;
                }

                if (*(item.signalMethod) != *(signalMethod_Bento)) 
                {
                    continue;
                }

                // unable to test if the passed slotLambda = slotLambda_Bento

                // connection already exists
                return false;
            }
        }

        sender.addConnection(
            std::move(signalMethod_Bento), 
            &receiver, 
            std::move(slotLambda_Bento), 
            type, 
            senderListHandle);

        return true;
    }

    // signal & slot bento
    template<class Sender, class Receiver>
    bool connect(const Sender& sender, std::unique_ptr<detail::BentoAbstract/*, qor_std_deleter<detail::BentoAbstract>*/ > signalMethod_Bento, const Receiver& receiver, std::unique_ptr<detail::BentoAbstract/*, qor_std_deleter<detail::BentoAbstract>*/ > slotMethod_Bento, ConnectionKind type, bool uniqueConnection)
    {
        auto senderListHandle = sender.m_connectList.lock_write();

        if (uniqueConnection) 
        {
            // ensure the connection is not added twice
            for (const auto& item : *senderListHandle) 
            {
                if (item.receiver != &receiver) 
                {
                    continue;
                }

                if (*(item.signalMethod) != *(signalMethod_Bento)) 
                {
                    continue;
                }

                if (*(item.slotMethod) != *(slotMethod_Bento)) 
                {
                    continue;
                }

                // connection already exists
                return false;
            }
        }

        sender.addConnection(std::move(signalMethod_Bento), &receiver, std::move(slotMethod_Bento), type, senderListHandle);

        return true;
    }

    // signal & slot method ptr
    template<class Sender, class SignalClass, class ...SignalArgs, class Receiver, class SlotClass, class ...SlotArgs, class SlotReturn>
    bool disconnect(const Sender& sender, void (SignalClass::* signalMethod)(SignalArgs...), const Receiver& receiver, SlotReturn(SlotClass::* slotMethod)(SlotArgs...))
    {
        // Sender must be the same class as SignalClass and Sender is a child of SignalClass
        detail::cs_testConnect_SenderSignal<Sender, SignalClass>();

        // Receiver must be the same class as SlotClass and Receiver is a child of SlotClass
        detail::cs_testConnect_ReceiverSlot<SlotClass, Receiver>();

        // signal & slot arguments do not agree
        detail::cs_testConnect_SignalSlotArgs_2< void (*)(SignalArgs...), void (*)(SlotArgs...) >();

        detail::Bento<void (SignalClass::*)(SignalArgs...)> signalMethod_Bento(signalMethod);
        detail::Bento<SlotReturn(SlotClass::*)(SlotArgs...)> slotMethod_Bento(slotMethod);

        if (!internal_disconnect(sender, &signalMethod_Bento, &receiver, &slotMethod_Bento)) 
        {
            return false;
        }

        return true;
    }

    // signal method ptr, slot lambda or function ptr
    template<class Sender, class SignalClass, class ...SignalArgs, class Receiver, class T>
    bool disconnect(const Sender& sender, void (SignalClass::* signalMethod)(SignalArgs...), const Receiver& receiver, T slotMethod)
    {
        // lambda, compile error
        static_assert(std::is_convertible<decltype(slotMethod == slotMethod), bool>::value, "disconnect():  Slot argument invalid or calling disconnect using a lambda");

        // function ptr
        detail::Bento<void (SignalClass::*)(SignalArgs...)> signalMethod_Bento(signalMethod);
        detail::Bento<T> slotMethod_Bento(slotMethod);

        if (!internal_disconnect(sender, &signalMethod_Bento, &receiver, &slotMethod_Bento)) 
        {
            return false;
        }

        return true;
    }

    // signal & slot bento objects
    template<class Sender, class Receiver>
    bool internal_disconnect(const Sender& sender, const detail::BentoAbstract* signalBento, const Receiver* receiver, const detail::BentoAbstract* slotBento)
    {
        bool retval = false;
        auto senderListHandle = sender.m_connectList.lock_write();

        for (auto iter = senderListHandle->begin(); iter != senderListHandle->end(); ++iter) 
        {
            const SignalBase::ConnectStruct& temp = *iter;
            bool isMatch = false;

            if (signalBento == nullptr && receiver == nullptr) 
            {
                // delete all connections in Sender
                isMatch = true;

            }
            else if (receiver != nullptr) 
            {
                if (receiver == temp.receiver) 
                {
                    if (signalBento == nullptr && (slotBento == nullptr || *slotBento == *temp.slotMethod)) 
                    {
                        isMatch = true;

                    }
                    else if (signalBento != nullptr && *signalBento == *temp.signalMethod && (slotBento == nullptr || *slotBento == *temp.slotMethod)) 
                    {
                        isMatch = true;
                    }
                }

            }
            else if (signalBento != nullptr) 
            {
                // receiver must be null therefore slot is null
                if (*signalBento == *temp.signalMethod) 
                {
                    isMatch = true;
                }
            }

            if (isMatch) 
            {
                // delete possible sender in the receiver
                retval = true;
                // lock temp.receiver and erase
                auto receiverListHandle = temp.receiver->m_possibleSenders.lock_write();
                receiverListHandle->erase(find(receiverListHandle->begin(), receiverListHandle->end(), &sender));
                // delete conneciton in sender
                senderListHandle->erase(iter);
            }
        }

        return retval;
    }

}//qor

#endif//QOR_PP_H_DOSIGNAL
