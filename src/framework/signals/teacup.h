// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

/***********************************************************************
*
* Copyright (c) 2016-2021 Barbara Geller
* Copyright (c) 2016-2021 Ansel Sermersheim
*
* This file is part of CsSignal.
*
* CsSignal is free software, released under the BSD 2-Clause license.
* For license details refer to LICENSE provided with this project.
*
* CopperSpice is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
*
* https://opensource.org/licenses/BSD-2-Clause
*
***********************************************************************/

#ifndef QOR_PP_H_SIGNALS_TEACUP
#define QOR_PP_H_SIGNALS_TEACUP

#include <type_traits>
#include <functional>

#include "src/platform/compiler/compiler.h"
#include "src/qor/memory/memory.h"
#include "internal.h"

namespace qor{ namespace detail{

    // ** class used to store slot data in a tuple
    class TeaCupAbstract
    {
    public:
        virtual ~TeaCupAbstract() {}
    };

    template<class ...Ts>
    class TeaCup : public TeaCup< typename removeLastType<Ts...>::type>
    {
    public:
        template<class T>
        explicit TeaCup(T lambda);
        virtual ~TeaCup() {}
        std::tuple<Ts...> getData() const;

    private:
        std::function<std::tuple<Ts...>()> m_lambda;
    };

    template<class ...Ts>
    template<class T>
    TeaCup<Ts...>::TeaCup(T lambda) : TeaCup< typename removeLastType<Ts...>::type >( [this]() { 
            return funcRemoveData(m_lambda()); 
        }), 
        m_lambda(std::move(lambda)){}

    template<class ...Ts>
    std::tuple<Ts...> TeaCup<Ts...>::getData() const
    {
        return m_lambda();
    }

    // 2  specialization for no args
    template<>
    class TeaCup<> : public TeaCupAbstract
    {
    public:
        template<class T>
        explicit TeaCup(T lambda);
        virtual ~TeaCup() {}
        std::tuple<> getData() const;
    };

    template<class T>
    TeaCup<>::TeaCup(T){}

    inline std::tuple<> TeaCup<>::getData() const
    {
        // empty tuple
        return std::tuple<> {};
    }

    // 3  specialization, tuple with args
    template<class ...Ts>
    class TeaCup< std::tuple<Ts...> > : public TeaCup<Ts...>
    {
    public:
        template<class T>
        explicit TeaCup(T lambda);
    };

    template<class ...Ts>
    template<class T>
    TeaCup<std::tuple<Ts...>>::TeaCup(T lambda) : TeaCup<Ts...>(std::move(lambda)){}

    // ** template functions use Index_Sequence to convert a tuple to R

    template<class R, class T, size_t ...Ks>
    R convert_tuple_internal(T& data, std::index_sequence<Ks...>)
    {
        return R{ std::get<Ks>(data)... };
    }

    template<class R, class ...Ts>
    R convert_tuple(std::tuple<Ts...>& data)
    {
        return convert_tuple_internal<R>(data, std::index_sequence_for<Ts...> {});
    }

    // ** templated class, used to store data for signals

    template<class ...Ts>
    class TeaCup_Data : public TeaCup<Ts...>
    {
    public:
        TeaCup_Data(bool needs_copying, Ts...);
        virtual ~TeaCup_Data() {}
        std::tuple<Ts...> getData() const;

    private:
        std::shared_ptr< std::tuple<typename std::remove_reference<Ts>::type...> > m_copyOfData;
        std::tuple<Ts...> m_data;
    };

    template<class ...Ts>
    TeaCup_Data<Ts...>::TeaCup_Data(bool needs_copying, Ts...Vs) : TeaCup<Ts...>( [this]() { return m_data; } ),
     m_copyOfData(needs_copying ? new std::tuple<typename std::remove_reference<Ts>::type...> (Vs...) : nullptr),
     m_data(needs_copying ? convert_tuple<std::tuple<Ts...>> (*m_copyOfData) : std::tuple<Ts...> (Vs...) ){}

    template<class ...Ts>
    std::tuple<Ts...> TeaCup_Data<Ts...>::getData() const
    {
        return m_data;
    }

}}//qor::detail

#endif//QOR_PP_H_SIGNALS_TEACUP