// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

/***********************************************************************
*
* Copyright (c) 2016-2021 Barbara Geller
* Copyright (c) 2016-2021 Ansel Sermersheim
*
* This file is part of CsSignal.
*
* CsSignal is free software, released under the BSD 2-Clause license.
* For license details refer to LICENSE provided with this project.
*
* CopperSpice is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
*
* https://opensource.org/licenses/BSD-2-Clause
*
***********************************************************************/

#ifndef QOR_PP_H_SIGNALS_INTERNAL
#define QOR_PP_H_SIGNALS_INTERNAL

#include "src/platform/compiler/compiler.h"

namespace qor{
    
    class SlotBase;

    namespace detail
    {        
        template<class T, class U, class = void>
        class cs_check_connect_args : public cs_check_connect_args<T, decltype(&U::operator())>
        {
        };

        // 2 slot is a func ptr, first signal and first slot parameters match
        template<class T, class ...ArgsX, class ...ArgsY>
        class cs_check_connect_args<void (*)(T, ArgsX...), void (*)(T, ArgsY...)> : public cs_check_connect_args<void (*) (ArgsX...), void (*) (ArgsY...)>
        {
        };

        //  slot is a func ptr, slot has no parameters
        template<class ...ArgsX>
        class cs_check_connect_args<void (*)(ArgsX...), void (*)()> : public std::integral_constant<bool, true>
        {
        };

        //  slot is a func ptr, signal has the same number of parms as the slot, types mismatch
        template<class ...ArgsX, class ...ArgsY>
        class cs_check_connect_args < void (*)(ArgsX...), void (*)(ArgsY...), typename std::enable_if< sizeof...(ArgsX) == sizeof...(ArgsY) && !std::is_same<std::tuple<ArgsX...>, std::tuple<ArgsY...>>::value >::type> : public std::integral_constant<bool, false>
        {
        };

        //  slot is a func ptr, signal has fewer number of parms than the slot
        template<class ...ArgsX, class ...ArgsY>
        class cs_check_connect_args < void (*)(ArgsX...), void (*)(ArgsY...), typename std::enable_if<sizeof...(ArgsX) < sizeof...(ArgsY) > ::type > : public std::integral_constant<bool, false>
        {
        };

        // 3 slot is a method ptr
        template<class T, class...ArgsX, class...ArgsY>
        class cs_check_connect_args<void (*)(ArgsX...), void (T::*)(ArgsY...) > : public cs_check_connect_args<void (*)(ArgsX...), void (*) (ArgsY...)>
        {
        };

        //  slot is a const method ptr
        template<class T, class...ArgsX, class...ArgsY>
        class cs_check_connect_args<void (*)(ArgsX...), void (T::*)(ArgsY...) const> : public cs_check_connect_args<void (*)(ArgsX...), void (*) (ArgsY...)>
        {
        };


        // compile time tests

        template<class Sender, class SignalClass>
        void cs_testConnect_SenderSignal()
        {
            static_assert(std::is_base_of<SignalClass, Sender>::value, "Signal is not defined in the sender class");
        }

        template<class Slot_LambdaType, class ...SignalArgs>
        void cs_testConnect_SignalSlotArgs_1()
        {
            static_assert(cs_check_connect_args<void (*)(SignalArgs...), Slot_LambdaType>::value, "Incompatible signal/slot arguments");
        }

        template<class SlotClass, class Receiver>
        void cs_testConnect_ReceiverSlot()
        {
            static_assert(std::is_base_of<SlotClass, Receiver>::value, "Slot is not defined in the receiver class");
        }

        template<class Signal_ArgType, class Slot_ArgType>
        void cs_testConnect_SignalSlotArgs_2()
        {
            static_assert(cs_check_connect_args<Signal_ArgType, Slot_ArgType>::value, "Incompatible signal/slot arguments");
        }

        // marker for a function which returns a void
        class CSVoidReturn
        {
        };


        // ** unpack_function   (1)
        // ** index_sequence unpacks a tuple into arguments for function pointer

        template< typename ...FunctionArgTypes, typename FunctionReturn, typename ...TupleTypes, size_t ...Ks >
        FunctionReturn cs_unpack_function_args_internal(FunctionReturn(*functionPtr)(FunctionArgTypes...), const std::tuple<TupleTypes...>& data, std::index_sequence<Ks...>)
        {
            return functionPtr(std::get<Ks>(data)...);
        }

        // (api) specialization function pointer
        template<typename ...FunctionArgTypes, typename FunctionReturn, typename ...TupleTypes>
        FunctionReturn cs_unpack_function_args(FunctionReturn(*functionPtr)(FunctionArgTypes...), const std::tuple<TupleTypes...>& data)
        {
            return cs_unpack_function_args_internal(functionPtr, data, std::index_sequence_for<TupleTypes...> {});
        }

        // (api) specialization function pointer, return type is void
        template<typename ...FunctionArgTypes, typename ...TupleTypes>
        CSVoidReturn cs_unpack_function_args(void (*functionPtr)(FunctionArgTypes...), const std::tuple<TupleTypes...>& data)
        {
            cs_unpack_function_args_internal(functionPtr, data, std::index_sequence_for<TupleTypes...> {});
            return CSVoidReturn{};
        }


        // ** unpack_function   (2)
        // ** index_sequence unpacks a tuple into arguments for a method pointer
        template<typename MethodClass, class MethodReturn, typename ...MethodArgTypes, typename ...TupleTypes, size_t ...Ks>
        MethodReturn cs_unpack_method_args_internal(MethodClass* obj, MethodReturn(MethodClass::* methodPtr)(MethodArgTypes...), const std::tuple<TupleTypes...>& data, std::index_sequence<Ks...>)
        {
            return (obj->*methodPtr)(std::get<Ks, TupleTypes...>(data)...);
            //return (obj->*methodPtr)(std::get<Ks>(data)...);
        }

        // (api) specialization method pointer
        template<typename MethodClass, class MethodReturn, typename ...MethodArgTypes, typename ...TupleTypes>
        MethodReturn cs_unpack_method_args(MethodClass* obj, MethodReturn(MethodClass::* methodPtr)(MethodArgTypes...), const std::tuple<TupleTypes...>& data)
        {
            return cs_unpack_method_args_internal(obj, methodPtr, data, std::index_sequence_for<TupleTypes...> {});
        }

        // (api) specialization for method pointer, return type is void
        template<typename MethodClass, typename ...MethodArgTypes, typename ...TupleTypes>
        CSVoidReturn cs_unpack_method_args(MethodClass* obj, void (MethodClass::* methodPtr)(MethodArgTypes...), const std::tuple<TupleTypes...>& data)
        {
            cs_unpack_method_args_internal(obj, methodPtr, data, std::index_sequence_for<TupleTypes...> {});
            return CSVoidReturn{};
        }

        // ** index_sequence unpacks a tuple into arguments for a const method pointer
        template<typename MethodClass, class MethodReturn, typename ...MethodArgTypes, typename ...TupleTypes, size_t ...Ks>
        MethodReturn cs_unpack_method_args_internal(const MethodClass* obj, MethodReturn(MethodClass::* methodPtr)(MethodArgTypes...) const, const std::tuple<TupleTypes...>& data, std::index_sequence<Ks...>)
        {
            return (obj->*methodPtr)(std::get<Ks>(data)...);
        }

        // (api) specialization for const method pointer
        template<typename MethodClass, class MethodReturn, typename ...MethodArgTypes, typename ...TupleTypes>
        MethodReturn cs_unpack_method_args(const MethodClass* obj, MethodReturn(MethodClass::* methodPtr)(MethodArgTypes...) const, const std::tuple<TupleTypes...>& data)
        {
            return cs_unpack_method_args_internal(obj, methodPtr, data, std::index_sequence_for<TupleTypes...> {});
        }

        // (api) specialization for const method pointer, return type is void
        template<typename MethodClass, typename ...MethodArgTypes, typename ...TupleTypes>
        CSVoidReturn cs_unpack_method_args(const MethodClass* obj, void (MethodClass::* methodPtr)(MethodArgTypes...) const, const std::tuple<TupleTypes...>& data)
        {
            cs_unpack_method_args_internal(obj, methodPtr, data, std::index_sequence_for<TupleTypes...> {});
            return CSVoidReturn{};
        }

        // ** templated classes used to add or remove types to a tuple

        template <class T1, class T2>
        class prePend
        {
            // required class to utilze a specialization
        };

        template <class T, class ...Ts>
        class prePend<T, std::tuple<Ts...>>
        {
        public:
            using type = typename std::tuple<T, Ts...>;
        };

        template <class T1>
        class strip
        {
        public:
            // contains nothing
            using type = typename std::tuple<>;
        };

        template <class T1, class T2, class ...Ts>
        class strip<std::tuple<T1, T2, Ts...>>
        {
        public:
            using type = typename prePend<T1, typename strip<std::tuple<T2, Ts...> >::type>::type;
        };


        // ** templated classes for generating a data type from a parameter pack

        template<unsigned int ...Vs>
        class intValues
        {
        };

        template<unsigned int Max, unsigned int ...Vs>
        class makeIntValues : public makeIntValues <Max - 1, Max - 1, Vs...>
        {
        };

        template<unsigned int ...Vs>
        class makeIntValues<0, Vs...> : public intValues<Vs...>
        {
        };

        // ** templated class to remove the last data type from the "tuple data type"

        template <class ...Ts>
        class removeLastType
        {
        public:
            using type = typename strip< std::tuple<Ts...> >::type;
        };


        // ** templated functions, to strip the last data element from a tuple

        template<unsigned int ...Vs, class ...Ts>
        typename removeLastType<Ts...>::type internalRemoveData(intValues<Vs...>, std::tuple<Ts...> tupleValue)
        {
            (void)tupleValue;
            return std::forward_as_tuple(std::get<Vs>(tupleValue)...);
        }

        template<class ...Ts>
        typename removeLastType<Ts...>::type funcRemoveData(std::tuple<Ts...> tupleValue)
        {
            return internalRemoveData(makeIntValues<sizeof...(Ts) - 1>(), tupleValue);
        }

}}//qor::detail

#endif//QOR_PP_H_SIGNALS_INTERNAL
