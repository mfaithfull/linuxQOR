// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

/***********************************************************************
*
* Copyright (c) 2016-2021 Barbara Geller
* Copyright (c) 2016-2021 Ansel Sermersheim
*
* This file is part of CsSignal.
*
* CsSignal is free software, released under the BSD 2-Clause license.
* For license details refer to LICENSE provided with this project.
*
* CopperSpice is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
*
* https://opensource.org/licenses/BSD-2-Clause
*
***********************************************************************/

#ifndef QOR_PP_H_SIGNALS_BENTO
#define QOR_PP_H_SIGNALS_BENTO

#include <memory>
#include "src/platform/compiler/compiler.h"
#include "teacup.h"
#include "src/qor/memory/stddeleter.h"
#include "src/qor/memory/stdallocator.h"

namespace qor{ namespace detail {

    // ** class to store method pointer for signals and slots
    class BentoAbstract
    {
    public:
        virtual ~BentoAbstract() {}

        virtual bool operator ==(const BentoAbstract& right) const = 0;
        bool operator !=(const BentoAbstract& right) const;

        virtual void invoke(SlotBase* receiver, const TeaCupAbstract* dataPack) const = 0;
        virtual std::unique_ptr<BentoAbstract/*, qor_std_deleter<BentoAbstract>*/ > clone() const = 0;
    };

    inline bool BentoAbstract::operator !=(const BentoAbstract& right) const
    {
        return !(*this == right);
    }

    template<class T>
    class Bento : public virtual BentoAbstract
    {
    public:

        virtual ~Bento() {}
        Bento(T ptr);

        bool operator ==(const BentoAbstract& right) const override;

        void invoke(SlotBase* receiver, const TeaCupAbstract* dataPack) const override;
        std::unique_ptr<BentoAbstract/*, qor_std_deleter<BentoAbstract>*/ > clone() const override;

        template<class MethodReturn, class ...MethodArgs>
        void invoke_internal(const TeaCupAbstract* dataPack, MethodReturn(T::* methodPtr)(MethodArgs...) const) const;

        template<class MethodReturn, class ...MethodArgs>
        void invoke_internal(const TeaCupAbstract* dataPack, MethodReturn(T::* methodPtr)(MethodArgs...)) const;

        T m_lambda;
    };

    template<class FunctionReturn, class ...FunctionArgs>
    class Bento<FunctionReturn(*)(FunctionArgs...)> : public virtual BentoAbstract
    {
    public:

        virtual ~Bento() {}
        Bento(FunctionReturn(*ptr)(FunctionArgs...));

        bool operator ==(const BentoAbstract& right) const override;

        std::unique_ptr<BentoAbstract/*, qor_std_deleter<BentoAbstract>*/ > clone() const override;
        void invoke(SlotBase* receiver, const TeaCupAbstract* dataPack) const override;

        FunctionReturn(*m_methodPtr)(FunctionArgs...);
    };

    template<class MethodClass, class MethodReturn, class...MethodArgs>
    class Bento<MethodReturn(MethodClass::*)(MethodArgs...)> : public virtual BentoAbstract
    {
    public:

        virtual ~Bento() {}
        Bento(MethodReturn(MethodClass::* ptr)(MethodArgs...));

        bool operator ==(const BentoAbstract& right) const override;
        void invoke(SlotBase* receiver, const TeaCupAbstract* dataPack) const override;
        std::unique_ptr<BentoAbstract/*, qor_std_deleter<BentoAbstract>*/ > clone() const override;

        MethodReturn(MethodClass::* m_methodPtr)(MethodArgs...);
    };

    // specialization, const method pointer
    template<class MethodClass, class MethodReturn, class...MethodArgs>
    class Bento<MethodReturn(MethodClass::*)(MethodArgs...) const> : public virtual BentoAbstract
    {
    public:

        virtual ~Bento() {}
        Bento(MethodReturn(MethodClass::* ptr)(MethodArgs...) const);

        bool operator ==(const BentoAbstract& right) const override;

        void invoke(SlotBase* receiver, const TeaCupAbstract* dataPack) const override;
        std::unique_ptr<BentoAbstract/*, qor_std_deleter<BentoAbstract>*/ > clone() const override;

        MethodReturn(MethodClass::* m_methodPtr)(MethodArgs...) const;
    };
    
    // (1) lambda
    template<class T>
    Bento<T>::Bento(T lambda) : m_lambda(lambda)
    {
    }

    template<class T>
    std::unique_ptr<BentoAbstract/*, qor_std_deleter<BentoAbstract>*/ > Bento<T>::clone() const
    {
        return std::make_unique<Bento<T>>(*this);
    }

    template<class T>
    bool Bento<T>::operator ==(const BentoAbstract&) const
    {
        // can not compare two lambdas
        return false;
    }

    template<class T>
    void Bento<T>::invoke(SlotBase*, const TeaCupAbstract* dataPack) const
    {
        // T must be a class or it will be a compiler erroe
        auto methodPtr = &T::operator();

        this->invoke_internal(dataPack, methodPtr);
    }

    template<class T>
    template<class MethodReturn, class ...MethodArgs>
    void Bento<T>::invoke_internal(const TeaCupAbstract* dataPack, MethodReturn(T::* methodPtr)(MethodArgs...) const) const
    {
        // handles non-mutable, captured variables are const

        // dynamic cast will return a valid ptr if the slot has equal or less parameters
        // retrieve ptr to teaCup object, which contains the data
        const TeaCup<MethodArgs...>* teaCup = dynamic_cast<const TeaCup<MethodArgs...> *>(dataPack);

        if (teaCup) {
            // expand arguments
            std::tuple<MethodArgs...>&& args = teaCup->getData();

            // unpack the tuple, then call the methodPtr
            cs_unpack_method_args(&m_lambda, methodPtr, args);
        }
    }

    template<class T>
    template<class MethodReturn, class ...MethodArgs>
    void Bento<T>::invoke_internal(const TeaCupAbstract* dataPack, MethodReturn(T::* methodPtr)(MethodArgs...)) const
    {
        // handles mutable, captured variables are non-const

        // dynamic cast will return a valid ptr if the slot has equal or less parameters
        // retrieve ptr to teaCup object, which contains the data
        const TeaCup<MethodArgs...>* teaCup = dynamic_cast<const TeaCup<MethodArgs...> *>(dataPack);

        if (teaCup) {
            // expand arguments
            std::tuple<MethodArgs...>&& args = teaCup->getData();

            auto object = const_cast<typename std::remove_const<T>::type*>(&m_lambda);

            // unpack the tuple, then call the methodPtr
            cs_unpack_method_args(object, methodPtr, args);
        }
    }

    // (2) specialization, function pointer
    template<class FunctionReturn, class ...FunctionArgs>
    Bento<FunctionReturn(*)(FunctionArgs...)>::Bento(FunctionReturn(*ptr)(FunctionArgs...)) : m_methodPtr(ptr)
    {
    }

    template<class FunctionReturn, class ...FunctionArgs>
    std::unique_ptr<BentoAbstract/*, qor_std_deleter<BentoAbstract>*/ > Bento<FunctionReturn(*)(FunctionArgs...)>::clone() const
    {
        return std::make_unique<Bento<FunctionReturn(*)(FunctionArgs...)>>(*this);
    }

    template<class FunctionReturn, class ...FunctionArgs>
    bool Bento<FunctionReturn(*)(FunctionArgs...)>::operator ==(const BentoAbstract& right) const
    {
        bool retval = false;

        const Bento<FunctionReturn(*)(FunctionArgs...)>* temp;
        temp = dynamic_cast<const Bento <FunctionReturn(*)(FunctionArgs...)> *> (&right);

        if (temp) {
            retval = (this->m_methodPtr == temp->m_methodPtr);
        }

        return retval;
    }

    template<class FunctionReturn, class ...FunctionArgs>
    void Bento<FunctionReturn(*)(FunctionArgs...)>::invoke(SlotBase*, const TeaCupAbstract* dataPack) const
    {
        // no need to verify receiver (slotBase *) since it is not used

        // dynamic cast will return a valid ptr if the slot has equal or less parameters
        // retrieve ptr to teaCup object, which contains the data
        const TeaCup<FunctionArgs...>* teaCup = dynamic_cast<const TeaCup<FunctionArgs...> *>(dataPack);

        if (teaCup) 
        {
            // expand arguments
            std::tuple<FunctionArgs...>&& args = teaCup->getData();

            // unpack the tuple, then call the methodPtr
            cs_unpack_function_args(m_methodPtr, args);
        }
    }

    // (3) specialization, method pointer
    template<class MethodClass, class MethodReturn, class...MethodArgs>
    Bento<MethodReturn(MethodClass::*)(MethodArgs...)>::Bento(MethodReturn(MethodClass::* ptr)(MethodArgs...))
        : m_methodPtr(ptr)
    {
    }

    template<class MethodClass, class MethodReturn, class...MethodArgs>
    std::unique_ptr<BentoAbstract/*, qor_std_deleter<BentoAbstract>*/ > Bento<MethodReturn(MethodClass::*)(MethodArgs...)>::clone() const
    {
        return std::make_unique<Bento<MethodReturn(MethodClass::*)(MethodArgs...)>>(*this);
    }

    template<class MethodClass, class MethodReturn, class...MethodArgs>
    bool Bento<MethodReturn(MethodClass::*)(MethodArgs...)>::operator ==(const BentoAbstract& right) const
    {
        bool retval = false;

        const Bento<MethodReturn(MethodClass::*)(MethodArgs...)>* temp;
        temp = dynamic_cast<const Bento <MethodReturn(MethodClass::*)(MethodArgs...)> *> (&right);

        if (temp) 
        {
            retval = (this->m_methodPtr == temp->m_methodPtr);
        }

        return retval;
    }

    template<class MethodClass, class MethodReturn, class ...MethodArgs>
    void Bento<MethodReturn(MethodClass::*)(MethodArgs...)>::invoke(SlotBase* receiver, const TeaCupAbstract* dataPack) const
    {
        if (!receiver) 
        {
            return;
        }

        MethodClass* t_receiver = dynamic_cast<MethodClass*>(receiver);

        if (t_receiver) 
        {
            // dynamic cast will return a valid ptr if the slot has equal or less parameters
            // retrieve ptr to teaCup object, which contains the data
            const TeaCup<MethodArgs...>* teaCup = dynamic_cast<const TeaCup<MethodArgs...> *>(dataPack);

            if (teaCup) 
            {
                // expand arguments
                std::tuple<MethodArgs...>&& args = teaCup->getData();

                // unpacks the tuple, then calls the methodPtr
                cs_unpack_method_args(t_receiver, m_methodPtr, args);
            }
        }
    }

    // (4) specialization, pointer to const method
    template<class MethodClass, class MethodReturn, class...MethodArgs>
    Bento<MethodReturn(MethodClass::*)(MethodArgs...) const>::Bento(MethodReturn(MethodClass::* ptr)(MethodArgs...) const)
        : m_methodPtr(ptr)
    {
    }

    template<class MethodClass, class MethodReturn, class...MethodArgs>
    std::unique_ptr<BentoAbstract/*, qor_std_deleter<BentoAbstract>*/ > Bento<MethodReturn(MethodClass::*)(MethodArgs...) const>::clone() const
    {
        return std::make_unique<Bento<MethodReturn(MethodClass::*)(MethodArgs...) const>>(*this);
    }

    template<class MethodClass, class MethodReturn, class...MethodArgs>
    bool Bento<MethodReturn(MethodClass::*)(MethodArgs...) const>::operator ==(const BentoAbstract& right) const
    {
        bool retval = false;

        const Bento<MethodReturn(MethodClass::*)(MethodArgs...) const>* temp;
        temp = dynamic_cast<const Bento <MethodReturn(MethodClass::*)(MethodArgs...) const> *> (&right);

        if (temp) 
        {
            retval = (this->m_methodPtr == temp->m_methodPtr);
        }

        return retval;
    }

    template<class MethodClass, class MethodReturn, class ...MethodArgs>
    void Bento<MethodReturn(MethodClass::*)(MethodArgs...) const>::invoke(SlotBase* receiver, const TeaCupAbstract* dataPack) const
    {
        if (!receiver) 
        {
            return;
        }

        MethodClass* t_receiver = dynamic_cast<MethodClass*>(receiver);

        if (t_receiver) 
        {
            // dynamic cast will return a valid ptr if the slot has equal or less parameters

            // retrieve ptr to teaCup object, which contains the data
            const TeaCup<MethodArgs...>* teaCup = dynamic_cast<const TeaCup<MethodArgs...> *>(dataPack);

            if (teaCup) 
            {
                // expand arguments
                std::tuple<MethodArgs...>&& args = teaCup->getData();

                // unpacks the tuple, then calls the methodPtr
                cs_unpack_method_args(t_receiver, m_methodPtr, args);
            }
        }
    }

}}//qor::detail

#endif//QOR_PP_H_SIGNALS_BENTO
