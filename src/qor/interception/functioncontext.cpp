// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "../../configuration/configuration.h"
#include "functioncontext.h"
#include "src/framework/thread/thread.h"

namespace qor {

	FunctionContext::FunctionContext(const char* szFuncName, const char* szFile, unsigned int uiLine, const char* szModule, bool bProfile, bool bCoverage, AnyObject ObjContext) : m_ObjContext(ObjContext)
		, m_uiLocked(0)
		, m_TraceDepth(1)
		, m_szFuncName(szFuncName)
		, m_szFile(szFile)
		, m_szModule(szModule)
		, m_uiLine(uiLine)
		, m_pParent(nullptr)
		, m_CallContext()
		, m_Profiler(this, bProfile)
	{
		Init();
	}

	FunctionContext::FunctionContext() : m_uiLocked(0)
		, m_TraceDepth(1)
		, m_szFuncName(nullptr)
		, m_szFile(nullptr)
		, m_szModule(nullptr)
		, m_uiLine(0)
		, m_pParent(nullptr)
		, m_CallContext()
		, m_Profiler(this, false)
	{
		Init();
	}

	bool FunctionContext::Locked() const
	{
		return m_uiLocked > 0;
	}

	unsigned int FunctionContext::Lock()
	{
		return ++m_uiLocked;
	}

	unsigned int FunctionContext::Unlock()
	{
		return m_uiLocked--;
	}

	bool FunctionContext::Trace(bool bNewTrace)
	{
		bool bTrace = m_bTraceCalls;
		m_bTraceCalls = bNewTrace;
		return bTrace;
	}

	ICallContext* FunctionContext::GetCallContext(void)
	{
		return &m_CallContext;
	}

	void FunctionContext::Init()
	{
		Lock();

        m_pParent = qor::framework::CurrentThread::GetCurrent().Context().RegisterFunctionContext(this);

		if (m_pParent)
		{
			m_TraceDepth = m_pParent->TraceDepth() + 1;
			if (!m_pParent->Locked())
			{
				if (m_pParent->GetCallContext())
				{
					m_pParent->GetCallContext()->CallMade(this);//Tell calling context we have reached called function body
				}
			}
		}
		Unlock();		
	}

	const char* FunctionContext::File() const
	{
		return m_szFile;
	}

	const char* FunctionContext::Module() const
	{
		return m_szModule;
	}

	unsigned int FunctionContext::Line() const
	{
		return m_uiLine;
	}

	IFunctionContext* FunctionContext::GetParent() const
	{
		return m_pParent;
	}

	void FunctionContext::SetParent(IFunctionContext* pParent)
	{
		m_pParent = pParent;
	}

	unsigned int FunctionContext::TraceDepth()
	{
		return m_TraceDepth;
	}

	FunctionContext::~FunctionContext()
	{
		Lock();
		if (m_pParent)
		{
			if (!m_pParent->Locked() && m_pParent->GetCallContext())
			{
				m_pParent->GetCallContext()->CallCompleted();//Tell call context we have completed sub function body				
				//m_pParent->GetCallContext()->Cleanup();
			}
		}

        qor::framework::CurrentThread::GetCurrent().Context().UnregisterFunctionContext(this, m_pParent);

        Unlock();
		m_uiLocked = (unsigned int) - 1;
		m_TraceDepth = 1001;
		m_szFuncName = "deleted";
		m_szFile = "deleted";
		m_szModule = "deleted";
		m_uiLine = (unsigned int) - 1;
		m_pParent = nullptr;
	}

	const char* FunctionContext::Name() const
	{
		return m_szFuncName;
	}

	AnyObject FunctionContext::TypedAny() const
	{
		return m_ObjContext;
	}

	void FunctionContext::Profile(const std::chrono::duration<int64_t, std::milli>)
	{
		//TODO: Find a flyer to handle the profiling info. Pass the function details along with the duration.
	}

}//qor
