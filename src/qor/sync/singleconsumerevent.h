// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_SYNC_SINGLECONSUMEREVENT
#define QOR_PP_H_SYNC_SINGLECONSUMEREVENT

#include <atomic>
#include <coroutine>

namespace qor
{
	/// A manual-reset event that supports only a single awaiting
	/// coroutine at a time.
	///
	/// You can co_await the event to suspend the current coroutine until
	/// some thread calls set(). If the event is already set then the
	/// coroutine will not be suspended and will continue execution.
	/// If the event was not yet set then the coroutine will be resumed
	/// on the thread that calls set() within the call to set().
	///
	/// Callers must ensure that only one coroutine is executing a
	/// co_await statement at any point in time.
	class SingleConsumerEvent
	{
	public:

		/// Construct a new event, initialising to either 'set' or 'not set' state.
		///
		/// \param initiallySet
		/// If true then initialises the event to the 'set' state.
		/// Otherwise, initialised the event to the 'not set' state.
		SingleConsumerEvent(bool initiallySet = false) noexcept : m_state(initiallySet ? state::set : state::not_set) {}

		/// Query if this event has been set.
		bool is_set() const noexcept
		{
			return m_state.load(std::memory_order_acquire) == state::set;
		}

		/// Transition this event to the 'set' state if it is not already set.
		///
		/// If there was a coroutine awaiting the event then it will be resumed
		/// inside this call.
		void set()
		{
			const state oldState = m_state.exchange(state::set, std::memory_order_acq_rel);
			if (oldState == state::not_set_consumer_waiting)
			{
				m_awaiter.resume();
			}
		}

		/// Transition this event to the 'non set' state if it was in the set state.
		void reset() noexcept
		{
			state oldState = state::set;
			m_state.compare_exchange_strong(oldState, state::not_set, std::memory_order_relaxed);
		}

		/// Wait until the event becomes set.
		///
		/// If the event is already set then the awaiting coroutine will not be suspended
		/// and will continue execution. If the event was not yet set then the coroutine
		/// will be suspended and will be later resumed inside a subsequent call to set()
		/// on the thread that calls set().
		auto operator co_await() noexcept
		{
			class awaiter
			{
			public:

				awaiter(SingleConsumerEvent& event) : m_event(event) {}

				bool await_ready() const noexcept
				{
					return m_event.is_set();
				}

				bool await_suspend(std::coroutine_handle<> awaiter)
				{
					m_event.m_awaiter = awaiter;

					state oldState = state::not_set;
					return m_event.m_state.compare_exchange_strong(
						oldState,
						state::not_set_consumer_waiting,
						std::memory_order_release,
						std::memory_order_acquire);
				}

				void await_resume() noexcept {}

			private:

				SingleConsumerEvent& m_event;

			};

			return awaiter{ *this };
		}

	private:

		enum class state
		{
			not_set,
			not_set_consumer_waiting,
			set
		};

		// TODO: Merge these two fields into a single std::atomic<std::uintptr_t>
		// by encoding 'not_set' as 0 (nullptr), 'set' as 1 and
		// 'not_set_consumer_waiting' as a coroutine handle pointer.
		std::atomic<state> m_state;
		std::coroutine_handle<> m_awaiter;

	};
}

#endif//QOR_PP_H_SYNC_SINGLECONSUMEREVENT