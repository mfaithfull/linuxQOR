// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include <cassert>

#include "asyncmutex.h"

namespace qor{

    AsyncMutex::AsyncMutex() noexcept
        : m_state(not_locked)
        , m_waiters(nullptr) {}

    AsyncMutex::~AsyncMutex()
    {
        [[maybe_unused]] auto state = m_state.load(std::memory_order_relaxed);
        assert(state == not_locked || state == locked_no_waiters);
        assert(m_waiters == nullptr);
    }

    bool AsyncMutex::try_lock() noexcept
    {
        // Try to atomically transition from nullptr (not-locked) -> this (locked-no-waiters).
        auto oldState = not_locked;
        return m_state.compare_exchange_strong(
            oldState,
            locked_no_waiters,
            std::memory_order_acquire,
            std::memory_order_relaxed);
    }

    AsyncMutexLockOperation AsyncMutex::lock_async() noexcept
    {
        return AsyncMutexLockOperation{ *this };
    }

    AsyncMutexScopedLockOperation AsyncMutex::scoped_lock_async() noexcept
    {
        return AsyncMutexScopedLockOperation{ *this };
    }

    void AsyncMutex::unlock()
    {
        assert(m_state.load(std::memory_order_relaxed) != not_locked);

        AsyncMutexLockOperation* waitersHead = m_waiters;
        if (waitersHead == nullptr)
        {
            auto oldState = locked_no_waiters;
            const bool releasedLock = m_state.compare_exchange_strong(
                oldState,
                not_locked,
                std::memory_order_release,
                std::memory_order_relaxed);
            if (releasedLock)
            {
                return;
            }

            // At least one new waiter.
            // Acquire the list of new waiter operations atomically.
            oldState = m_state.exchange(locked_no_waiters, std::memory_order_acquire);

            assert(oldState != locked_no_waiters && oldState != not_locked);

            // Transfer the list to m_waiters, reversing the list in the process so
            // that the head of the list is the first to be resumed.
            auto* next = reinterpret_cast<AsyncMutexLockOperation*>(oldState);
            do
            {
                auto* temp = next->m_next;
                next->m_next = waitersHead; 
                waitersHead = next;
                next = temp;
            } while (next != nullptr);
        }

        assert(waitersHead != nullptr);

        m_waiters = waitersHead->m_next;

        // Resume the waiter.
        // This will pass the ownership of the lock on to that operation/coroutine.
        waitersHead->m_awaiter.resume();
    }

    bool AsyncMutexLockOperation::await_suspend(std::coroutine_handle<> awaiter) noexcept
    {
        m_awaiter = awaiter;

        std::uintptr_t oldState = m_mutex.m_state.load(std::memory_order_acquire);
        while (true)
        {
            if (oldState == AsyncMutex::not_locked)
            {
                if (m_mutex.m_state.compare_exchange_weak(
                    oldState,
                    AsyncMutex::locked_no_waiters,
                    std::memory_order_acquire,
                    std::memory_order_relaxed))
                {
                    // Acquired lock, don't suspend.
                    return false;
                }
            }
            else
            {
                // Try to push this operation onto the head of the waiter stack.
                m_next = reinterpret_cast<AsyncMutexLockOperation*>(oldState);
                if (m_mutex.m_state.compare_exchange_weak(
                    oldState,
                    reinterpret_cast<std::uintptr_t>(this),
                    std::memory_order_release,
                    std::memory_order_relaxed))
                {
                    // Queued operation to waiters list, suspend now.
                    return true;
                }
            }
        }
    }

}//qor
