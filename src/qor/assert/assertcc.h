// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Derived from assertcc
//Copyright 2021 Sean Nash
//under BSD 3 clause license

#ifndef QOR_PP_H_ASSERTCC
#define QOR_PP_H_ASSERTCC

#include "adl.h"
#include "subject/boolsubject.h"
#include "subject/complexsubject.h"
#include "subject/floatingsubject.h"
#include "subject/genericsubject.h"
#include "subject/integralsubject.h"
#include "subject/iteratorssubject.h"
#include "subject/mapsubject.h"
#include "subject/multimapsubject.h"
#include "subject/optionalsubject.h"
#include "subject/pointersubject.h"
#include "subject/priorityqueuesubject.h"
#include "subject/setsubject.h"
#include "subject/sharedptrsubject.h"
#include "subject/spansubject.h"
#include "subject/stacksubject.h"
#include "subject/stringsubject.h"
#include "subject/stringviewsubject.h"
#include "subject/uniqueptrsubject.h"
#include "subject/weakptrsubject.h"
#include "../test/test.h"
//#include "gtest/gtest.h"

#include <array>
#include <deque>
#include <forward_list>
#include <initializer_list>
#include <list>
#include <sstream>
#include <stack>
#include <string>
#include <type_traits>
#include <utility>
#include <complex>
#include <vector>
#include <optional>
#include <map>
#include <unordered_map>
#include <set>
#include <unordered_set>
#include <queue>

#define assertThat(x) assertcc::assert_that_internal(assertcc::Adl(), true, __FILE__, __LINE__, x)
#define expectThat(x) assertcc::assert_that_internal(assertcc::Adl(), false, __FILE__, __LINE__, x)

namespace assertcc {

    template <typename T, typename std::enable_if<std::is_same<T, bool>::value>::type* = nullptr>
    auto assert_that_internal(Adl dummy, bool failOnError, const char* file, int line, T v) 
    {
        return subject::BoolSubject(failOnError, file, line, v);
    }

    template <typename T,
            typename std::enable_if<!std::is_same<T, bool>::value>::type* = nullptr,
            typename std::enable_if<std::is_integral<T>::value>::type* = nullptr>
    auto assert_that_internal(Adl dummy, bool failOnError, const char* file, int line, T v) 
    {
        return subject::IntegralSubject<T>(failOnError, file, line, v);
    }

    template <typename T>
    auto assert_that_internal(
        Adl dummy, bool failOnError, const char* file, int line, std::complex<T> v) 
    {
        return subject::ComplexSubject(failOnError, file, line, v);
    }

    template <typename T, typename std::enable_if<std::is_floating_point<T>::value, T>::type* = nullptr>
    auto assert_that_internal(Adl dummy, bool failOnError, const char* file, int line, T v) 
    {
        return subject::FloatingSubject<T>(failOnError, file, line, v);
    }

    template <typename T, size_t N>
    auto assert_that_internal(
        Adl dummy, bool failOnError, const char* file, int line, std::array<T, N>& v) 
    {
        return subject::IteratorsSubject(failOnError, file, line, v.cbegin(), v.cend());
    }

    template <typename T, typename A>
    auto assert_that_internal(
        Adl dummy, bool failOnError, const char* file, int line, std::vector<T, A>& v) 
    {
        return subject::IteratorsSubject(failOnError, file, line, v.cbegin(), v.cend());
    }

    template <typename T, typename A>
    auto assert_that_internal(
        Adl dummy, bool failOnError, const char* file, int line, std::list<T, A>& v) 
    {
        return subject::IteratorsSubject(failOnError, file, line, v.cbegin(), v.cend());
    }

    template <typename T, typename A>
    auto assert_that_internal(
        Adl dummy, bool failOnError, const char* file, int line, std::deque<T, A>& v) 
    {
        return subject::IteratorsSubject(failOnError, file, line, v.cbegin(), v.cend());
    }

    template <typename T, typename A>
    auto assert_that_internal(
        Adl dummy, bool failOnError, const char* file, int line, std::forward_list<T, A>& v) 
    {
        return subject::IteratorsSubject(failOnError, file, line, v.cbegin(), v.cend());
    }

    template <typename T>
    auto assert_that_internal(
        Adl dummy, bool failOnError, const char* file, int line, std::optional<T> v) 
    {
        return subject::OptionalSubject(failOnError, file, line, v);
    }

    template <typename T, typename std::enable_if<std::is_pointer<T>::value, T>::type* = nullptr>
    auto assert_that_internal(Adl dummy, bool failOnError, const char* file, int line, T v) 
    {
        return subject::PointerSubject<T>(failOnError, file, line, v);
    }

    template <typename T>
    auto assert_that_internal(
        Adl dummy, bool failOnError, const char* file, int line, std::shared_ptr<T> v) 
    {
        return subject::SharedPtrSubject(failOnError, file, line, v);
    }

    template <typename T, typename Deleter>
    auto assert_that_internal(
        Adl dummy, bool failOnError, const char* file, int line, std::unique_ptr<T, Deleter>& v) 
    {
        return subject::UniquePtrSubject(failOnError, file, line, v);
    }

    template <typename T>
    auto assert_that_internal(
        Adl dummy, bool failOnError, const char* file, int line, std::weak_ptr<T>& v) 
    {
        return subject::WeakPtrSubject(failOnError, file, line, v);
    }

    template <typename Key, typename T, typename Compare, typename Allocator>
    auto assert_that_internal(Adl dummy,
                            bool failOnError,
                            const char* file,
                            int line,
                            std::map<Key, T, Compare, Allocator>& v) 
    {
        return subject::MapSubject(failOnError, file, line, v);
    }

    template <typename Key, typename T, typename Hash, typename KeyEqual, typename Allocator>
    auto assert_that_internal(Adl dummy,
                            bool failOnError,
                            const char* file,
                            int line,
                            std::unordered_map<Key, T, Hash, KeyEqual, Allocator>& v) 
    {
        return subject::MapSubject(failOnError, file, line, v);
    }

    template <typename Key, typename T, typename Compare, typename Allocator>
    auto assert_that_internal(Adl dummy,
                            bool failOnError,
                            const char* file,
                            int line,
                            std::multimap<Key, T, Compare, Allocator>& v) 
    {
        return subject::MultiMapSubject(failOnError, file, line, v);
    }

    template <typename Key, typename T, typename Hash, typename KeyEqual, typename Allocator>
    auto assert_that_internal(Adl dummy,
                            bool failOnError,
                            const char* file,
                            int line,
                            std::unordered_multimap<Key, T, Hash, KeyEqual, Allocator>& v) 
    {
        return subject::MultiMapSubject(failOnError, file, line, v);
    }

    template <typename Key, typename Compare, typename Allocator>
    auto assert_that_internal(
        Adl dummy, bool failOnError, const char* file, int line, std::set<Key, Compare, Allocator>& v) 
    {
        return subject::SetSubject(failOnError, file, line, v);
    }

    template <typename Key, typename Hash, typename KeyEqual, typename Allocator>
    auto assert_that_internal(Adl dummy,
                            bool failOnError,
                            const char* file,
                            int line,
                            std::unordered_set<Key, Hash, KeyEqual, Allocator>& v) 
    {
        return subject::SetSubject(failOnError, file, line, v);
    }

    template <typename CharT, typename Traits>
    auto assert_that_internal(Adl dummy,
                            bool failOnError,
                            const char* file,
                            int line,
                            const std::basic_string<CharT, Traits>& v) 
    {
        return subject::StringSubject(failOnError, file, line, v);
    }

    template <typename CharT, typename Traits>
    auto assert_that_internal(Adl dummy,
                            bool failOnError,
                            const char* file,
                            int line,
                            const std::basic_string_view<CharT, Traits>& v) 
    {
        return subject::StringViewSubject(failOnError, file, line, v);
    }

    template <typename E, typename C>
    auto assert_that_internal(
        Adl dummy, bool failOnError, const char* file, int line, std::stack<E, C>& v) 
    {
        return subject::StackSubject(failOnError, file, line, v);
    }

    template <typename Type, typename Container, typename Compare>
    auto assert_that_internal(Adl dummy,
                            bool failOnError,
                            const char* file,
                            int line,
                            std::priority_queue<Type, Container, Compare>& v) 
    {
        return subject::PriorityQueueSubject(failOnError, file, line, v);
    }

#if __cpp_lib_span > 202002L

    template <typename T, std::size_t Extent>
    auto assert_that_internal(
        Adl dummy, bool failOnError, const char* file, int line, std::span<T, Extent>& v) 
    {
        return subject::SpanSubject(failOnError, file, line, v);
    }

#endif

}//assertcc

#endif//QOR_PP_H_ASSERTCC
