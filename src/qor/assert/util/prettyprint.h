// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Derived from assertcc
//Copyright 2021 Sean Nash
//under BSD 3 clause license

#include <iostream>
#include <map>
#include <memory>
#include <optional>
#include <queue>
#include <set>
#include <stack>
#if __cpp_lib_span > 202002L
#include <span>
#endif
#include <unordered_map>
#include <unordered_set>

namespace assertcc {

namespace util {

template <typename Key, typename T, typename Compare, typename Allocator>
std::ostream& operator<<(std::ostream& os, const std::map<Key, T, Compare, Allocator>& m) {
  os << "[std::map ";
  if (!m.empty())
    for (const auto& entry : m) os << " " << entry.first << "->" << entry.second;
  os << " ]";
  return os;
}
template <typename Key, typename T, typename Hash, typename KeyEqual, typename Allocator>
std::ostream& operator<<(std::ostream& os,
                         const std::unordered_map<Key, T, Hash, KeyEqual, Allocator>& m) {
  os << "[std::unordered_map ";
  if (!m.empty())
    for (const auto& entry : m) os << " " << entry.first << "->" << entry.second;
  os << " ]";
  return os;
}

template <typename Key, typename T, typename Compare, typename Allocator>
std::ostream& operator<<(std::ostream& os, const std::multimap<Key, T, Compare, Allocator>& m) {
  os << "[std::multimap ";
  if (!m.empty())
    for (const auto& entry : m) os << " " << entry.first << "->" << entry.second;
  os << " ]";
  return os;
}

template <typename Key, typename T, typename Hash, typename KeyEqual, typename Allocator>
std::ostream& operator<<(std::ostream& os,
                         const std::unordered_multimap<Key, T, Hash, KeyEqual, Allocator>& m) {
  os << "[std::unordered_multimap ";
  if (!m.empty())
    for (const auto& entry : m) os << " " << entry.first << "->" << entry.second;
  os << " ]";
  return os;
}

template <typename T>
std::ostream& operator<<(std::ostream& os, const std::optional<T> opt) {
  os << "[std::optional ";
  if (opt.has_value()) os << opt.value();
  os << " ]";
  return os;
}

template <typename T, typename Container, typename Compare>
std::ostream& operator<<(std::ostream& os, const std::priority_queue<T, Container, Compare>& m) {
  os << "[std::priority_queue "
     << "size=(" << m.size() << ")";
  if (!m.empty()) {
    os << " top=(" << m.top() << ")";
  }
  os << " ]";
  return os;
}

#if __cpp_lib_span > 202002L

template <typename T, std::size_t Extent>
std::ostream& operator<<(std::ostream& os, const std::span<T, Extent> data) {
  os << "[std::span ";
  for (const auto& d : data) {
    os << " " << d;
  }
  os << " ]";
  return os;
}

#endif

template <typename T, typename C>
std::ostream& operator<<(std::ostream& os, const std::stack<T, C>& m) {
  os << "[std::stack "
     << "size=(" << m.size() << ")";
  if (!m.empty()) {
    os << " top=(" << m.top() << ")";
  }
  os << " ]";
  return os;
}

template <typename Key, typename Compare, typename Allocator>
std::ostream& operator<<(std::ostream& os, const std::set<Key, Compare, Allocator>& m) {
  os << "[std::set ";
  if (!m.empty())
    for (const auto& entry : m) os << " " << entry;
  os << " ]";
  return os;
}

template <typename Key, typename Compare, typename Allocator>
std::ostream& operator<<(std::ostream& os, const std::unordered_set<Key, Compare, Allocator>& m) {
  os << "[std::unordered_set ";
  if (!m.empty())
    for (const auto& entry : m) os << " " << entry;
  os << " ]";
  return os;
}

template <typename T, typename Deleter>
std::ostream& operator<<(std::ostream& os, std::unique_ptr<T, Deleter> const& p) {
  os << "[std::unique_ptr ";
  if (p) {
    os << *p;
  }
  os << " ]";
  return os;
}
template <typename T>
std::ostream& operator<<(std::ostream& os, const std::weak_ptr<T> o) {
  os << "[std::weak_ptr ";
  if (!o.expired()) {
    auto sp = o.lock();
    os << sp.get();
  }
  os << " ]";
  return os;
}

}  // namespace util

}  // namespace assertcc