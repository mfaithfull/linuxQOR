// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_MANUALLIFETIME
#define QOR_PP_H_MANUALLIFETIME

#include <type_traits>
#include <memory>

namespace qor{ namespace detail{

	template<typename T>
	struct manual_lifetime
	{
	public:

		manual_lifetime() noexcept {}
		~manual_lifetime() noexcept {}

		manual_lifetime(const manual_lifetime&) = delete;
		manual_lifetime(manual_lifetime&&) = delete;
		manual_lifetime& operator=(const manual_lifetime&) = delete;
		manual_lifetime& operator=(manual_lifetime&&) = delete;

		template<typename... Args>
		std::enable_if_t<std::is_constructible_v<T, Args&&...>> construct(Args&&... args) noexcept(std::is_nothrow_constructible_v<T, Args&&...>)
		{
			::new (static_cast<void*>(std::addressof(m_value))) T(static_cast<Args&&>(args)...);
		}

		void destruct() noexcept(std::is_nothrow_destructible_v<T>)
		{
			m_value.~T();
		}

		std::add_pointer_t<T> operator->() noexcept 
        { 
            return std::addressof(**this); 
        }

		std::add_pointer_t<const T> operator->() const noexcept 
        { 
            return std::addressof(**this); 
        }

		T& operator*() & noexcept 
        { 
            return m_value; 
        }

		const T& operator*() const & noexcept 
        { 
            return m_value; 
        }

		T&& operator*() && noexcept 
        { 
            return static_cast<T&&>(m_value); 
        }

		const T&& operator*() const && noexcept 
        { 
            return static_cast<const T&&>(m_value); 
        }

	private:

		union 
        {
			T m_value;
		};
	};

	template<typename T>
	struct manual_lifetime<T&>
	{
	public:

		manual_lifetime() noexcept {}
		~manual_lifetime() noexcept {}

		manual_lifetime(const manual_lifetime&) = delete;
		manual_lifetime(manual_lifetime&&) = delete;
		manual_lifetime& operator=(const manual_lifetime&) = delete;
		manual_lifetime& operator=(manual_lifetime&&) = delete;

		void construct(T& value) noexcept
		{
			m_value = std::addressof(value);
		}

		void destruct() noexcept {}

		T* operator->() noexcept 
        { 
            return m_value; 
        }

		const T* operator->() const noexcept 
        { 
            return m_value; 
        }

		T& operator*() noexcept 
        { 
            return *m_value; 
        }

		const T& operator*() const noexcept 
        { 
            return *m_value; 
        }

	private:

		T* m_value;
	};

	template<typename T>
	struct manual_lifetime<T&&>
	{
	public:

		manual_lifetime() noexcept {}
		~manual_lifetime() noexcept {}

		manual_lifetime(const manual_lifetime&) = delete;
		manual_lifetime(manual_lifetime&&) = delete;
		manual_lifetime& operator=(const manual_lifetime&) = delete;
		manual_lifetime& operator=(manual_lifetime&&) = delete;

		void construct(T&& value) noexcept
		{
			m_value = std::addressof(value);
		}

		void destruct() noexcept {}

		T* operator->() noexcept 
        { 
            return m_value; 
        }
		
        const T* operator->() const noexcept 
        { 
            return m_value; 
        }

		T& operator*() & noexcept 
        { 
            return *m_value; 
        }

		const T& operator*() const & noexcept 
        { 
            return *m_value; 
        }

		T&& operator*() && noexcept 
        { 
            return static_cast<T&&>(*m_value); 
        }

		const T&& operator*() const && noexcept 
        { 
            return static_cast<const T&&>(*m_value); 
        }

	private:
    
		T* m_value;
	};

	template<>
	struct manual_lifetime<void>
	{
		void construct() noexcept {}
		void destruct() noexcept {}
		void operator*() const noexcept {}
	};

}}//qor::detail

#endif//QOR_PP_H_MANUALLIFETIME
