// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Derived from HippoMocks
//Copyright (C) 2008, Bas van Tiel, Christian Rexwinkel, Mike Looijmans, Peter Bindels
//under GNU LGPL v2.1

#ifndef QOR_PP_H_MOCKS
#define QOR_PP_H_MOCKS

#ifndef qor_pp_mock_default_autoexpect
#define qor_pp_mock_default_autoexpect true
#endif

/* 
 The qor_pp_mock_default_autoexpect is an option that determines whether tests are, by default, under- or
 overspecified. Auto-expect, by function, adds an expectation to the current ExpectCall that
 it will happen after the previous ExpectCall. For many people this is an intuitive and logical
 thing when writing a C++ program. Usually, this makes your test workable but overspecified.
 Overspecified means that your test will fail on working code that does things in a different
 order. The alternative, underspecified, allows code to pass your test that does things in a
 different order, where that different order should be considered wrong. Consider reading a
 file, where it needs to be first opened, then read and then closed.

 The default is to make tests overspecified. At least it prevents faulty code from passing
 unit tests. To locally disable (or enable) this behaviour, set the boolean autoExpect on your
 MockRepository to false (or true). To globally override, redefine qor_pp_mock_default_autoexpect to false.
*/

#ifndef qor_pp_mock_debugbreak
#   define qor_pp_mock_debugbreak qor_pp_compiler_debugbreak
#endif

#ifndef qor_pp_mock_extra_destructor
#   ifdef qor_pp_compiler_extra_destructor
#       define qor_pp_mock_extra_destructor
#   endif
#endif

#ifndef qor_pp_mock_dontcare_name
#   define qor_pp_mock_dontcare_name _
#endif

#ifndef qor_pp_mock_virt_func_limit
#   define qor_pp_mock_virt_func_limit 1024
#elif qor_pp_mock_virt_func_limit > 1024
#   error Adjust the code to support more than 1024 virtual functions before setting the qor_pp_mock_virt_func_limit above 1024
#endif

#include "detail/replace.h"
#include "detail/reverse.h"
#include "registrationtype.h"
#include "basemock.h"
#include "parameters/dontcare.h"
#include "parameters/outparam.h"
#include "parameters/inparam.h"
#include "printing/nonprintable.h"
#include "printing/printarg.h"
#include "repository/mockrepositoryinstanceholder.h"
#include "printing/argumentprinter.h"
#include "exceptions/exceptionholder.h"
#include "exceptions/exceptionwrapper.h"
#include "exceptions/exceptionfunctor.h"
#include "exceptions/exceptionholderimpl.h"
#include "detail/reporter.h"
#include "detail/func_index.h"
#include "typedestructable.h"
#include "memberwrapper.h"
#include "rttiinfo.h"
#include "mock.h"
#include "returnvalue/returnvaluewrapper.h"
#include "returnvalue/returnvaluewrappercopy.h"
#include "returnvalue/returnvaluehandle.h"
#include "call.h"
#include "detail/callimpl.h"
#include "invoke.h"
#include "parameters/assignsingle.h"
#include "parameters/assigner.h"
#include "comparabletuple.h"
#include "tcall.h"
#include "repository/mockrepository.h"
#include "mockfuncs.h"
#include "mockimpl.h"
#include "repository/mockrepositoryimpl.h"
#include "exceptions/baseexception.h"
#include "exceptions/expectationexception.h"
#include "exceptions/notimplementedexception.h"
#include "exceptions/callmissingexception.h"
#include "exceptions/zombiemockexception.h"
#include "exceptions/noresultsetupexception.h"
#include "detail/defaultreporter.h"

namespace qor{ namespace mock {

    template<typename T>
    inline std::ostream& operator << (std::ostream& os, std::reference_wrapper<T>& ref)
    {
        os << "ref(" << ref.get() << ")";
        return os;
    }

    template<typename T, typename U>
    static inline bool operator==(const std::reference_wrapper<U>& a, const T b)
    {
        return &a.get() == &b;
    }

}}//qor::mock


using qor::mock::MockRepository;
using qor::mock::qor_pp_mock_dontcare_name;
using qor::mock::Call;
using qor::mock::Out;
using qor::mock::In;

#undef qor_pp_mock_virt_func_limit
#undef qor_pp_mock_dontcare_name
#undef qor_pp_mock_extra_destructor
#undef qor_pp_mock_debugbreak

#endif//QOR_PP_H_MOCKS

