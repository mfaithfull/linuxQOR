// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_PROPERTY_PROPERTYVALUE
#define QOR_PP_H_PROPERTY_PROPERTYVALUE

#include <vector>
#include <unordered_map>

#include "propertyvaluebase.h"
#include "propertybase.h"

namespace qor {

	class qor_pp_module_interface(QOR_PROPERTY) Property;
	typedef std::unordered_map< PropertyName, Property > PropertyMap;
	typedef std::vector< Property > PropertyVector;

	class qor_pp_module_interface(QOR_PROPERTY) PropertyValue : public PropertyValueBase
	{
	public:

		PropertyValue() : m_pv(nullptr), m_pm(nullptr), m_pp(nullptr) {}

		PropertyValue(const PropertyValue& src) : PropertyValueBase(src), m_pv(nullptr), m_pm(nullptr), m_pp(nullptr)
		{
			*this = src;
		}

		PropertyValue& operator =(const PropertyValue& src)
		{
			if (&src != this)
			{
				return Set(src);
			}
			return *this;
		}

		~PropertyValue()
		{
			delete m_pv;
			m_pv = nullptr;
			delete m_pm;
			m_pm = nullptr;
			delete m_pp;
			m_pp = nullptr;
		}

		PropertyVector GetVector() const
		{
			return *m_pv;
		}

		PropertyMap GetMap() const
		{
			return *m_pm;
		}

		PropertyBase* GetProperty();

		template< class T >
		PropertyValue& Set(const T& t)
		{
			delete m_p;			
			delete m_pv;
			delete m_pm;
			delete m_pp;

			if constexpr (std::is_same < T, PropertyValue >::value)
			{
				pvt = t.GetType();
				switch (pvt)
				{
				case PVT_Null:
					break;
				case PVT_Map:
					m_pm = new PropertyMap(*t.m_pm);
					break;
				case PVT_Property:
					m_pp = InternalCreateProperty(t.m_pp);
					break;
				case PVT_Vector:
					m_pv = new PropertyVector(*t.m_pv);
					break;
				case PVT_Value:
					m_p = t.m_p->Clone();
					break;
				}
				return *this;
			}
			else if constexpr (std::is_same < T, Property >::value)
			{
				pvt = PVT_Property;
				m_pp = t.m_pp->Clone();
				return *this;
			}
			else if constexpr (std::is_same < T, PropertyVector >::value)
			{
				pvt = PVT_Vector;
				m_pv = new PropertyVector(t);
				return *this;
			}
			else if constexpr (std::is_same < T, PropertyMap >::value)
			{
				pvt = PVT_Map;
				m_pm = new PropertyMap(t);
				return *this;
			}
			else if constexpr (std::is_base_of < UnsafeAnyProperty, T >::value)
			{
				pvt = PVT_Value;
				m_p = t.Clone();
				return *this;
			}
			else
			{
				pvt = PVT_Value;
				m_p = new TypedAnyProperty<T>(t);
				return *this;
			}
		}

	private:

		PropertyBase* InternalCreateProperty(PropertyBase* pb);

		PropertyVector* m_pv;
		PropertyMap* m_pm;
		PropertyBase* m_pp;

	};

}//qor

#endif//QOR_PP_H_PROPERTY_PROPERTYVALUE
