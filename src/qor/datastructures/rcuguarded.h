// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

/***********************************************************************
*
* Copyright (c) 2015-2018 Barbara Geller
* Copyright (c) 2015-2018 Ansel Sermersheim
* All rights reserved.
*
* This file is part of libguarded
*
* libguarded is free software, released under the BSD 2-Clause license.
* For license details refer to LICENSE provided with this project.
*
***********************************************************************/

#ifndef QOR_PP_H_RCUGUARDED
#define QOR_PP_H_RCUGUARDED

#include <memory>

namespace qor {

	/**This templated class implements a mechanism which controls access
	   to an RCU data structure. The only way to access the underlying
	   data structure is to use either the lock_read or lock_write methods
	   to receive a read-only or writable handle to the data structure,
	   respectively.
	*/
	template <typename T>
	class rcu_guarded
	{
	public:

		class write_handle;
		class read_handle;

		template <typename... Us>
		rcu_guarded(Us &&... data);		
		[[nodiscard]] write_handle lock_write();		// write access		
		[[nodiscard]] read_handle lock_read() const;	// read access

		class write_handle
		{
		public:
			
			using pointer = T* ;
			using element_type = T;

			write_handle(T *ptr);

			~write_handle()
			{
				if (m_accessed) 
				{
					m_guard.rcu_write_unlock(*m_ptr);
				}
			}

			T & operator*() const
			{
				access();
				return *m_ptr;
			}

			T * operator->() const
			{
				access();
				return m_ptr;
			}

		private:
			
			void access() const
			{
				if (!m_accessed) 
				{
					m_guard.rcu_write_lock(*m_ptr);
					m_accessed = true;
				}
			}

			T* m_ptr;
			mutable typename T::rcu_write_guard m_guard;
			mutable bool m_accessed;
		};


        class read_handle
		{
		public:

			using pointer = const T*;
			using element_type = const T;

			read_handle(const T* ptr) : m_ptr(ptr), m_accessed(false)
			{
			}

			~read_handle()
			{
				if (m_accessed) 
				{
					m_guard.rcu_read_unlock(*m_ptr);
				}
			}

			const T & operator*() const
			{
				access();
				return *m_ptr;
			}

			const T * operator->() const
			{
				access();
				return m_ptr;
			}

		private:
			
			void access() const
			{
				if (!m_accessed) 
				{
					m_guard.rcu_read_lock(*m_ptr);
					m_accessed = true;
				}
			}

			const T * m_ptr;
			mutable typename T::rcu_read_guard m_guard;
			mutable bool m_accessed;
		};

	private:

		T m_obj;
	};


    template <typename T>
	template <typename... Us>
	rcu_guarded<T>::rcu_guarded(Us &&... data) : m_obj(std::forward<Us>(data)...)
	{
	}

	template <typename T>
	auto rcu_guarded<T>::lock_write() -> write_handle
	{
		return write_handle(&m_obj);
	}
	
	template <typename T>
	auto rcu_guarded<T>::lock_read() const -> read_handle
	{
		return read_handle(&m_obj);
	}

	template <typename T>
	rcu_guarded<T>::write_handle::write_handle(T* ptr)
		: m_ptr(ptr), m_accessed(false)
	{
	}

}//qor

#endif//QOR_PP_H_RCUGUARDED
