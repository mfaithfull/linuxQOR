// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include "path.h"

namespace qor{ namespace system{

    std::string Path::s_rootIndicator;
    std::string Path::s_selfIndicator;
    std::string Path::s_parentIndicator;
    unsigned short Path::s_maxElementLength;
    std::string Path::s_separator;

    Path::Path() : m_path()
    {
        
    }

    Path::Path(const std::string& path) : m_path(path)
    {

    }
    
    Path& Path::operator /= (const std::string& folder)
    {
        m_path /= folder;
        return *this;
    }

    Path Path::Parent() const
    {
        Path parent(m_path.parent_path().generic_string());
        return parent;
    }

    const std::string Path::Separator() const
    {
        return Path::s_separator;
    }

    const std::string Path::SelfIndicator() const
    {
        return Path::s_selfIndicator;
    }

    const std::string Path::ParentIndicator() const
    {
        return Path::s_parentIndicator;
    }

    const unsigned short Path::MaxElementLength() const
    {
        return Path::s_maxElementLength;
    }

    const std::string Path::RootIndicator() const
    {
        return Path::s_rootIndicator;
    }

    std::string Path::ToString() const
    {
        return m_path.string();
    }

    std::string Path::ToString(std::string FileName) const
    {
        Path child = *this;
        child /= FileName;        
        return child.ToString();
    }

    void Path::Clear()
    {
        m_path.clear();
    }

    Path Path::RootName()
    {
        Path root(m_path.root_name().generic_string());
        return root;
    }

    Path Path::RootDirectory()
    {
        Path dir(m_path.root_directory().generic_string());
        return dir;
    }

    Path Path::RelativePath()
    {
        Path relative(m_path.relative_path().generic_string());
        return relative;
    }

    bool Path::IsEmpty()
    {
        return m_path.empty();
    }

    bool Path::HasRootPath()
    {
        return m_path.has_root_path();
    }

    bool Path::HasRootName()
    {
        return m_path.has_root_name();
    }

    bool Path::HasRootDirectory()
    {
        return m_path.has_root_directory();
    }

    bool Path::HasRelativePath()
    {
        return m_path.has_relative_path();
    }

    bool Path::HasParentPath()
    {
        return m_path.has_parent_path();
    }

    bool Path::IsAbsolute()
    {
        return m_path.is_absolute();
    }

    bool Path::IsRelative()
    {
        return m_path.is_relative();
    }

}}//qor::system
