// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"
#include "src/qor/injection/typeidentity.h"
#include "src/framework/thread/currentthread.h"
#include "src/qor/reference/newref.h"
#include "filesystem.h"
#include "path.h"

namespace qor{ namespace system{

    FileSystem::FileSystem()
    {
        m_pimpl = new_ref<IFileSystem>();
    }

    void FileSystem::Setup()
    {
        if(m_pimpl.IsNotNull())
        {
            Path::s_separator = m_pimpl->PathSeparator();
            Path::s_selfIndicator = m_pimpl->SelfIndicator();
            Path::s_parentIndicator = m_pimpl->ParentIndicator();
            Path::s_maxElementLength = m_pimpl->MaxElementLength();
            Path::s_rootIndicator = m_pimpl->RootIndicator();
        }
        m_root.Setup();
    }

    void FileSystem::Shutdown(){}

    const Root& FileSystem::GetRoot()
    {
        return m_root;
    }

    Path FileSystem::CurrentPath()
    {
        std::filesystem::path stdpath = std::filesystem::current_path();
        Path currentPath(stdpath.string());
        return currentPath;
    }

    void FileSystem::CurrentPath(Path& path)
    {
        std::filesystem::current_path(path);
    }

    ref_of<File>::type FileSystem::Create(const FileIndex& index, const int withFlags) const
    {
        return m_pimpl->Create(index, withFlags);
    }

    std::optional<Folder> FileSystem::Create(const Path& path) const
    {
        return m_pimpl->MakeDir(path);
    }

    bool FileSystem::Delete(const FileIndex& index) const
    {
        return m_pimpl->Delete(index);
    }

    bool FileSystem::Delete(const Path& path) const
    {
        return m_pimpl->RemoveDir(path);
    }

    ref_of<File>::type FileSystem::Open(const FileIndex& index, const int openFor, const int withFlags) const
    {
        return m_pimpl->Open(index, openFor, withFlags);
    }

    bool FileSystem::Copy(const system::FileIndex& srcIndex, const system::FileIndex& destIndex) const
    {
        return srcIndex.Copy(destIndex);
    }

    bool FileSystem::Move(const system::FileIndex& srcIndex, const system::FileIndex& destIndex) const
    {
        return srcIndex.Move(destIndex);
    }

    bool FileSystem::Rename(system::FileIndex& srcIndex, const system::FileIndex& destIndex) const
    {
        return srcIndex.Rename(destIndex);
    }

    std::filesystem::space_info Space(const Path& path)
    {
        return std::filesystem::space(path);
    }

    Path FileSystem::TempFolder()
    {
        Path tempPath(std::filesystem::temp_directory_path().generic_string());
        return tempPath;
    }

}}//qor::system
