// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"
#include "src/qor/injection/typeidentity.h"
#include "src/framework/thread/currentthread.h"
#include "src/qor/reference/newref.h"
#include "filesystem.h"
#include "path.h"

namespace qor{ namespace platform{

    FileSystem::FileSystem()
    {
        m_pimpl = new_ref<IFileSystem>();
    }

    void FileSystem::Setup()
    {
        if(m_pimpl.IsNotNull())
        {
            Path::s_separator = m_pimpl->PathSeparator();
            Path::s_selfIndicator = m_pimpl->SelfIndicator();
            Path::s_parentIndicator = m_pimpl->ParentIndicator();
            Path::s_maxElementLength = m_pimpl->MaxElementLength();
            Path::s_rootIndicator = m_pimpl->RootIndicator();
        }
        m_root.Setup();
    }

    void FileSystem::Shutdown(){}

    const Root& FileSystem::GetRoot()
    {
        return m_root;
    }

    Path FileSystem::CurrentPath()
    {
        std::filesystem::path stdpath = std::filesystem::current_path();
        Path currentPath(stdpath.string());
        return currentPath;
    }

    void FileSystem::CurrentPath(Path& path)
    {
        std::filesystem::current_path(path);
    }

    ref_of<IFile>::type FileSystem::Create(const FileIndex& index, const int withFlags) const
    {
        return m_pimpl->Create(index, withFlags);
    }

    std::optional<Folder> FileSystem::Create(const Path& path) const
    {
        return MakeDir(path);
    }

    std::optional<Folder> FileSystem::MakeDir(const Path& path) const
    {
        std::optional<Folder> folder;
        try{
            if(std::filesystem::create_directory(path))
            {
                folder.emplace(Folder(path));                
            }
        }
        catch(std::filesystem::filesystem_error& fse)
        {
            continuable(fse.what());
        }
        return folder;
    }

    std::optional<Folder> FileSystem::NewFolder(const Path& path) const
    {
        return MakeDir(path);
    }


    bool FileSystem::Delete(const FileIndex& index) const
    {
        try{
            return std::filesystem::remove(index.GetPath());
        }
        catch(std::filesystem::filesystem_error& fse)
        {
            continuable(fse.what());
        }
        return false;
    }

    bool FileSystem::RemoveDir(const Path& path) const
    {
        try
        {
            return std::filesystem::remove(path);
        }
        catch(std::filesystem::filesystem_error& fse)
        {
            continuable(fse.what());
        }
        return false;            
    }
    
    bool FileSystem::DeleteFolder(const Path& path) const
    {
        return RemoveDir(path);
    }

    ref_of<IFile>::type FileSystem::Open(const FileIndex& index, const int openFor, const int withFlags) const
    {
        return m_pimpl->Open(index, openFor, withFlags);
    }

    bool FileSystem::Copy(const platform::FileIndex& srcIndex, const platform::FileIndex& destIndex) const
    {
        try
        {
            std::filesystem::copy(srcIndex.GetPath(), destIndex.GetPath());
            return true;
        }
        catch(std::filesystem::filesystem_error& fse)
        {
            continuable(fse.what());
        }

        return false;
    }

    bool FileSystem::Move(const platform::FileIndex& srcIndex, const platform::FileIndex& destIndex) const
    {
        return srcIndex.Move(destIndex);
    }

    bool FileSystem::Rename(platform::FileIndex& srcIndex, const platform::FileIndex& destIndex) const
    {
        {
            try
            {
                std::filesystem::rename(srcIndex.GetPath(), destIndex.GetPath());
                return true;
            }
            catch(std::filesystem::filesystem_error& fse)
            {
                continuable(fse.what());
            }
            return false;
        }
    }

    std::filesystem::space_info Space(const Path& path)
    {
        return std::filesystem::space(path);
    }

    Path FileSystem::TempFolder()
    {
        Path tempPath(std::filesystem::temp_directory_path().generic_string());
        return tempPath;
    }

    Path FileSystem::ApplicationLogPath()
    {
        return m_pimpl->ApplicationLogPath();
    }

}}//qor::platform
