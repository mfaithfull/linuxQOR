// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_PLATFORM_NETWORK_WINDOWS_ADDRESSHELPERS
#define QOR_PP_H_PLATFORM_NETWORK_WINDOWS_ADDRESSHELPERS

#include <cstring>
#include <cassert>

#include <WinSock2.h>
#include <WS2tcpip.h>
#include <MSWSock.h>
#include <Windows.h>

#include "src/platform/network/ipendpoint.h"

namespace qor { namespace network { namespace nswindows {

	inline network::IPEndpoint sockaddr_to_ip_endpoint(const sockaddr& address) noexcept
	{
		if (address.sa_family == AF_INET)
		{
			SOCKADDR_IN ipv4Address;
			std::memcpy(&ipv4Address, &address, sizeof(ipv4Address));

			std::uint8_t addressBytes[4];
			std::memcpy(addressBytes, &ipv4Address.sin_addr, 4);

			return network::IPv4Endpoint{
				network::IPv4Address{ addressBytes },
				ntohs(ipv4Address.sin_port)
			};
		}
		else
		{
			assert(address.sa_family == AF_INET6);

			SOCKADDR_IN6 ipv6Address;
			std::memcpy(&ipv6Address, &address, sizeof(ipv6Address));

			return network::IPv6Endpoint{
				network::IPv6Address{ ipv6Address.sin6_addr.u.Byte },
				ntohs(ipv6Address.sin6_port)
			};
		}
	}

	inline int ip_endpoint_to_sockaddr(const network::IPEndpoint& endPoint, std::reference_wrapper<sockaddr_storage> address) noexcept
	{
		if (endPoint.is_ipv4())
		{
			const auto& ipv4EndPoint = endPoint.to_ipv4();

			SOCKADDR_IN ipv4Address;
			ipv4Address.sin_family = AF_INET;
			std::memcpy(&ipv4Address.sin_addr, ipv4EndPoint.address().bytes(), 4);
			ipv4Address.sin_port = htons(ipv4EndPoint.port());
			std::memset(&ipv4Address.sin_zero, 0, sizeof(ipv4Address.sin_zero));

			std::memcpy(&address.get(), &ipv4Address, sizeof(ipv4Address));

			return sizeof(SOCKADDR_IN);
		}
		else
		{
			const auto& ipv6EndPoint = endPoint.to_ipv6();

			SOCKADDR_IN6 ipv6Address;
			ipv6Address.sin6_family = AF_INET6;
			std::memcpy(&ipv6Address.sin6_addr, ipv6EndPoint.address().bytes(), 16);
			ipv6Address.sin6_port = htons(ipv6EndPoint.port());
			ipv6Address.sin6_flowinfo = 0;
			ipv6Address.sin6_scope_struct = SCOPEID_UNSPECIFIED_INIT;

			std::memcpy(&address.get(), &ipv6Address, sizeof(ipv6Address));

			return sizeof(SOCKADDR_IN6);
		}
	}

}}}//qor::network::nswindows

#endif//QOR_PP_H_PLATFORM_NETWORK_WINDOWS_ADDRESSHELPERS