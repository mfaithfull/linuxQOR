// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include "src/framework/thread/thread.h"
#include "socket.h"
#include "src/platform/os/windows/framework/asyncioservice/asyncioservice.h"

#include "src/platform/os/windows/api_layer/winsock2/ws2.h"

using namespace qor::framework::nswindows;
using namespace qor::nswindows::api;

namespace qor{ namespace network{ namespace nswindows{

    Socket::Socket()
    {
        m_socket = network::Socket::Invalid_Socket;
    }

    Socket::Socket(int sock)
    {
        m_socket = sock;
    }

    Socket::Socket(const Socket& src)
    {
        m_socket = src.m_socket;
    }

    Socket::Socket(const network::sockets::eAddressFamily AF, const network::sockets::eType Type, const network::sockets::eProtocol Protocol)
    {
        int domain = AddressFamilyToWindows(AF);        
        int type = TypeToWindows(Type, AF == network::sockets::eAddressFamily::AF_Unix ? true : false);
        int protocol = ProtocolToWindows(Protocol);
        //WSAPROTOCOL_INFO protocolInfo;
        unsigned long flags = WSA_FLAG_OVERLAPPED;
        m_socket = WS2::WSASocket(domain, type, protocol, nullptr, 0, flags);
    }
    
    Socket::~Socket()
    {
        closesocket(m_socket);
    }
    
    int32_t Socket::Bind(const qor::framework::AsyncIOInterface& ioContext, const network::Address& Address)
    {
        return sync_wait(ioContext.Bind(this, Address));
    }
    
    int32_t Socket::Listen(const qor::framework::AsyncIOInterface& ioContext, int32_t backlog)
    {
        return sync_wait(ioContext.Listen(this, backlog));
    }

    task<int32_t> Socket::AcceptAsync(const qor::framework::AsyncIOInterface& ioContext, network::Address& Address, network::Socket* Socket)
    {
        return ioContext.Accept(this, Address, Socket);
    }

    int32_t Socket::Bind(const network::Address& Address)
    {
        sockaddr_in addr;        
        memset(&addr, 0, sizeof(sockaddr_in));
        addr.sin_family = Address.sa_family;
        addr.sin_addr.s_addr = Address.sa.IPAddress.sin_addr.S_un.S_addr;
        addr.sin_port = Address.sa.IPAddress.sin_port;                
        return WS2::bind(m_socket, (struct sockaddr *)&addr, 16);
    }

    int32_t Socket::Listen(int32_t iBacklog)
    {
        return WS2::listen(m_socket, iBacklog);
    }
 
    ref_of<network::Socket>::type Socket::Accept(network::Address& Address)
    {
        ref_of<network::Socket>::type newsocket;
        sockaddr addr;
        socklen_t len = 0;
        SOCKET iresult = WS2::accept(m_socket, &addr, &len);
        if(iresult == -1)
        {
            //TODO:Raise error
        }
        else
        {
            newsocket = new_ref<Socket>(static_cast<int>(iresult)).AsRef<network::Socket>();
        }
        return newsocket;
    }
 
    int32_t Socket::Connect(const network::Address& Address)
    {
        sockaddr_in addr;
        memset(&addr, 0, sizeof(sockaddr_in));
        addr.sin_family = Address.sa_family;
        addr.sin_addr.s_addr = Address.sa.IPAddress.sin_addr.S_un.S_addr;
        addr.sin_port = Address.sa.IPAddress.sin_port;
        socklen_t len = sizeof(addr);
        return WS2::connect(m_socket, (const sockaddr*)&addr, len);
    }
 
    int32_t Socket::GetPeerName(network::Address& Address)
    {
        sockaddr addr;
        socklen_t len;
        return WS2::getpeername(m_socket, &addr, &len);
    }
 
    int32_t Socket::GetSockName(network::Address& Address)
    {
        sockaddr addr;
        socklen_t len;
        return WS2::getsockname(m_socket, &addr, &len);
    }
 
    int32_t Socket::GetSockOpt(int32_t level, int32_t optname, char* optval, int32_t* len)
    {
        return WS2::getsockopt(m_socket, level, optname, optval, (socklen_t*)&len);
    }
 
    int32_t Socket::SetSockOpt(int32_t level, int32_t optname, const char* optval, int32_t optlen)
    {
        return WS2::setsockopt(m_socket, level, optname, optval, optlen);
    }
 
    task<int32_t> Socket::AsyncReceive(const qor::framework::AsyncIOInterface& ioContext, char* pBuffer, int32_t iLen)
    {
        return ioContext.Recv(this, (byte*)pBuffer, iLen);
    }
 
    int32_t Socket::Receive(char* buf, int32_t len, int32_t flags)
    {
        return WS2::recv(m_socket, buf, len, flags);
    }

    int32_t Socket::Peek(char* buf, int32_t len)
    {
        return WS2::recv(m_socket, buf, len, MSG_PEEK);
    }
    
    int32_t Socket::ReceiveFrom(char* Buffer, int32_t iLen, int32_t iFlags, network::Address& From)
    {
        sockaddr_in addr;
        addr.sin_family = From.sa_family;
        addr.sin_addr.s_addr = From.sa.IPAddress.sin_addr.S_un.S_addr;
        addr.sin_port = From.sa.IPAddress.sin_port;
        socklen_t socklen = sizeof(addr);
        return WS2::recvfrom(m_socket, Buffer, iLen, iFlags, (sockaddr*)&addr, &socklen);
    }
 
    task<int32_t> Socket::AsyncSend(const qor::framework::AsyncIOInterface& ioContext, const char* Buffer, int32_t iLen)
    {
        return ioContext.Send(this, (byte*)Buffer, iLen, 0);
    }

    int32_t Socket::Send(const char* Buffer, int32_t iLen)
    {
        return WS2::send(m_socket, Buffer, iLen, 0);
    }
 
    int32_t Socket::SendTo(const char* Buffer, int32_t len, int32_t flags, const network::Address& To)
    {
        sockaddr_in addr;
        addr.sin_family = To.sa_family;
        addr.sin_addr.s_addr = To.sa.IPAddress.sin_addr.S_un.S_addr;
        addr.sin_port = To.sa.IPAddress.sin_port;
        return WS2::sendto(m_socket, Buffer, len, flags, (sockaddr*)&addr, len);
    }
 
    int32_t Socket::Shutdown(network::sockets::eShutdown how)
    {
        int iHow = 0;
        iHow = ( how & network::sockets::eShutdown::ShutdownRead ) ? SD_RECEIVE : iHow;
        iHow = ( how & network::sockets::eShutdown::ShutdownWrite ) ? SD_SEND : iHow;
        iHow = ( (how & network::sockets::eShutdown::ShutdownReadWrite) == 
            network::sockets::eShutdown::ShutdownReadWrite) ? SD_BOTH : iHow;
        return WS2::shutdown(m_socket, iHow);
    }
 
    std::size_t Socket::ID(void)
    {
        return m_socket;
    }
 
    int32_t Socket::GetLastError(void)
    {
        return WS2::WSAGetLastError();
    }

    bool Socket::SetNonBlocking(bool nonBlocking)
    {
        u_long mode = 1;  // 1 to enable non-blocking socket
        return WS2::ioctlsocket(m_socket, FIONBIO, &mode) == 0 ? true : false;
    }

    bool Socket::IsAlive()
    {        
        WSAPOLLFD fdArray[1];
        fdArray[0] = {
            .fd = m_socket,
            .events = POLLIN | POLLOUT,
            .revents = 0,
        };

        int result = WS2::WSAPoll(fdArray,1,0);
        if (result > 0) 
        {
            return true;
        } 
        return false;
    }

    bool Socket::SetRecvTimeout(time_t readTimeoutSec, time_t readTimeoutuSec)
    {
        timeval timeout;
        timeout.tv_sec = static_cast<long>(readTimeoutSec);
        timeout.tv_usec = static_cast<decltype(timeout.tv_usec)>(readTimeoutuSec);

        return SetSockOpt(SOL_SOCKET, SO_RCVTIMEO, (const char*)&timeout, sizeof(timeout)) == 0;
    }
                    
    bool Socket::SetSendTimeout(time_t writeTimeoutSec, time_t writeTimeoutuSec)
    {
        timeval timeout;
        timeout.tv_sec = static_cast<long>(writeTimeoutSec);
        timeout.tv_usec = static_cast<decltype(timeout.tv_usec)>(writeTimeoutuSec);

        return SetSockOpt(SOL_SOCKET, SO_SNDTIMEO, (const char*)&timeout, sizeof(timeout)) == 0;
    }

    bool Socket::SetTCPNoDelay(bool nodelay)
    {
        int noDelayOpt = nodelay ? 1 : 0;
        return SetSockOpt(IPPROTO_TCP, TCP_NODELAY, (const char*)&noDelayOpt, sizeof(int)) == 0;
        return false;
    }

    bool Socket::SetIPv6Only(bool ipv6Only)
    {
        int ipv6onlyOption = ipv6Only ? 1 : 0;
        return SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, (const char*)&ipv6onlyOption, sizeof(int)) == 0;
    }

    int Socket::AddressFamilyToWindows(const network::sockets::eAddressFamily& AF)
    {
        int domain = AF_UNSPEC;

        switch(AF)
        {
            case network::sockets::eAddressFamily::AF_Unspecified:
                domain = AF_UNSPEC;
                break;
            case network::sockets::eAddressFamily::AF_Unix:
                domain = AF_UNIX;
                break;
            case network::sockets::eAddressFamily::AF_INet:
                domain = AF_INET;
                break;
        }
        return domain;
    }

    network::sockets::eAddressFamily Socket::AddressFamilyFromWindows(int domain)
    {
        network::sockets::eAddressFamily result = network::sockets::eAddressFamily::AF_Unspecified;
        switch(domain)
        {
            case AF_UNSPEC:
                result = network::sockets::eAddressFamily::AF_Unspecified;
                break;
            case AF_UNIX:
                result = network::sockets::eAddressFamily::AF_Unix;
                break;
            case AF_INET:
                result = network::sockets::eAddressFamily::AF_INet;
                break;
        }
        return result;
    }

    network::sockets::eType Socket::TypeFromWindows(int type)
    {
        network::sockets::eType result = network::sockets::eType::Sock_Stream;
#ifdef SOCK_CLOEXEC
        type = type & ~SOCK_CLOEXEC;
#endif
        switch (type)
        {
            case SOCK_STREAM:
                result = network::sockets::eType::Sock_Stream;
                break;
            case SOCK_DGRAM:
                result = network::sockets::eType::Sock_DGram;
                break;
            case SOCK_RAW:
                result = network::sockets::eType::Sock_Raw;
                break;
            case SOCK_RDM:
                result = network::sockets::eType::Sock_ReliablyDeliveredMessage;
                break;
            case SOCK_SEQPACKET:
                result = network::sockets::eType::Sock_SeqPacket;
                break;
        }
        return result;
    }

    int Socket::TypeToWindows(const network::sockets::eType& Type, bool closeOnExec)
    {
        int type = SOCK_STREAM;
        switch(Type)
        {
            case network::sockets::eType::Sock_Stream:
                type = SOCK_STREAM;
                break;
            case network::sockets::eType::Sock_DGram:
                type = SOCK_DGRAM;
                break;
            case network::sockets::eType::Sock_Raw:
                type = SOCK_RAW;
                break;
            case network::sockets::eType::Sock_ReliablyDeliveredMessage:
                type = SOCK_RDM;
                break;
            case network::sockets::eType::Sock_SeqPacket:
                type = SOCK_SEQPACKET;
        }

#ifdef SOCK_CLOEXEC
        if(closeOnExec)
        {
            type |= SOCK_CLOEXEC;
        }
#endif
        return type;
    }

    network::sockets::eProtocol Socket::ProtocolFromWindows(int protocol)
    {
        network::sockets::eProtocol result = network::sockets::eProtocol::IPProto_IP;
        switch(protocol)
        {
            case IPPROTO_IP:
                result = network::sockets::eProtocol::IPProto_IP;
                break;
            case IPPROTO_ICMP:
                result = network::sockets::eProtocol::IPProto_ICMP;
                break;
            case IPPROTO_IGMP:
                result = network::sockets::eProtocol::IPProto_IGMP;
                break;
            case IPPROTO_TCP:
                result = network::sockets::eProtocol::IPProto_TCP;
                break;
            case IPPROTO_PUP:
                result = network::sockets::eProtocol::IPProto_PUP;
                break;
            case IPPROTO_UDP:
                result = network::sockets::eProtocol::IPProto_UDP;
                break;
            case IPPROTO_IDP:
                result = network::sockets::eProtocol::IPProto_IDP;
                break;
            case IPPROTO_RAW:
                result = network::sockets::eProtocol::IPProto_RAW;
                break;
        }
        return result;
    }

    int Socket::ProtocolToWindows(const network::sockets::eProtocol& Protocol)
    {
        int protocol = IPPROTO_IP;
        switch(Protocol)
        {
            case network::sockets::eProtocol::IPProto_IP:
                protocol = IPPROTO_IP;
                break;
            case network::sockets::eProtocol::IPProto_ICMP:
                protocol = IPPROTO_ICMP;
                break;
            case network::sockets::eProtocol::IPProto_IGMP:
                protocol = IPPROTO_IGMP;
                break;
            case network::sockets::eProtocol::IPProto_GGP:
                break;
            case network::sockets::eProtocol::IPProto_TCP:
                protocol = IPPROTO_TCP;
                break;
            case network::sockets::eProtocol::IPProto_PUP:
                protocol = IPPROTO_PUP;
                break;
            case network::sockets::eProtocol::IPProto_UDP:
                protocol = IPPROTO_UDP;
                break;
            case network::sockets::eProtocol::IPProto_IDP:
                protocol = IPPROTO_IDP;
                break;
            case network::sockets::eProtocol::IPProto_ND:
                break;
            case network::sockets::eProtocol::IPProto_RAW:
                protocol = IPPROTO_RAW;
                break;
            case network::sockets::eProtocol::IPProto_MAX:
                protocol = IPPROTO_MAX;
                break;
        }
        return protocol;
    }

}}}//qor::network::nswindows
