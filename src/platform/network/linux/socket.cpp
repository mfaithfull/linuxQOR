// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"
#include "src/framework/thread/thread.h"
#include "socket.h"
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <fcntl.h>
#include <poll.h>
#include "src/platform/os/linux/framework/asyncioservice/asyncioservice.h"
#include "src/platform/os/linux/framework/asyncioservice/iouringservice/readop.h"

using namespace qor::nslinux::framework;

namespace qor{ namespace nslinux{

    Socket::Socket()
    {
        m_sock = network::Socket::Invalid_Socket;
    }

    Socket::Socket(int sock) : m_sock(sock)
    {
    }

    Socket::Socket(const Socket& src)
    {
        m_sock = ::fcntl(src.m_sock, F_DUPFD, 0);
    }

    Socket::Socket(const network::sockets::eAddressFamily& AF, const network::sockets::eType& Type, const network::sockets::eProtocol& Protocol)
    {
        int domain = AddressFamilyToLinux(AF);        
        int type = TypeToLinux(Type, AF == network::sockets::eAddressFamily::AF_Unix ? true : false);
        int protocol = ProtocolToLinux(Protocol);
        m_sock = ::socket(domain, type, protocol);
    }
    
    Socket::~Socket()
    {
        ::close(m_sock);
    }
    
    int32_t Socket::Bind(const network::Address& Address)
    {
        sockaddr_in addr;
        addr.sin_family = Address.sa_family;
        addr.sin_addr.s_addr = Address.sa.IPAddress.sin_addr.S_un.S_addr;
        addr.sin_port = Address.sa.IPAddress.sin_port;                
        return ::bind(m_sock, (struct sockaddr *)&addr, sizeof(addr));
    }
    
    int32_t Socket::Listen(int32_t iBacklog)
    {
        return ::listen(m_sock, iBacklog);
    }
 
    ref_of<network::Socket>::type Socket::Accept(network::Address& Address)
    {
        ref_of<network::Socket>::type newsocket;
        sockaddr addr;
        socklen_t len = 0;
        int iresult = ::accept(m_sock, &addr, &len);
        if(iresult == -1)
        {
            //TODO:Raise error
        }
        else
        {
            newsocket = new_ref<Socket>(iresult).AsRef<network::Socket>();
        }
        return newsocket;
    }
 
    int32_t Socket::Connect(const network::Address& Address)
    {
        sockaddr_in addr;
        memset(&addr, 0, sizeof(sockaddr_in));
        addr.sin_family = Address.sa_family;
        addr.sin_addr.s_addr = Address.sa.IPAddress.sin_addr.S_un.S_addr;
        addr.sin_port = Address.sa.IPAddress.sin_port;
        socklen_t len = sizeof(addr);
        return ::connect(m_sock, (const sockaddr*)&addr, len);
    }
 
    int32_t Socket::GetPeerName(network::Address& Address)
    {
        sockaddr addr;
        socklen_t len;
        return ::getpeername(m_sock, &addr, &len);
    }
 
    int32_t Socket::GetSockName(network::Address& Address)
    {
        sockaddr addr;
        socklen_t len;
        return ::getsockname(m_sock, &addr, &len);
    }
 
    int32_t Socket::GetSockOpt(int32_t level, int32_t optname, char* optval, int32_t* len)
    {
        return ::getsockopt(m_sock, level, optname, optval, (socklen_t*)&len);
    }
 
    int32_t Socket::SetSockOpt(int32_t level, int32_t optname, const char* optval, int32_t optlen)
    {
        return ::setsockopt(m_sock, level, optname, optval, optlen);
    }
 
    qor::framework::IOTask Socket::AsyncReceive(qor::framework::AbstractIOWaiter& ioWaiter, char* pBuffer, int32_t iLen, void* pSyncObject)
    {
        return ioWaiter.Read(m_sock, (byte*)pBuffer, iLen);
        //co_await pool.Schedule();
    }
 
    int32_t Socket::Receive(char* buf, int32_t len, int32_t flags)
    {
        return ::recv(m_sock, buf, len, flags);
    }

    int32_t Socket::Peek(char* buf, int32_t len)
    {
        return ::recv(m_sock, buf, len, MSG_PEEK);
    }
    
    int32_t Socket::ReceiveFrom(char* Buffer, int32_t iLen, int32_t iFlags, network::Address& From)
    {
        sockaddr_in addr;
        addr.sin_family = From.sa_family;
        addr.sin_addr.s_addr = From.sa.IPAddress.sin_addr.S_un.S_addr;
        addr.sin_port = From.sa.IPAddress.sin_port;
        socklen_t socklen = sizeof(addr);
        return ::recvfrom(m_sock, Buffer, iLen, iFlags, (sockaddr*)&addr, &socklen);
    }
 
    int32_t Socket::AsyncSend(char* Buffer, int32_t iLen, void* pSyncObject)
    {
        return -1;
    }
 
    int32_t Socket::Send(const char* Buffer, int32_t iLen)
    {
        return ::send(m_sock, Buffer, iLen, 0);
    }
 
    int32_t Socket::SendTo(const char* Buffer, int32_t len, int32_t flags, const network::Address& To)
    {
        sockaddr_in addr;
        addr.sin_family = To.sa_family;
        addr.sin_addr.s_addr = To.sa.IPAddress.sin_addr.S_un.S_addr;
        addr.sin_port = To.sa.IPAddress.sin_port;
        return ::sendto(m_sock, Buffer, len, flags, (sockaddr*)&addr, len);
    }
 
    int32_t Socket::Shutdown(network::sockets::eShutdown how)
    {
        int iHow = 0;
        iHow = ( how & network::sockets::eShutdown::ShutdownRead ) ? SHUT_RD : iHow;
        iHow = ( how & network::sockets::eShutdown::ShutdownWrite ) ? SHUT_WR : iHow;
        iHow = ( how & network::sockets::eShutdown::ShutdownReadWrite ) ? SHUT_RDWR : iHow;
        return ::shutdown(m_sock, iHow);
    }
 
    std::size_t Socket::ID(void)
    {
        return m_sock;
    }
 
    int32_t Socket::GetLastError(void)
    {
        return -1;
    }

    bool Socket::SetNonBlocking(bool nonBlocking)
    {
        auto flags = ::fcntl(m_sock, F_GETFL, 0);
        return fcntl(m_sock, F_SETFL, nonBlocking ? (flags | O_NONBLOCK) : (flags & (~O_NONBLOCK))) == 0 ? true : false;
    }

    ssize_t Socket::PollWaitForInput(time_t sec, time_t usec)
    {
        struct pollfd pfd;
        pfd.fd = m_sock;
        pfd.events = POLLIN;
        auto timeout = static_cast<int>(sec * 1000 + usec / 1000);
        return handle_EINTR([&]() { return ::poll(&pfd, 1, timeout); });
    }

    ssize_t Socket::PollWaitForOutput(time_t sec, time_t usec)
    {
        struct pollfd pfd;
        pfd.fd = m_sock;
        pfd.events = POLLOUT;
        auto timeout = static_cast<int>(sec * 1000 + usec / 1000);
        return handle_EINTR([&]() { return ::poll(&pfd, 1, timeout); });
    }


    bool Socket::IsAlive()
    {        
        const auto val = PollWaitForInput(0, 0);
        if (val == 0) 
        {
            return true;
        } 
        else if (val < 0 && errno == EBADF) 
        {
            return false;
        }
        char buf[1];
        return ::recv(m_sock,&buf[0], sizeof(buf),MSG_PEEK) > 0;
    }

    bool Socket::SetRecvTimeout(time_t readTimeoutSec, time_t readTimeoutuSec)
    {
        timeval timeout;
        timeout.tv_sec = static_cast<long>(readTimeoutSec);
        timeout.tv_usec = static_cast<decltype(timeout.tv_usec)>(readTimeoutuSec);

        return SetSockOpt(SOL_SOCKET, SO_RCVTIMEO, (const char*)&timeout, sizeof(timeout)) == 0;
    }
                    
    bool Socket::SetSendTimeout(time_t writeTimeoutSec, time_t writeTimeoutuSec)
    {
        timeval timeout;
        timeout.tv_sec = static_cast<long>(writeTimeoutSec);
        timeout.tv_usec = static_cast<decltype(timeout.tv_usec)>(writeTimeoutuSec);

        return SetSockOpt(SOL_SOCKET, SO_SNDTIMEO, (const char*)&timeout, sizeof(timeout)) == 0;
    }

    bool Socket::SetTCPNoDelay(bool nodelay)
    {
        int noDelayOpt = nodelay ? 1 : 0;
        return SetSockOpt(SOL_TCP, TCP_NODELAY, (const char*)&noDelayOpt, sizeof(int)) == 0;
    }

    bool Socket::SetIPv6Only(bool ipv6Only)
    {
        int ipv6onlyOption = ipv6Only ? 1 : 0;
        return SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, (const char*)&ipv6onlyOption, sizeof(int)) == 0;
    }

    int Socket::AddressFamilyToLinux(const network::sockets::eAddressFamily& AF)
    {
        int domain = AF_UNSPEC;

        switch(AF)
        {
            case network::sockets::eAddressFamily::AF_Unspecified:
                domain = AF_UNSPEC;
                break;
            case network::sockets::eAddressFamily::AF_Unix:
                domain = AF_UNIX;
                break;
            case network::sockets::eAddressFamily::AF_INet:
                domain = AF_INET;
                break;
        }
        return domain;
    }

    network::sockets::eAddressFamily Socket::AddressFamilyFromLinux(int domain)
    {
        network::sockets::eAddressFamily result = network::sockets::eAddressFamily::AF_Unspecified;
        switch(domain)
        {
            case AF_UNSPEC:
                result = network::sockets::eAddressFamily::AF_Unspecified;
                break;
            case AF_UNIX:
                result = network::sockets::eAddressFamily::AF_Unix;
                break;
            case AF_INET:
                result = network::sockets::eAddressFamily::AF_INet;
                break;
        }
        return result;
    }

    network::sockets::eType Socket::TypeFromLinux(int type)
    {
        network::sockets::eType result = network::sockets::eType::Sock_Stream;
#ifdef SOCK_CLOEXEC
        type = type & ~SOCK_CLOEXEC;
#endif
        switch (type)
        {
            case SOCK_STREAM:
                result = network::sockets::eType::Sock_Stream;
                break;
            case SOCK_DGRAM:
                result = network::sockets::eType::Sock_DGram;
                break;
            case SOCK_RAW:
                result = network::sockets::eType::Sock_Raw;
                break;
            case SOCK_RDM:
                result = network::sockets::eType::Sock_ReliablyDeliveredMessage;
                break;
            case SOCK_SEQPACKET:
                result = network::sockets::eType::Sock_SeqPacket;
                break;
        }
        return result;
    }

    int Socket::TypeToLinux(const network::sockets::eType& Type, bool closeOnExec)
    {
        int type = SOCK_STREAM;
        switch(Type)
        {
            case network::sockets::eType::Sock_Stream:
                type = SOCK_STREAM;
                break;
            case network::sockets::eType::Sock_DGram:
                type = SOCK_DGRAM;
                break;
            case network::sockets::eType::Sock_Raw:
                type = SOCK_RAW;
                break;
            case network::sockets::eType::Sock_ReliablyDeliveredMessage:
                type = SOCK_RDM;
                break;
            case network::sockets::eType::Sock_SeqPacket:
                type = SOCK_SEQPACKET;
        }

#ifdef SOCK_CLOEXEC
        if(closeOnExec)
        {
            type |= SOCK_CLOEXEC;
        }
#endif
        return type;
    }

    network::sockets::eProtocol Socket::ProtocolFromLinux(int protocol)
    {
        network::sockets::eProtocol result = network::sockets::eProtocol::IPProto_IP;
        switch(protocol)
        {
            case IPPROTO_IP:
                result = network::sockets::eProtocol::IPProto_IP;
                break;
            case IPPROTO_ICMP:
                result = network::sockets::eProtocol::IPProto_ICMP;
                break;
            case IPPROTO_IGMP:
                result = network::sockets::eProtocol::IPProto_IGMP;
                break;
            case IPPROTO_TCP:
                result = network::sockets::eProtocol::IPProto_TCP;
                break;
            case IPPROTO_PUP:
                result = network::sockets::eProtocol::IPProto_PUP;
                break;
            case IPPROTO_UDP:
                result = network::sockets::eProtocol::IPProto_UDP;
                break;
            case IPPROTO_IDP:
                result = network::sockets::eProtocol::IPProto_IDP;
                break;
            case IPPROTO_RAW:
                result = network::sockets::eProtocol::IPProto_RAW;
                break;
        }
        return result;
    }

    int Socket::ProtocolToLinux(const network::sockets::eProtocol& Protocol)
    {
        int protocol = IPPROTO_IP;
        switch(Protocol)
        {
            case network::sockets::eProtocol::IPProto_IP:
                protocol = IPPROTO_IP;
                break;
            case network::sockets::eProtocol::IPProto_ICMP:
                protocol = IPPROTO_ICMP;
                break;
            case network::sockets::eProtocol::IPProto_IGMP:
                protocol = IPPROTO_IGMP;
                break;
            case network::sockets::eProtocol::IPProto_GGP:
                break;
            case network::sockets::eProtocol::IPProto_TCP:
                protocol = IPPROTO_TCP;
                break;
            case network::sockets::eProtocol::IPProto_PUP:
                protocol = IPPROTO_PUP;
                break;
            case network::sockets::eProtocol::IPProto_UDP:
                protocol = IPPROTO_UDP;
                break;
            case network::sockets::eProtocol::IPProto_IDP:
                protocol = IPPROTO_IDP;
                break;
            case network::sockets::eProtocol::IPProto_ND:
                break;
            case network::sockets::eProtocol::IPProto_RAW:
                protocol = IPPROTO_RAW;
                break;
            case network::sockets::eProtocol::IPProto_MAX:
                protocol = IPPROTO_MAX;
                break;
        }
        return protocol;
    }
}}//qor::nslinux
