// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include <iostream>

#include "opengles.h"
#include <GLES3/gl32.h>
#include <GLES3/gl3ext.h>

namespace qor{ bool qor_pp_module_interface(QOR_LINOPENGLES) ImplementsOpenGLESFeature() { return true; } }//qor

namespace qor{ namespace platform { namespace nslinux{

    void OpenGLES::CheckStatus()
    {
        unsigned int err = GetError();
        if(err == 0)
        {
            return;
        }
        else
        {
            std::cout << "OpenGL|ES Status: " << err << std::endl;
        }

    }

    const byte* OpenGLES::GetString(unsigned int name)
    {
        return glGetString(name);
    }

    unsigned int OpenGLES::GetError()
    {
        return glGetError();
    }

    void OpenGLES::GenBuffers(int n, unsigned int* buffers)
    {
        glGenBuffers(n, buffers);
        CheckStatus();
    }

    void OpenGLES::DeleteBuffers(int n, const unsigned int* buffers)
    {
        glDeleteBuffers(n, buffers);
        CheckStatus();
    }

    void OpenGLES::GenVertexArrays (int n, unsigned int* arrays)
    {
        glGenVertexArrays(n, arrays);
        CheckStatus();
    }

    void OpenGLES::DeleteVertexArrays(int n, const unsigned int* arrays)
    {
        glDeleteVertexArrays(n, arrays);
        CheckStatus();
    }

    void OpenGLES::GenFrameBuffers(int n, unsigned int* frameBuffers)
    {
        glGenFramebuffers(n, frameBuffers);
        CheckStatus();
    }

    void OpenGLES::BindFrameBuffer(unsigned int target, unsigned int framebuffer)
    {
        glBindFramebuffer(target, framebuffer);
        CheckStatus();
    }

    void OpenGLES::GenRenderBuffers(int n, unsigned int* renderBuffers)
    {
        glGenRenderbuffers(n, renderBuffers);
        CheckStatus();
    }

    void OpenGLES::BindRenderBuffer(unsigned int target, unsigned int renderBuffer)
    {
        glBindRenderbuffer(target, renderBuffer);
        CheckStatus();
    }

    void OpenGLES::RenderBufferStorageMultisample(unsigned int target, int samples, unsigned int internalformat, int width, int height)
    {
        glRenderbufferStorageMultisample(target, samples, internalformat, width, height);
        CheckStatus();
    }

    void OpenGLES::FrameBufferRenderBuffer(unsigned int target, unsigned int attachment, unsigned int renderbuffertarget, unsigned int renderbuffer)
    {
        glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
        CheckStatus();
    }

    void OpenGLES::GenTextures(int n, unsigned int* textures)
    {
        glGenTextures(n, textures);
        CheckStatus();
    }

    void OpenGLES::BindTexture(unsigned int target, unsigned int texture)
    {
        glBindTexture(target, texture);
        CheckStatus();
    }

    void OpenGLES::TexImage2D(unsigned int target, int level, int internalformat, int width, int height, int border, unsigned int format, unsigned int type, const void *pixels)
    {
        glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
        CheckStatus();
    }
        
    void OpenGLES::TexParameteri(unsigned int target, unsigned int pname, int param)
    {
        glTexParameteri(target, pname, param);
        CheckStatus();
    }

    void OpenGLES::FrameBufferTexture2D(unsigned int target, unsigned int attachment, unsigned int textarget, unsigned int texture, int level)
    {
        glFramebufferTexture2D(target, attachment, textarget, texture, level);
        CheckStatus();
    }

    void OpenGLES::DeleteFrameBuffers(int n, const unsigned int* framebuffers)
    {
        glDeleteFramebuffers(n, framebuffers);
        CheckStatus();
    }

    void OpenGLES::DeleteRenderBuffers(int n, const unsigned int* renderbuffers)
    {
        glDeleteRenderbuffers (n, renderbuffers);
        CheckStatus();
    }

    void OpenGLES::DeleteTextures(int n, const unsigned int* textures)
    {
        glDeleteTextures(n, textures);
        CheckStatus();
    }

    unsigned int OpenGLES::CreateShader(unsigned int type)
    {
        return glCreateShader(type);
    }

    void OpenGLES::ShaderSource(unsigned int shader, int count, const char* const* string, const int* length)
    {
        glShaderSource(shader, count, string, length);
        CheckStatus();
    }

    void OpenGLES::CompileShader(unsigned int shader)
    {
        glCompileShader(shader);
        CheckStatus();
    }

    void OpenGLES::GetShaderiv(unsigned int shader, unsigned int pname, int* params)
    {
        glGetShaderiv(shader, pname, params);
        CheckStatus();
    }

    void OpenGLES::GetShaderInfoLog(unsigned int shader, int bufSize, int* length, char* infoLog)
    {
        glGetShaderInfoLog(shader, bufSize, length, infoLog);
        CheckStatus();
    }

    void OpenGLES::DeleteShader(unsigned int shader)
    {
        glDeleteShader(shader);
        CheckStatus();
    }

    unsigned int OpenGLES::CreateProgram(void)
    {
        return glCreateProgram();        
    }

    void OpenGLES::AttachShader(unsigned int program, unsigned int shader)
    {
        glAttachShader(program, shader);
        CheckStatus();
    }

    void OpenGLES::LinkProgram(unsigned int program)
    {
        glLinkProgram(program);
        CheckStatus();
    }

    void OpenGLES::GetProgramiv(unsigned int program, unsigned int pname, int* params)
    {
        glGetProgramiv(program, pname, params);
        CheckStatus();
    }

    void OpenGLES::GetProgramInfoLog(unsigned int program, int bufSize, int* length, char* infoLog)
    {
        glGetProgramInfoLog(program, bufSize, length, infoLog);
        CheckStatus();
    }

    void OpenGLES::DeleteProgram(unsigned int program)
    {
        glDeleteProgram(program);
        CheckStatus();
    }

    void OpenGLES::UseProgram(unsigned int program)
    {
       glUseProgram(program);
       CheckStatus();
    }

    int OpenGLES::GetAttribLocation(unsigned int program, const char* name)
    {
        return glGetAttribLocation(program, name);
    }

    int OpenGLES::GetUniformLocation(unsigned int program, const char* name)
    {
       return glGetUniformLocation(program, name);
    }

    unsigned int OpenGLES::GetUniformBlockIndex(unsigned int program, const char* uniformBlockName)
    {
        return glGetUniformBlockIndex(program, uniformBlockName);
    }

    void OpenGLES::Uniform1iv(int location, int count, const int* value)
    {
        glUniform1iv (location, count, value);
        CheckStatus();
    }

    void OpenGLES::GetIntegerv(unsigned long pname, int* data)
    {
        glGetIntegerv(pname, data);
        CheckStatus();
    }

    void OpenGLES::BlendFunc(unsigned int sfactor, unsigned int dfactor)
    {
        glBlendFunc(sfactor, dfactor);
        CheckStatus();
    }

    void OpenGLES::Enable(unsigned int cap)
    {
        glEnable(cap);
        CheckStatus();
    }

    void OpenGLES::CullFace(unsigned int mode)
    {
        glCullFace(mode);
        CheckStatus();
    }

    void OpenGLES::FrontFace(unsigned int mode)
    {
        glFrontFace(mode);
        CheckStatus();
    }

    void OpenGLES::DepthFunc(unsigned int func)
    {
        glDepthFunc(func);
        CheckStatus();
    }

    void OpenGLES::Disable(unsigned int cap)
    {
        glDisable(cap);
        CheckStatus();
    }

    void OpenGLES::BindBuffer(unsigned int target, unsigned int buffer)
    {
        glBindBuffer(target, buffer);
        CheckStatus();
    }

    void OpenGLES::BufferData(unsigned int target, signed long long size, const void *data, unsigned int usage)
    {   
        glBufferData(target, size, data, usage);
        CheckStatus();
    }

    void OpenGLES::BindVertexArray(unsigned int array)
    {
        glBindVertexArray(array);
        CheckStatus();
    }

    void OpenGLES::Viewport(int x, int y, int width, int height)
    {
        glViewport(x, y, width, height);
        CheckStatus();
    }

    void OpenGLES::Scissor(int x, int y, int width, int height)
    {
        glScissor(x, y, width, height);
        CheckStatus();
    }

    void OpenGLES::BlitFrameBuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, unsigned int mask, unsigned int filter)
    {
        glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
        CheckStatus();
    }

    void OpenGLES::ClearColour(float red, float green, float blue, float alpha)
    {
        glClearColor(red, green, blue, alpha);
        CheckStatus();
    }

    void OpenGLES::Clear(unsigned int mask)
    {
        glClear(mask);
        CheckStatus();
    }

    void OpenGLES::ClearStencil(int s)
    {
        glClearStencil(s);
        CheckStatus();
    }

    void OpenGLES::ClearDepthf(float d)
    { 
        glClearDepthf(d);
        CheckStatus();
    }

    void OpenGLES::DepthMask(unsigned char flag)
    {
        glDepthMask(flag);
        CheckStatus();
    }

    void OpenGLES::StencilFunc(unsigned int func, int ref, unsigned int mask)
    {
        glStencilFunc(func, ref, mask);
        CheckStatus();
    }

    void OpenGLES::StencilOp(unsigned int fail, unsigned int zfail, unsigned int zpass)
    {
        glStencilOp(fail, zfail, zpass);
        CheckStatus();
    }

    void OpenGLES::StencilFuncSeparate(unsigned int face, unsigned int func, int ref, unsigned int mask)
    {
        glStencilFuncSeparate(face, func, ref, mask);
        CheckStatus();
    }

    void OpenGLES::StencilOpSeparate(unsigned int face, unsigned int sfail, unsigned int dpfail, unsigned int dppass)
    { 
        glStencilOpSeparate(face, sfail, dpfail, dppass);
        CheckStatus();
    }

    void OpenGLES::ColourMask(unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha)
    {
        glColorMask(red, green, blue, alpha);
        CheckStatus();
    }

    void OpenGLES::Uniform1f(int location, float v0)
    { 
        glUniform1f(location, v0);
        CheckStatus();
    }

    void OpenGLES::EnableVertexAttribArray(unsigned int index)
    { 
        glEnableVertexAttribArray(index);
        CheckStatus();
    }

    void OpenGLES::VertexAttribPointer(unsigned int index, int size, unsigned int type, unsigned char normalized, int stride, const void* pointer)
    { 
        glVertexAttribPointer(index, size, type, normalized, stride, pointer);
        CheckStatus();
    }

    void OpenGLES::ActiveTexture(unsigned int texture)
    { 
        glActiveTexture(texture);
        CheckStatus();
    }

    void OpenGLES::UniformBlockBinding(unsigned int program, unsigned int uniformBlockIndex, unsigned int uniformBlockBinding)
    { 
        glUniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);
        CheckStatus();
    }

    void OpenGLES::BindBufferRange(unsigned int target, unsigned int index, unsigned int buffer, signed long long offset, signed long long size)
    {
        glBindBufferRange(target, index, buffer, offset, size);
        CheckStatus();
    }

    void OpenGLES::DrawElements(unsigned int mode, int count, unsigned int type, const void* indices)
    {
        glDrawElements(mode, count, type, indices);
        CheckStatus();
    }

    void OpenGLES::DisableVertexAttribArray(unsigned int index)
    { 
        glDisableVertexAttribArray(index);
        CheckStatus();
    }

    void OpenGLES::InvalidateFramebuffer(unsigned int target, int numAttachments, const unsigned int* attachments)
    { 
        glInvalidateFramebuffer(target, numAttachments, attachments);
        CheckStatus();
    }

}}}//qor::platform::nslinux
