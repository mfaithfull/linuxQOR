// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include "egl.h"
#include "display.h"
#include "window.h"

namespace qor{ bool qor_pp_module_interface(QOR_LINEGL) ImplementsEGLFeature() { return true; } }//qor

namespace qor{ namespace platform { namespace nslinux{

    EGLDisplay EGL::StaticGetDisplay (EGLNativeDisplayType display_id)
    {
        return ::eglGetDisplay(display_id);
    }

    bool EGL::StaticChooseConfig(EGLDisplay dpy, const int32_t* attrib_list, EGLConfig* configs, int32_t config_size, int32_t* num_config)
    {
        return ::eglChooseConfig(dpy, attrib_list, configs, config_size, num_config) ? true : false;
    }

    bool EGL::StaticCopyBuffers(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target)
    {
        return ::eglCopyBuffers(dpy, surface, target);
    }

    EGLContext EGL::StaticCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *attrib_list)
    {
        return ::eglCreateContext(dpy, config, share_context, attrib_list);
    }

    EGLSurface EGL::StaticCreatePbufferSurface(EGLDisplay dpy, EGLConfig config, const EGLint *attrib_list)
    {
        return ::eglCreatePbufferSurface(dpy, config, attrib_list);
    }

    EGLSurface EGL::StaticCreatePixmapSurface(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint *attrib_list)
    {
        return ::eglCreatePixmapSurface(dpy, config, pixmap, attrib_list);
    }

    EGLSurface EGL::StaticCreateWindowSurface(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint *attrib_list)
    {
        return ::eglCreateWindowSurface(dpy, config, win, attrib_list);
    }

    bool EGL::StaticDestroyContext(EGLDisplay dpy, EGLContext ctx)
    {
        return ::eglDestroyContext(dpy, ctx) ? true : false;
    }

    bool EGL::StaticDestroySurface(EGLDisplay dpy, EGLSurface surface)
    {
        return ::eglDestroySurface(dpy, surface) ? true : false;
    }

    bool EGL::StaticGetConfigAttrib(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *value)
    {
        return ::eglGetConfigAttrib(dpy, config, attribute, value) ? true : false;
    }

    bool EGL::StaticGetConfigs(EGLDisplay dpy, EGLConfig *configs, EGLint config_size, EGLint *num_config)
    {
        return ::eglGetConfigs(dpy, configs, config_size, num_config) ? true : false;
    }

    EGLDisplay EGL::StaticGetCurrentDisplay(void)
    {
        return ::eglGetCurrentDisplay();
    }

    EGLSurface EGL::StaticGetCurrentSurface(EGLint readdraw)
    {
        return ::eglGetCurrentSurface(readdraw);
    }

    EGLint EGL::StaticGetError(void)
    {
        return ::eglGetError();
    }

    __eglMustCastToProperFunctionPointerType EGL::StaticGetProcAddress(const char *procname)
    {
        return ::eglGetProcAddress(procname);
    }

    bool EGL::StaticInitialize(EGLDisplay dpy, EGLint *major, EGLint *minor)
    {
        return ::eglInitialize(dpy, major, minor) ? true : false;
    }

    bool EGL::StaticMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx)
    {
        return ::eglMakeCurrent(dpy, draw, read, ctx) ? true : false;
    }

    bool EGL::StaticQueryContext(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint *value)
    {
        return ::eglQueryContext(dpy, ctx, attribute, value) ? true : false;
    }

    const char* EGL::StaticQueryString(EGLDisplay dpy, EGLint name)
    {
        return ::eglQueryString(dpy, name);
    }

    bool EGL::StaticQuerySurface(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint *value)
    {
        return ::eglQuerySurface(dpy, surface, attribute, value) ? true : false;
    }

    bool EGL::StaticSwapBuffers(EGLDisplay dpy, EGLSurface surface)
    {
        return ::eglSwapBuffers(dpy, surface);
    }

    bool EGL::StaticTerminate(EGLDisplay dpy)
    {
        return ::eglTerminate(dpy) ? true : false;
    }
    
    bool EGL::StaticWaitGL(void)
    {
        return ::eglWaitGL() ? true : false;
    }

    bool EGL::StaticWaitNative(EGLint engine)
    {
        return ::eglWaitNative(engine) ? true : false;
    }

    bool EGL::StaticBindTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer)
    {
        return ::eglBindTexImage(dpy, surface, buffer) ? true : false;
    }

    bool EGL::StaticReleaseTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer)
    {
        return ::eglReleaseTexImage(dpy, surface, buffer) ? true : false;
    }

    bool EGL::StaticSurfaceAttrib(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value)
    {
        return ::eglSurfaceAttrib(dpy, surface, attribute, value) ? true : false;
    }

    bool EGL::StaticSwapInterval(EGLDisplay dpy, EGLint interval)
    {
        return ::eglSwapInterval(dpy, interval) ? true : false;
    }

    bool EGL::StaticBindAPI(EGLenum api)
    {
        return ::eglBindAPI(api) ? true : false;
    }

    EGLenum EGL::StaticQueryAPI(void)
    {
        return ::eglQueryAPI();
    }

    EGLSurface EGL::StaticCreatePbufferFromClientBuffer(EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint *attrib_list)
    {
        return ::eglCreatePbufferFromClientBuffer(dpy, buftype, buffer, config, attrib_list);
    }

    bool EGL::StaticReleaseThread(void)
    {
        return ::eglReleaseThread() ? true : false;
    }

    bool EGL::StaticWaitClient(void)
    {
        return ::eglWaitClient() ? true : false;
    }

    EGLContext EGL::StaticGetCurrentContext(void)
    {
        return ::eglGetCurrentContext();
    }

    EGLSync EGL::StaticCreateSync(EGLDisplay dpy, EGLenum type, const EGLAttrib *attrib_list)
    {
        return ::eglCreateSync(dpy, type, attrib_list);
    }

    bool EGL::StaticDestroySync(EGLDisplay dpy, EGLSync sync)
    {
        return ::eglDestroySync(dpy, sync) ? true : false;
    }

    EGLint EGL::StaticClientWaitSync(EGLDisplay dpy, EGLSync sync, EGLint flags, EGLTime timeout)
    {
        return ::eglClientWaitSync(dpy, sync, flags, timeout);
    }

    bool EGL::StaticGetSyncAttrib(EGLDisplay dpy, EGLSync sync, EGLint attribute, EGLAttrib *value)
    {
        return ::eglGetSyncAttrib(dpy, sync, attribute, value) ? true : false;
    }

    EGLImage EGL::StaticCreateImage(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLAttrib *attrib_list)
    {
        return ::eglCreateImage(dpy, ctx, target, buffer, attrib_list);
    }

    bool EGL::StaticDestroyImage(EGLDisplay dpy, EGLImage image)
    {
        return ::eglDestroyImage(dpy, image);
    }

    EGLDisplay EGL::StaticGetPlatformDisplay(EGLenum platform, void *native_display, const EGLAttrib *attrib_list)
    {
        return ::eglGetPlatformDisplay(platform, native_display, attrib_list);
    }

    EGLSurface EGL::StaticCreatePlatformWindowSurface(EGLDisplay dpy, EGLConfig config, void *native_window, const EGLAttrib *attrib_list)
    {
        return ::eglCreatePlatformWindowSurface(dpy, config, native_window, attrib_list);
    }

    EGLSurface EGL::StaticCreatePlatformPixmapSurface(EGLDisplay dpy, EGLConfig config, void *native_pixmap, const EGLAttrib *attrib_list)
    {
        return ::eglCreatePlatformPixmapSurface(dpy, config, native_pixmap, attrib_list);
    }

    bool EGL::StaticWaitSync(EGLDisplay dpy, EGLSync sync, EGLint flags)
    {
        return ::eglWaitSync(dpy, sync, flags);
    }
    
    bool EGL::ReleaseThread(void)
    {
        return EGL::StaticReleaseThread();
    }

    bool EGL::WaitClient(void)
    {
        return EGL::StaticWaitClient();
    }

    void* EGL::GetCurrentContext(void)
    {
        return EGL::StaticGetCurrentContext();
    }

    bool EGL::BindAPI(unsigned int api)
    {
        return EGL::StaticBindAPI(api);
    }

    unsigned int EGL::QueryAPI(void)
    {
        return EGL::StaticQueryAPI();
    }

    bool EGL::WaitGL(void)
    {
        return EGL::StaticWaitGL();
    }

    bool EGL::WaitNative(int32_t engine)
    {
        return EGL::StaticWaitNative(engine);
    }

    void* EGL::GetCurrentDisplay(void)
    {
        return EGL::StaticGetCurrentDisplay();
    }

    void* EGL::GetCurrentSurface(int32_t readdraw)
    {
        return EGL::StaticGetCurrentSurface(readdraw);
    }

    int32_t EGL::GetError(void)
    {
        return EGL::StaticGetError();
    }

    ref_of<qor::components::EGLDisplay>::type EGL::CreateDisplay()
    {
        return new_ref<EglDisplay>();
    }

    ref_of<qor::components::EGLDisplay>::type EGL::CreateDisplay(void* nativeDisplay)
    {
        return new_ref<EglDisplay>(nativeDisplay);
    }

    ref_of<qor::components::EGLDisplay>::type EGL::CreateDisplay(unsigned int platform, void* nativeDisplay, const intptr_t* attrib_list)
    {
        return new_ref<EglDisplay>(platform, nativeDisplay, attrib_list);
    }

    ref_of<qor::components::EGLWindow>::type EGL::CreateNativeWindow()
    {
        return new_ref<EglWindow>();
    }

}}}//qor::platform::nslinux
