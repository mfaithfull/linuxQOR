// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include "src/qor/error/error.h"
#include "src/framework/application/application_builder.h"
#include "src/platform/os/linux/x/egl/eglsession.h"
#include "src/platform/os/linux/x/egl/eglwindow.h"
#include "src/platform/os/linux/x/xlib/xlib.h"
#include "egl.h"
#include "display.h"
#include "src/platform/os/linux/wayland/client/client.h"
#include "src/platform/os/linux/wayland/client/display.h"
#include "src/platform/os/linux/wayland/client/surface.h"
#include "src/platform/os/linux/wayland/xdgshell/listeners/xdgwmbaselistener.h"
#include "src/platform/os/linux/wayland/xdgshell/listeners/xdgsurfacelistener.h"
#include "src/platform/os/linux/wayland/xdgshell/listeners/xdgtoplevellistener.h"
#include "src/platform/os/linux/wayland/xdgshell/xdgsurface.h"
#include "src/platform/os/linux/wayland/xdgshell/xdgsession.h"
#include "src/platform/os/linux/wayland/egl/eglwindow.h"


namespace qor{ bool qor_pp_module_interface(QOR_LINEGL) ImplementsEGLFeature() { return true; } }//qor

namespace qor{ namespace platform { namespace nslinux{

    void EGL::CheckStatus()
    {
        EGLint lastError = EGL::StaticGetError();
        if (lastError != EGL_SUCCESS)
        {
            continuable("EGL Error ({0}).\n", lastError);
        }
    }

    EGLDisplay EGL::StaticGetDisplay(EGLNativeDisplayType display_id)
    {        
        EGLDisplay result = ::eglGetDisplay(display_id);
        CheckErrorStatus(result, EGL_NO_DISPLAY);
        return result;
    }

    bool EGL::StaticChooseConfig(EGLDisplay dpy, const int32_t* attrib_list, EGLConfig* configs, int32_t config_size, int32_t* num_config)
    {
        int result = ::eglChooseConfig(dpy, attrib_list, configs, config_size, num_config) ? true : false;
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }

    bool EGL::StaticCopyBuffers(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target)
    {
        int result = ::eglCopyBuffers(dpy, surface, target);
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }

    EGLContext EGL::StaticCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *attrib_list)
    {
        EGLContext result = ::eglCreateContext(dpy, config, share_context, attrib_list);
        CheckWarningStatus(result, nullptr);
        return result;
    }

    EGLSurface EGL::StaticCreatePbufferSurface(EGLDisplay dpy, EGLConfig config, const EGLint *attrib_list)
    {
        EGLSurface result = ::eglCreatePbufferSurface(dpy, config, attrib_list);
        CheckWarningStatus(result, nullptr);
        return result;
    }

    EGLSurface EGL::StaticCreatePixmapSurface(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint *attrib_list)
    {
        EGLSurface result = ::eglCreatePixmapSurface(dpy, config, pixmap, attrib_list);
        CheckWarningStatus(result, nullptr);
        return result;
    }

    EGLSurface EGL::StaticCreateWindowSurface(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint *attrib_list)
    {
        EGLSurface result = ::eglCreateWindowSurface(dpy, config, win, attrib_list);
        CheckWarningStatus(result, nullptr);
        return result;
    }

    bool EGL::StaticDestroyContext(EGLDisplay dpy, EGLContext ctx)
    {
        int result = ::eglDestroyContext(dpy, ctx) ? true : false;
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }

    bool EGL::StaticDestroySurface(EGLDisplay dpy, EGLSurface surface)
    {
        int result = ::eglDestroySurface(dpy, surface) ? true : false;
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }

    bool EGL::StaticGetConfigAttrib(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *value)
    {
        int result = ::eglGetConfigAttrib(dpy, config, attribute, value) ? true : false;
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }

    bool EGL::StaticGetConfigs(EGLDisplay dpy, EGLConfig *configs, EGLint config_size, EGLint *num_config)
    {
        int result = ::eglGetConfigs(dpy, configs, config_size, num_config) ? true : false;
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }

    EGLDisplay EGL::StaticGetCurrentDisplay(void)
    {
        EGLDisplay result = ::eglGetCurrentDisplay();
        CheckWarningStatus(result, EGL_NO_DISPLAY);
        return result;
    }

    EGLSurface EGL::StaticGetCurrentSurface(EGLint readdraw)
    {
        EGLSurface result = ::eglGetCurrentSurface(readdraw);
        CheckWarningStatus(result, nullptr);
        return result;
    }

    EGLint EGL::StaticGetError(void)
    {
        return ::eglGetError();
    }

    __eglMustCastToProperFunctionPointerType EGL::StaticGetProcAddress(const char *procname)
    {
        __eglMustCastToProperFunctionPointerType result = ::eglGetProcAddress(procname);
        CheckErrorStatus(result, (__eglMustCastToProperFunctionPointerType)(nullptr));
        return result;
    }

    bool EGL::StaticInitialize(EGLDisplay dpy, EGLint *major, EGLint *minor)
    {
        int result = ::eglInitialize(dpy, major, minor) ? true : false;
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }

    bool EGL::StaticMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx)
    {
        int result = ::eglMakeCurrent(dpy, draw, read, ctx) ? true : false;
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }

    bool EGL::StaticQueryContext(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint *value)
    {
        int result = ::eglQueryContext(dpy, ctx, attribute, value) ? true : false;
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }

    const char* EGL::StaticQueryString(EGLDisplay dpy, EGLint name)
    {
        const char* result = ::eglQueryString(dpy, name);        
        return result;
    }

    bool EGL::StaticQuerySurface(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint *value)
    {
        int result = ::eglQuerySurface(dpy, surface, attribute, value) ? true : false;
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }

    bool EGL::StaticSwapBuffers(EGLDisplay dpy, EGLSurface surface)
    {
        int result = ::eglSwapBuffers(dpy, surface);
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }

    bool EGL::StaticTerminate(EGLDisplay dpy)
    {
        int result = ::eglTerminate(dpy) ? true : false;
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }
    
    bool EGL::StaticWaitGL(void)
    {
        int result = ::eglWaitGL() ? true : false;
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }

    bool EGL::StaticWaitNative(EGLint engine)
    {
        int result = ::eglWaitNative(engine) ? true : false;
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }

    bool EGL::StaticBindTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer)
    {
        int result = ::eglBindTexImage(dpy, surface, buffer) ? true : false;
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }

    bool EGL::StaticReleaseTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer)
    {
        int result = ::eglReleaseTexImage(dpy, surface, buffer) ? true : false;
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }

    bool EGL::StaticSurfaceAttrib(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value)
    {
        int result = ::eglSurfaceAttrib(dpy, surface, attribute, value) ? true : false;
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }

    bool EGL::StaticSwapInterval(EGLDisplay dpy, EGLint interval)
    {
        int result = ::eglSwapInterval(dpy, interval) ? true : false;
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }

    bool EGL::StaticBindAPI(EGLenum api)
    {
        int result = ::eglBindAPI(api) ? true : false;
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }

    EGLenum EGL::StaticQueryAPI(void)
    {
        return ::eglQueryAPI();
    }

    EGLSurface EGL::StaticCreatePbufferFromClientBuffer(EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint *attrib_list)
    {
        EGLSurface result = ::eglCreatePbufferFromClientBuffer(dpy, buftype, buffer, config, attrib_list);
        CheckWarningStatus(result, EGL_NO_SURFACE);
        return result;
    }

    bool EGL::StaticReleaseThread(void)
    {
        int result = ::eglReleaseThread() ? true : false;
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }

    bool EGL::StaticWaitClient(void)
    {
        int result = ::eglWaitClient() ? true : false;
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }

    EGLContext EGL::StaticGetCurrentContext(void)
    {
        EGLContext result = ::eglGetCurrentContext();
        CheckWarningStatus(result, EGL_NO_CONTEXT);
        return result;
    }

    EGLSync EGL::StaticCreateSync(EGLDisplay dpy, EGLenum type, const EGLAttrib *attrib_list)
    {
        EGLSync result = ::eglCreateSync(dpy, type, attrib_list);
        CheckErrorStatus(result, (EGLSync)nullptr);
        return result;
    }

    bool EGL::StaticDestroySync(EGLDisplay dpy, EGLSync sync)
    {
        int result = ::eglDestroySync(dpy, sync) ? true : false;
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }

    EGLint EGL::StaticClientWaitSync(EGLDisplay dpy, EGLSync sync, EGLint flags, EGLTime timeout)
    {
        EGLint result = ::eglClientWaitSync(dpy, sync, flags, timeout);
        CheckErrorStatus(result, EGL_FALSE);
        return result;
    }

    bool EGL::StaticGetSyncAttrib(EGLDisplay dpy, EGLSync sync, EGLint attribute, EGLAttrib *value)
    {
        int result = ::eglGetSyncAttrib(dpy, sync, attribute, value) ? true : false;
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }

    EGLImage EGL::StaticCreateImage(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLAttrib *attrib_list)
    {
        EGLImage result = ::eglCreateImage(dpy, ctx, target, buffer, attrib_list);
        CheckErrorStatus(result, EGL_NO_IMAGE);
        return result;
    }

    bool EGL::StaticDestroyImage(EGLDisplay dpy, EGLImage image)
    {
        int result = ::eglDestroyImage(dpy, image);
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }

    EGLDisplay EGL::StaticGetPlatformDisplay(EGLenum platform, void *native_display, const EGLAttrib *attrib_list)
    {
        EGLDisplay result = ::eglGetPlatformDisplay(platform, native_display, attrib_list);
        CheckErrorStatus(result, EGL_NO_DISPLAY);
        return result;
    }

    EGLSurface EGL::StaticCreatePlatformWindowSurface(EGLDisplay dpy, EGLConfig config, void *native_window, const EGLAttrib *attrib_list)
    {
        EGLSurface result = ::eglCreatePlatformWindowSurface(dpy, config, native_window, attrib_list);
        CheckErrorStatus(result, EGL_NO_SURFACE);
        return result;
    }

    EGLSurface EGL::StaticCreatePlatformPixmapSurface(EGLDisplay dpy, EGLConfig config, void *native_pixmap, const EGLAttrib *attrib_list)
    {
        EGLSurface result = ::eglCreatePlatformPixmapSurface(dpy, config, native_pixmap, attrib_list);
        CheckErrorStatus(result, EGL_NO_SURFACE);
        return result;
    }

    bool EGL::StaticWaitSync(EGLDisplay dpy, EGLSync sync, EGLint flags)
    {
        int result = ::eglWaitSync(dpy, sync, flags);
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }
    

    bool EGL::ReleaseThread(void)
    {
        return EGL::StaticReleaseThread();
    }

    bool EGL::WaitClient(void)
    {
        return EGL::StaticWaitClient();
    }

    void* EGL::GetCurrentContext(void)
    {
        return EGL::StaticGetCurrentContext();
    }

    bool EGL::BindAPI(unsigned int api)
    {
        return EGL::StaticBindAPI(api);
    }

    unsigned int EGL::QueryAPI(void)
    {
        return EGL::StaticQueryAPI();
    }

    bool EGL::WaitGL(void)
    {
        int result = EGL::StaticWaitGL();
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }

    bool EGL::WaitNative(int32_t engine)
    {
        int result = EGL::StaticWaitNative(engine);
        CheckSuccessStatus(result, EGL_TRUE);
        return result ?  true : false;
    }

    void* EGL::GetCurrentDisplay(void)
    {
        return EGL::StaticGetCurrentDisplay();
    }

    void* EGL::GetCurrentSurface(int32_t readdraw)
    {
        return EGL::StaticGetCurrentSurface(readdraw);        
    }

    int32_t EGL::GetError(void)
    {
        return EGL::StaticGetError();
    }

    ref_of<qor::components::EGLDisplay>::type EGL::CreateDisplay()
    {   
        return new_ref<EglDisplay>();
    }

    ref_of<qor::components::EGLDisplay>::type EGL::CreateDisplay(void* nativeDisplay)
    {
        return new_ref<EglDisplay>(nativeDisplay);
    }

    ref_of<qor::components::EGLSession>::type EGL::CreateSession(qor::components::EGLPlatformHint hint)
    {
        if(hint == qor::components::EGLPlatformHint::X)
        {
            auto xClient = qor::framework::AppBuilder().TheApplication(qor_shared)->GetRole(qor_shared)->template GetFeature<XClient>();
            auto xDisplay = xClient(qor_shared).GetDisplay(":0");
            auto eglDisplay = new_ref<EglDisplay>((void*)0x31D5);//EGL_PLATFORM_X11_KHR
            return new_ref<qor::components::EGLSessionWrapper<x::XEGLSession, EglDisplay>>(xDisplay, eglDisplay);            
        }
        else
        {            
            auto waylandClient = qor::framework::AppBuilder().TheApplication(qor_shared)->GetRole(qor_shared)->template GetFeature<WaylandClient>();
            auto waylandDisplay = waylandClient(qor_shared).GetDisplay();              //Get the default local display
            auto eglDisplay = new_ref<EglDisplay>((void*)0x31D8);//EGL_PLATFORM_WAYLAND_KHR
            return new_ref<qor::components::EGLSessionWrapper<wl::XDGSession, EglDisplay>>(waylandDisplay, eglDisplay);    
        }                
    }

    ref_of<qor::components::EGLWindow>::type EGL::CreateWindow(ref_of<qor::components::EGLSession>::type session, std::vector<int32_t>& contextAttributes, int x, int y, uint32_t width, uint32_t height)
    {
        if(session->GetPlatform() == qor::components::EGLPlatformHint::X)
        {
            return new_ref<qor::components::EGLWindowWrapper<x::XEGLWindow>>(session, contextAttributes, x,y,width,height); //Create and make current an EGL surfaced X Window
        }
        else
        {
            return new_ref<qor::components::EGLWindowWrapper<wl::WEGLWindow>>(session, contextAttributes, x,y,width,height);
        }
    }

}}}//qor::platform::nslinux
