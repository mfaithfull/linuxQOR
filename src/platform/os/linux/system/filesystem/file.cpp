// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include "src/qor/injection/typeidentity.h"
#include "src/qor/objectcontext/anyobject.h"
#include "src/framework/thread/currentthread.h"
#include "src/qor/reference/newref.h"
#include "file.h"
#include "src/platform/filesystem/ifilesystem.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <aio.h>

namespace qor{ namespace nslinux{    

    File::File(int fd) : m_fd(fd){}

    File::File(const File& src)
    {
        int m_fd = fcntl(src.m_fd, F_DUPFD, 0);
    }

    File::File(const platform::FileIndex& direntry, int openFor, int withFlags) : m_fd(-1) 
    {
        int mode = 0;
        if( withFlags & (platform::IFileSystem::WithFlags::CreateNew | platform::IFileSystem::WithFlags::TempFile) != 0)
        {
            mode |= (( (openFor & platform::IFileSystem::OpenFor::Exec) != 0) ? 1 : 0);
            mode |= (( (openFor & (platform::IFileSystem::OpenFor::ReadOnly | platform::IFileSystem::OpenFor::ReadWrite)) != 0) ? 4 : 0);
            mode |= (( (openFor & (platform::IFileSystem::OpenFor::WriteOnly | platform::IFileSystem::OpenFor::ReadWrite)) != 0) ? 2 : 0);
        }

        int oflags = 0;
        switch(openFor)
        {
            /*case OpenFor::Exec:
                oflags |= O_EXEC;*/
            case platform::IFileSystem::OpenFor::ReadOnly:
                oflags |= O_RDONLY;
                break;
            case platform::IFileSystem::OpenFor::WriteOnly:
                oflags |= O_WRONLY;
                break;
            case platform::IFileSystem::OpenFor::ReadWrite:
                oflags |= O_RDWR;
                break;
            /*case OpenFor::Search:
                oflags |= O_SEARCH;*/
            default:
                break;
                //Raise an error for invalid access mode
        }

        if( ( withFlags & platform::IFileSystem::WithFlags::Append ) != 0 )
        {
            oflags |= O_APPEND;
        }

        if( ( withFlags & platform::IFileSystem::WithFlags::CloseExec ) != 0 )
        {
            oflags |= O_CLOEXEC;
        }

        if( ( withFlags & platform::IFileSystem::WithFlags::CloseFork ) != 0 )
        {
            //oflags |= O_CLOFORK;
        }

        if( ( withFlags & platform::IFileSystem::WithFlags::CreateNew ) != 0 )
        {
            oflags |= O_CREAT;
        }

        if( ( withFlags & platform::IFileSystem::WithFlags::Directory ) != 0 )
        {
            oflags |= O_DIRECTORY;
        }

        if( ( withFlags & platform::IFileSystem::WithFlags::DSync ) != 0 )
        {
            oflags |= O_DSYNC;
        }

        if( ( withFlags & platform::IFileSystem::WithFlags::Exclusive ) != 0 )
        {
            oflags |= O_EXCL;
        }

        if( ( withFlags & platform::IFileSystem::WithFlags::NoCTTY ) != 0 )
        {
            oflags |= O_NOCTTY;
        }

        if( ( withFlags & platform::IFileSystem::WithFlags::NoFollow ) != 0 )
        {
            oflags |= O_NOFOLLOW;
        }

        if( ( withFlags & platform::IFileSystem::WithFlags::NonBlock ) != 0 )
        {
            oflags |= O_NONBLOCK;
        }

        if( ( withFlags & platform::IFileSystem::WithFlags::RSync ) != 0 )
        {
            oflags |= O_RSYNC;
        }

        if( ( withFlags & platform::IFileSystem::WithFlags::Sync ) != 0 )
        {
            oflags |= O_SYNC;
        }

        if( ( withFlags & platform::IFileSystem::WithFlags::Truncate ) != 0 )
        {
            oflags |= O_TRUNC;
        }

        if( ( withFlags & platform::IFileSystem::WithFlags::TTYInit ) != 0 )
        {
            //oflags |= O_TTY_INIT;
        }

        if( ( withFlags & platform::IFileSystem::WithFlags::TempFile ) != 0 )
        {
            oflags |= O_TMPFILE;
        }

        m_fd = open(direntry.ToString().c_str(), oflags, mode);        
        
        if(m_fd == -1)
        {
            //TODO: a bunch of error handling
        }        
    }

    File::~File()
    {
        if(m_fd != -1)
        {
            int b = fsync(m_fd);
            int c = close(m_fd);
        }
    }

    int File::ChangeAccess(unsigned int mode)
    {
        return fchmod(m_fd, static_cast<mode_t>(mode));
    }

    int File::AdviseOnUsage(off_t offset, off_t length, int advise)
    {
        return posix_fadvise(m_fd, offset, length, advise);            
    }

    ref_of<platform::File>::type File::Duplicate()
    {
        int fd = fcntl(m_fd, F_DUPFD, 0);
        return new_ref<File>(fd).template AsRef<platform::File>();
    }

    int File::GetStatus()
    {
        struct stat statusBuffer;
        int result = fstat(m_fd, &statusBuffer);
        return result;
    }

    int File::GetDescriptor() const
    {
        return m_fd;
    }

    int File::GetDescriptorMode()
    {
        return fcntl(m_fd, F_GETFD);
    }

    int File::ChangeDescriptorMode(int flags)
    {
        return fcntl(m_fd, F_SETFD, flags);
    }

    int File::GetOperatingMode()
    {
        return fcntl(m_fd, F_GETFL);
    }

    int File::ChangeOperatingMode(int flags)
    {        
        return fcntl(m_fd, F_SETFL, flags);
    }

    int File::ReserveSpace(off_t offset, off_t length)
    {
        return posix_fallocate(m_fd, offset, length);
    }

    int File::Truncate(off_t length)
    {
        return ftruncate(m_fd, length);
    }

    int File::SyncToSystem()
    {
        return fsync(m_fd);
    }

    off_t File::GetPosition()
    {
        return lseek(m_fd, 0, SEEK_CUR);
    }

    off_t File::SetPosition(off_t offset, int whence)
    {
        return lseek(m_fd, offset, whence);
    }

    int File::AsyncRead(byte* buffer, size_t byteCount, off_t offset)
    {
        aiocb cb;
    	memset(&cb, 0, sizeof(aiocb));
	    cb.aio_nbytes = byteCount;
	    cb.aio_fildes = m_fd;
	    cb.aio_offset = offset;
	    cb.aio_buf = buffer;
        aio_read(&cb);
        const aiocb* const list[1] = {&cb};
        //TODO here we should co_await an awaiter which does this on a pool thread
        aio_suspend(list, 1, nullptr);
        return aio_return(&cb);
    }

    int File::AsyncWrite(byte* buffer, size_t byteCount, off_t offset)
    {
        aiocb cb;
        memset(&cb, 0, sizeof(aiocb));
        cb.aio_nbytes = byteCount;
        cb.aio_fildes = m_fd;
        cb.aio_offset = offset;
        cb.aio_buf = buffer;
        aio_write(&cb);
        const aiocb* const list[1] = {&cb};
        //TODO here we should co_await an awaiter which does this on a pool thread
        aio_suspend(list, 1, nullptr);
        return aio_return(&cb);
    }

    ssize_t File::Read(byte* buffer, size_t byteCount, off_t offset)
    {
        if(offset == -1)
        {
            return read(m_fd, buffer, byteCount);
        }
        else
        {
            return pread(m_fd, buffer, byteCount, offset);
        }        
    }

    ssize_t File::Write(const byte* buffer, size_t byteCount, off_t offset)
    {
        if(offset == -1)
        {
            return write(m_fd, buffer, byteCount);
        }
        else
        {
            return pwrite(m_fd, buffer, byteCount, offset);
        }     
    }

}}//qor::nslinux