// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"
#include "src/qor/error/error.h"
#include "src/qor/log/informative.h"

#include "registry.h"

#include <wayland-client-core.h>
#include <wayland-client-protocol.h>

#include "listeners/registrylistener.h"
#include "session.h"
#include "compositor.h"

namespace qor{ namespace platform { namespace nslinux{ namespace wl{

    const char* const Registry::TagName = "QOR::PLATFORM::NSLINUX::WL::REGISTRY";

    Registry* Registry::RegistryFrom(wl_registry* registry)
    {
        if(!registry)
        {
            return nullptr;
        }
        Registry* result = reinterpret_cast<Registry*>(wl_registry_get_user_data(registry));
        if(result && result->Tag() == TagName)
        {
            return result;
        }
        else if(result)
        {
            continuable("Wayland wl_registry user data tag mismatch");
        }
        return new Registry(registry);
    }

    Registry::Registry(wl_registry* registry) : m_registry(registry), m_defaultListener(nullptr)
    {
        if(registry)
        {
            wl_registry_set_user_data(m_registry, this);
        }
        else
        {
            continuable("Registry created with null wl_registry pointer");
        }
    }

    Registry::Registry(Registry&& rhs) noexcept : m_registry(rhs.m_registry), m_defaultListener(rhs.m_defaultListener)
    {
        rhs.m_registry = nullptr;
        rhs.m_defaultListener = nullptr;
        if (m_registry)
        {
            wl_registry_set_user_data(m_registry, this);
        }
    }

    Registry& Registry::operator=(Registry&& rhs) noexcept
    {
        if (this != &rhs)
        {
            if (m_registry)
            {
                wl_registry_destroy(m_registry);
            }

            m_registry = rhs.m_registry;
            m_defaultListener = rhs.m_defaultListener;
            rhs.m_defaultListener = nullptr;
            rhs.m_registry = nullptr;

            if (m_registry)
            {
                wl_registry_set_user_data(m_registry, this);
            }
        }
        return *this;
    }

    Registry::~Registry()
    {
        if(m_registry)
        {
            wl_registry_destroy(m_registry);
        }
        if(m_defaultListener)
        {
            delete m_defaultListener;
            m_defaultListener = nullptr;
        }
    }

    wl_registry* Registry::Use() const
    {
        if(!m_registry)
        {
            warning("Using Registry with null wl_registry pointer");
        }
        return m_registry;
    }

    uint32_t Registry::Version()
    {
        if(!m_registry)
        {
            warning("Getting version of Registry with null wl_registry pointer");
            return 0;
        }
        return wl_registry_get_version(m_registry);
    }

    void Registry::AddDefaultListener(qor::ref_of<Session>::type session)
    {
        if(!m_registry)
        {
            warning("Adding default listener to Registry with null wl_registry pointer");
            return;
        }
        if(!m_defaultListener)
        {
            m_defaultListener = new RegistryListener();
        }
        wl_registry_add_listener(m_registry, m_defaultListener, session.operator->());
    }

    int Registry::AddListener(const wl_registry_listener& listener, void* data)
    {
        if(!m_registry)
        {
            warning("Adding listener to Registry with null wl_registry pointer");
            return -1;
        }
        return wl_registry_add_listener(m_registry, &listener, data);
    }

    void* Registry::Bind(uint32_t name, uint32_t version, const wl_interface& interface)
    {
        if(!m_registry)
        {
            warning("Binding to Registry with null wl_registry pointer");
            return nullptr;
        }
        return wl_registry_bind(m_registry, name, &interface, version);
    }

    void Registry::OnGlobal(void* context, uint32_t name, const char* interface, uint32_t version)
    {
        log::inform("Global object announced: {0:s} (version {1:u) with name {2:u}", interface, version, name);
        Session* session = reinterpret_cast<Session*>(context);
        if(session && session->Tag() == Session::TagName)
        {
            if (strcmp(interface, "wl_compositor") == 0)
            {
                wl_compositor* compositor = reinterpret_cast<wl_compositor*>(Bind(name, version, wl_compositor_interface));
                session->SetCompositor(new_ref<Compositor>(compositor));
            }
        }
    }

    void Registry::OnGlobalRemove(void* context, uint32_t name)
    {
        log::inform("Global object removed with name {0:u}", name);
        Session* session = reinterpret_cast<Session*>(context);
        if(session && session->Tag() == Session::TagName)
        {
            //Handle removal if needed
        }
    }

}}}}//qor::platform::nslinux::wl
