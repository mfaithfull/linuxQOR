// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include <assert.h>

#include "src/qor/error/error.h"
#include "src/qor/log/informative.h"

#include "registry.h"

#include <wayland-client-core.h>
#include <wayland-client-protocol.h>

#include "listeners/registrylistener.h"
#include "session.h"
#include "compositor.h"
#include "datadevicemanager.h"
#include "shm.h"
#include "shell.h"
#include "output.h"
#include "seat.h"

namespace qor{ namespace platform { namespace nslinux{ namespace wl{

    const char* const Registry::TagName = "QOR::PLATFORM::NSLINUX::WL::REGISTRY";
    Registry* Registry::s_pInstance = nullptr;
    
    Registry* Registry::RegistryFrom(wl_registry* registry)
    {
        if(!registry)
        {
            return nullptr;
        }
        return s_pInstance;
    }

    Registry::Registry() : m_registry(nullptr), m_defaultListener(nullptr)
    {
        //DO NOT USE. Required for singleton instancing
    }

    Registry::Registry(wl_registry* registry) : m_registry(registry), m_defaultListener(nullptr)
    {
        if(!registry)
        {
            continuable("Registry created with null wl_registry pointer");
        }
        s_pInstance = this;
        wl_registry_set_user_data(m_registry, this);
    }

    Registry::Registry(Registry&& rhs) noexcept : m_registry(rhs.m_registry), m_defaultListener(rhs.m_defaultListener)
    {
        rhs.m_registry = nullptr;
        rhs.m_defaultListener = nullptr;
        if (m_registry)
        {
            wl_registry_set_user_data(m_registry, this);
        }
    }

    Registry& Registry::operator=(Registry&& rhs) noexcept
    {
        if (this != &rhs)
        {
            if (m_registry)
            {
                wl_registry_destroy(m_registry);
            }

            m_registry = rhs.m_registry;
            m_defaultListener = rhs.m_defaultListener;
            rhs.m_defaultListener = nullptr;
            rhs.m_registry = nullptr;

            if (m_registry)
            {
                wl_registry_set_user_data(m_registry, this);
            }
        }
        return *this;
    }

    Registry::~Registry()
    {
        if(m_registry)
        {
            wl_registry_destroy(m_registry);
        }
        if(m_defaultListener)
        {
            delete m_defaultListener;
            m_defaultListener = nullptr;
        }
    }

    wl_registry* Registry::Use() const
    {
        if(!m_registry)
        {
            warning("Using Registry with null wl_registry pointer");
        }
        return m_registry;
    }

    uint32_t Registry::Version()
    {
        if(!m_registry)
        {
            warning("Getting version of Registry with null wl_registry pointer");
            return 0;
        }
        return wl_registry_get_version(m_registry);
    }

    void Registry::AddDefaultListener(Session* session)
    {
        if(!m_registry)
        {
            warning("Adding default listener to Registry with null wl_registry pointer");
            return;
        }
        if(!m_defaultListener)
        {
            m_defaultListener = new RegistryListener();
        }
        if(wl_registry_add_listener(m_registry, m_defaultListener, session) != 0)
        {
            warning("Failed to add default listener to Registry");
        }
    }

    int Registry::AddListener(const wl_registry_listener& listener, void* data)
    {
        if(!m_registry)
        {
            warning("Adding listener to Registry with null wl_registry pointer");
            return -1;
        }
        return wl_registry_add_listener(m_registry, &listener, data);
    }

    void* Registry::Bind(uint32_t name, uint32_t version, const wl_interface& interface)
    {
        if(!m_registry)
        {
            warning("Binding to Registry with null wl_registry pointer");
            return nullptr;
        }
        return wl_registry_bind(m_registry, name, &interface, version);
    }

    void Registry::OnGlobal(void* context, uint32_t name, const char* interface, uint32_t version)
    {
        log::inform("Global object announced: {0} (version {1} with name {2}", interface, version, name);
        Session* session = reinterpret_cast<Session*>(context);
        if(session && session->Tag() == Session::TagName)
        {
            if (strcmp(interface, "wl_compositor") == 0)
            {
                wl_compositor* compositor = reinterpret_cast<wl_compositor*>(Bind(name, version, wl_compositor_interface));
                session->SetCompositor(new_ref<Compositor>(compositor));
                return;
            }

            if(strcmp(interface, "wl_data_device_manager") == 0)
            {
                wl_data_device_manager* dataDeviceManager = reinterpret_cast<wl_data_device_manager*>(Bind(name, version, wl_data_device_manager_interface));
                session->SetDataDeviceManager(new_ref<DataDeviceManager>(dataDeviceManager));
                return;
            }

            if(strcmp(interface, "wl_shell") == 0)
            {
                wl_shell* shell = reinterpret_cast<wl_shell*>(Bind(name, version, wl_shell_interface));
                session->SetShell(new_ref<Shell>(shell));
                return;
            }

            if(strcmp(interface, "wl_output") == 0)
            {
                wl_output* output = reinterpret_cast<wl_output*>(Bind(name, version, wl_output_interface));
                session->AddOutput(new_ref<Output>(output), name);
                return;
            }

            if(strcmp(interface, "wl_shm") == 0)
            {
                wl_shm* shm = reinterpret_cast<wl_shm*>(Bind(name, version, wl_shm_interface));
                session->SetShm(new_ref<SharedMemory>(shm));
                return;
            }

            if(strcmp(interface, "wl_seat") == 0)
            {
                wl_seat* seat = reinterpret_cast<wl_seat*>(Bind(name, version, wl_seat_interface));
                session->AddSeat(new_ref<Seat>(seat), name);
                return;
            }

            session->AddUnknownGlobal(name, interface, version);
        }
    }

    void Registry::OnGlobalRemove(void* context, uint32_t name)
    {
        log::inform("Global object removed with name {0:u}", name);
        Session* session = reinterpret_cast<Session*>(context);
        if(session && session->Tag() == Session::TagName)
        {
            //Handle removal if needed
        }
    }

}}}}//qor::platform::nslinux::wl
