// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include <sys/mman.h>
#include <sys/syscall.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "sdk/using_framework.h"
#include "src/components/framework/ui/egl/egl.h"
#include "src/components/framework/ui/egl/display.h"
#include "src/components/framework/ui/egl/context.h"
#include "src/components/framework/ui/egl/window.h"
#include "src/components/framework/ui/egl/session.h"
#include "src/components/framework/ui/opengles/opengles.h"
#include "src/components/framework/ui/opengles/constants.h"
#include "src/components/framework/ui/renderer/thor.h"

#include "sdk/platform/os/linux/wayland.h"
#include "src/platform/os/linux/wayland/egl/eglwindow.h"
#include "src/platform/os/linux/egl/display.h"

using namespace qor::platform::nslinux;
using namespace qor::components;

class CustomWindow : public EGLWindowWrapper<wl::WEGLWindow>
{
public:

    CustomWindow(ref_of<EGLSessionWrapper<wl::XDGSession, EglDisplay>>::type session, const std::vector<int32_t>& contextAttributes, int x, int y, unsigned int width, unsigned int height) : 
        qor::components::EGLWindowWrapper<wl::WEGLWindow>(session, contextAttributes, x, y, width, height), m_session(session)
    {
        m_canvas = nullptr;
        m_gl = GetFeature<OpenGLESFeature>();                        
        SetWidth(width);
        SetHeight(height);
        DoConfiguration();//Need to this for every XDGWindow to connect up the callbacks to our derived class
                
        m_canvas = ui::renderer::GlCanvas::gen(m_gl);
        auto shape3 = ui::renderer::Shape::gen();
        shape3->appendCircle(200, 200, 150, 100);    //cx, cy, radiusW, radiusH
        shape3->fill(0, 255, 255);                   //r, g, b
        m_canvas->push(shape3);
        
        DrawFrame();
    }

    virtual ~CustomWindow()
    {        
        delete m_canvas;
    }

    virtual void OnResize()//Override to handle resize happing to this window, e.g. from a Window Manager
    {   
        if(m_canvas)
        {
            static_cast<ui::renderer::GlCanvas*>(m_canvas)->target(m_eglContext->Use(), 0, m_width, m_height, ui::renderer::ColorSpace::ABGR8888S);         
        }
    }

    void DrawFrame(uint32_t serial = 0)
    {        
        m_canvas->draw(true);
        m_canvas->sync();
        Present();
    }

    virtual void OnXDGTopLevelConfigured(int32_t new_width, int32_t new_height, struct wl_array* states)
    {
        if (new_width == 0 || new_height == 0)
        {
            return;
        }

        if (m_width != new_width || m_height != new_height)
        {
            m_width = new_width;
            m_height = new_height;
            OnResize();
        }
    }

    virtual void OnClose()
    {
        m_session->End();
    }
    
    ref_of<EGLSessionWrapper<wl::XDGSession, EglDisplay>>::type m_session;    
    ref_of<OpenGLESFeature>::type m_gl;
    ui::renderer::Canvas* m_canvas;
};

class customKeyboardController : public wl::KeyboardController
{
public:

    customKeyboardController(wl::XDGSession* session, ref_of<wl::Keyboard>::type keyboard) : wl::KeyboardController(keyboard), m_session(session)
    {        
    }

    virtual ~customKeyboardController() = default;

    virtual void OnKey(wl::Keyboard*, uint32_t serial, uint32_t time, uint32_t key, uint32_t state)
    {
        if(m_session)
        {
            if(key == 1 && state == 1)
            {
                m_session->End();
            }
        }
    }

protected:

    wl::XDGSession* m_session;    
};

int waylandExampleRun(ref_of<EGLSessionWrapper<wl::XDGSession, EglDisplay>>::type session)
{
    std::vector<int32_t> contextAttributes = { EGL_CONTEXT_CLIENT_VERSION, 2, EGL_NONE};
    auto window = new_ref<CustomWindow>(session,contextAttributes, 100, 100, 640, 480);     //Create a Top Level EGL window
    window->SetTitle("Wayland EGL Example");                            //Set window properties    
    customKeyboardController keycon(session, session->GetKeyboard());   //Setup a Keyboard controller to catch Esc and quit the Session    
    
    while(!session->Ended())
    {     
        session->GetDisplay()->DispatchPending();   
        window->DrawFrame();
        window->Present();
    }

    return 0;
}

int waylandExampleCommon()
{
    auto waylandClient = GetFeature<WaylandClient>();                   //Get a reference to the Wayland Client feature
    auto display = waylandClient(qor_shared).GetDisplay();              //Get the default local display
    auto session = new_ref<EGLSessionWrapper<wl::XDGSession, EglDisplay>>(display);        //Create an EGL enabled Session over a Wayland XDG Session
    return waylandExampleRun(session);
}

const char* appName = "wedge";
qor_pp_implement_module(appName)
qor_pp_module_requires(WaylandClient)
qor_pp_module_requires(EGLFeature)
qor_pp_module_requires(OpenGLESFeature)

int main(int argc, char **argv) 
{    
    auto wedgeApp = AppBuilder().Build(appName);

    wedgeApp->SetRole<Role>(
        [](ref_of<IRole>::type role)
        {
            role->AddFeature<WaylandClient>();
            role->AddFeature<EGLFeature>();
            role->AddFeature<OpenGLESFeature>();
        }
    ).Run(
        make_runable( 
            []()->int
            {
                int result = waylandExampleCommon();
                printf("Disconnected from display\n");
                return result;
            }
        )
    );
}