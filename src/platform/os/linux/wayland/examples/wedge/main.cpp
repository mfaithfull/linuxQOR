// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include <sys/mman.h>
#include <sys/syscall.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "sdk/using_framework.h"
#include "sdk/platform/os/linux/wayland.h"
#include "src/platform/os/linux/wayland/egl/eglwindow.h"
#include "src/components/framework/ui/egl/egl.h"
#include "src/components/framework/ui/egl/display.h"
#include "src/components/framework/ui/egl/context.h"
#include "src/components/framework/ui/egl/window.h"
#include "src/components/framework/ui/opengles/opengles.h"
#include "src/components/framework/ui/opengles/constants.h"

#include "src/platform/os/linux/egl/session.h"
#include "src/platform/os/linux/egl/display.h"

using namespace qor::platform::nslinux;

// helper to create a std::function out of a member function and an object
template <typename R, typename T, typename... Args>
std::function<R(Args...)> bind_mem_fn(R(T::* func)(Args...), T *t)
{
    return [func, t] (Args... args)
    {
        return (t->*func)(args...);
    };
}

class CustomWindow : public EglWindow<wl::WEGLWindow>
{
public:

    CustomWindow(qor::ref_of<EGLSession<wl::XDGSession>>::type session, const std::vector<int32_t>& contextAttributes) : EglWindow<wl::WEGLWindow>(session, contextAttributes), m_session(session)
    {
        m_gl = GetFeature<qor::components::OpenGLESFeature>();                
        SetWidth(640);
        SetHeight(480);
        DoConfiguration();//Need to this for every XDGWindow to connect up the callbacks to our derived class

        Resize();
        DrawFrame();
    }

    virtual ~CustomWindow()
    {        
    }

    void Resize()
    {
        m_gl->Viewport(0,0, m_width, m_height);
    }

    void DrawFrame(uint32_t serial = 0)
    {        
        m_gl->ClearColour(200, 0, 0, 0);

        m_frameCallback = m_xdgSurface->BaseSurface()->Frame();        
        m_frameCallback.m_done = bind_mem_fn(&CustomWindow::DrawFrame, this);
        m_frameCallback.AddDefaultListener();

        Present();
    }

    virtual void OnXDGTopLevelConfigured(int32_t new_width, int32_t new_height, struct wl_array* states)
    {
        if (new_width == 0 || new_height == 0)
        {
            return;
        }

        if (m_width != new_width || m_height != new_height)
        {
            m_width = new_width;
            m_height = new_height;
            Resize();
        }
    }

    virtual void OnClose()
    {
        m_session->End();
    }
    
    qor::ref_of<EGLSession<wl::XDGSession>>::type m_session;
    wl::Callback m_frameCallback;
    qor::ref_of<qor::components::OpenGLESFeature>::type m_gl;

};

class customKeyboardController : public wl::KeyboardController
{
public:

    customKeyboardController(wl::XDGSession* session, ref_of<wl::Keyboard>::type keyboard) : wl::KeyboardController(keyboard), m_session(session)
    {        
    }

    virtual ~customKeyboardController() = default;

    virtual void OnKey(wl::Keyboard*, uint32_t serial, uint32_t time, uint32_t key, uint32_t state)
    {
        if(m_session)
        {
            if(key == 1 && state == 1)
            {
                m_session->End();
            }
        }
    }

protected:

    wl::XDGSession* m_session;    
};

int waylandExampleRun(ref_of<EGLSession<wl::XDGSession>>::type session)
{
    std::vector<int32_t> contextAttributes = { EGL_CONTEXT_CLIENT_VERSION, 3, EGL_NONE};
    auto window = new_ref<CustomWindow>(session,contextAttributes);     //Create a Top Level EGL window
    window->SetTitle("Wayland EGL Example");                            //Set window properties    
    customKeyboardController keycon(session, session->GetKeyboard());   //Setup a Keyboard controller to catch Esc and quit the Session    
    
    while(!session->Ended())
    {     
        session->GetDisplay()->DispatchPending();   
        window->DrawFrame();
        window->Present();
    }

    return 0;
}

int waylandExampleCommon()
{
    auto waylandClient = GetFeature<WaylandClient>();                   //Get a reference to the Wayland Client feature
    auto display = waylandClient(qor_shared).GetDisplay();              //Get the default local display
    auto session = new_ref<EGLSession<wl::XDGSession>>(display);        //Create an EGL enabled Session over a Wayland XDG Session
    return waylandExampleRun(session);
}

const char* appName = "wedge";
qor_pp_implement_module(appName)
qor_pp_module_requires(WaylandClient)
qor_pp_module_requires(EGLFeature)
qor_pp_module_requires(OpenGLESFeature)

int main(int argc, char **argv) 
{    
    auto wedgeApp = AppBuilder().Build(appName);

    wedgeApp->SetRole<Role>(
        [](ref_of<IRole>::type role)
        {
            role->AddFeature<WaylandClient>();
            role->AddFeature<qor::components::EGLFeature>();
            role->AddFeature<qor::components::OpenGLESFeature>();
        }
    ).Run(
        make_runable( 
            []()->int
            {
                int result = waylandExampleCommon();
                printf("Disconnected from display\n");
                return result;
            }
        )
    );
}