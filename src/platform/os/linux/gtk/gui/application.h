// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_OS_LINUX_GUI_GTK_APPLICATION
#define QOR_PP_H_OS_LINUX_GUI_GTK_APPLICATION

#include "window.h"

namespace qor{ namespace nslinux{ namespace gui {

    enum ApplicationFlags
    {
        APPLICATION_FLAGS_NONE,
        APPLICATION_IS_SERVICE  =          (1 << 0),
        APPLICATION_IS_LAUNCHER =          (1 << 1),

        APPLICATION_HANDLES_OPEN =         (1 << 2),
        APPLICATION_HANDLES_COMMAND_LINE = (1 << 3),
        APPLICATION_SEND_ENVIRONMENT    =  (1 << 4),

        APPLICATION_NON_UNIQUE =           (1 << 5),

        APPLICATION_CAN_OVERRIDE_APP_ID =  (1 << 6),
        APPLICATION_ALLOW_REPLACEMENT   =  (1 << 7),
        APPLICATION_REPLACE             =  (1 << 8)
    };

    class Application
    {
    public:

        Application(GApplication* app) : m_gtk(GTK_APPLICATION(app))
        {            
        }

        Application(const char* appid, int flags)
        {
            m_gtk = gtk_application_new(appid, (GApplicationFlags)flags);
        }

        ~Application()
        {
            g_object_unref(m_gtk);
            m_gtk = nullptr;
        }

        unsigned long GetType() const
        {
            return gtk_application_get_type();
        }

        void AddWindow(Window& window)
        {
            gtk_application_add_window(m_gtk, window.Impl());
        }

        void RemoveWindow(Window& window)
        {
            gtk_application_remove_window(m_gtk, window.Impl());
        }

        /*
        GList* gtk_application_get_windows   (GtkApplication    *application);
        GMenuModel* gtk_application_get_app_menu  (GtkApplication    *application);
        void gtk_application_set_app_menu  (GtkApplication    *application, GMenuModel        *app_menu);
        GMenuModel* gtk_application_get_menubar   (GtkApplication    *application);
        void gtk_application_set_menubar   (GtkApplication    *application, GMenuModel        *menubar);
        //GDK_DEPRECATED_IN_3_14_FOR(gtk_application_set_accels_for_action)
        void gtk_application_add_accelerator    (GtkApplication  *application, const gchar     *accelerator, const gchar     *action_name, GVariant        *parameter);
        //GDK_DEPRECATED_IN_3_14_FOR(gtk_application_set_accels_for_action)
        void gtk_application_remove_accelerator (GtkApplication *application, const gchar    *action_name, GVariant       *parameter);
        */
        /*
        typedef enum
        {
            GTK_APPLICATION_INHIBIT_LOGOUT  = (1 << 0),
            GTK_APPLICATION_INHIBIT_SWITCH  = (1 << 1),
            GTK_APPLICATION_INHIBIT_SUSPEND = (1 << 2),
            GTK_APPLICATION_INHIBIT_IDLE    = (1 << 3)
        } GtkApplicationInhibitFlags;
        */
        /*
        guint            gtk_application_inhibit            (GtkApplication             *application, GtkWindow                  *window, GtkApplicationInhibitFlags  flags, const gchar                *reason);
        void             gtk_application_uninhibit          (GtkApplication             *application, guint                       cookie);
        gboolean         gtk_application_is_inhibited       (GtkApplication             *application, GtkApplicationInhibitFlags  flags);
        GtkWindow *      gtk_application_get_window_by_id   (GtkApplication             *application, guint                       id);
        GtkWindow *      gtk_application_get_active_window  (GtkApplication             *application);
        gchar **         gtk_application_list_action_descriptions        (GtkApplication       *application);
        gchar **         gtk_application_get_accels_for_action           (GtkApplication       *application, const gchar          *detailed_action_name);
        gchar **         gtk_application_get_actions_for_accel           (GtkApplication       *application, const gchar          *accel);
        void             gtk_application_set_accels_for_action           (GtkApplication       *application, const gchar          *detailed_action_name, const gchar * const  *accels);
        gboolean         gtk_application_prefers_app_menu                (GtkApplication       *application);
        GMenu *          gtk_application_get_menu_by_id                  (GtkApplication       *application, const gchar          *id);

        gboolean                g_application_id_is_valid                       (const gchar              *application_id);
        GApplication *          g_application_new                               (const gchar              *application_id,
                                                                                GApplicationFlags         flags);
        const gchar *           g_application_get_application_id                (GApplication             *application);
        void                    g_application_set_application_id                (GApplication             *application,
                                                                                const gchar              *application_id);
        GDBusConnection *       g_application_get_dbus_connection               (GApplication             *application);
        const gchar *           g_application_get_dbus_object_path              (GApplication             *application);
        guint                   g_application_get_inactivity_timeout            (GApplication             *application);
        void                    g_application_set_inactivity_timeout            (GApplication             *application,
                                                                                guint                     inactivity_timeout);
        GApplicationFlags       g_application_get_flags                         (GApplication             *application);
        void                    g_application_set_flags                         (GApplication             *application,
                                                                                GApplicationFlags         flags);
        const gchar *           g_application_get_resource_base_path            (GApplication             *application);
        void                    g_application_set_resource_base_path            (GApplication             *application,
                                                                                const gchar              *resource_path);
        void                    g_application_set_action_group                  (GApplication             *application,
                                                                                GActionGroup             *action_group);
        void                    g_application_add_main_option_entries           (GApplication             *application,
                                                                                const GOptionEntry       *entries);
        void                    g_application_add_main_option                   (GApplication             *application,
                                                                                const char               *long_name,
                                                                                char                      short_name,
                                                                                GOptionFlags              flags,
                                                                                GOptionArg                arg,
                                                                                const char               *description,
                                                                                const char               *arg_description);
        void                    g_application_add_option_group                  (GApplication             *application,
                                                                                GOptionGroup             *group);
        void                    g_application_set_option_context_parameter_string (GApplication             *application,
                                                                                const gchar              *parameter_string);
        void                    g_application_set_option_context_summary        (GApplication             *application,
                                                                                const gchar              *summary);
        void                    g_application_set_option_context_description    (GApplication             *application,
                                                                                const gchar              *description);
        gboolean                g_application_get_is_registered                 (GApplication             *application);
        gboolean                g_application_get_is_remote                     (GApplication             *application);
        gboolean                g_application_register                          (GApplication             *application,
                                                                                GCancellable             *cancellable,
                                                                                GError                  **error);
        void                    g_application_hold                              (GApplication             *application);
        void                    g_application_release                           (GApplication             *application);
        void                    g_application_activate                          (GApplication             *application);
        void                    g_application_open                              (GApplication             *application,
                                                                                GFile                   **files,
                                                                                gint                      n_files,
                                                                                const gchar              *hint);
        */
        int Run(int argc, char **argv)
        {
            return g_application_run(G_APPLICATION(m_gtk), argc, argv);
        }

        void Quit()
        {
            g_application_quit(G_APPLICATION(m_gtk));
        }

        Application static GetDefault()
        {
            Application app(g_application_get_default());
            return app;
        }

        void SetDefault()
        {
            g_application_set_default(G_APPLICATION(m_gtk));
        }

        void MarkBusy()
        {
            g_application_mark_busy(G_APPLICATION(m_gtk));
        }

        void UnmarkBusy()
        {
            g_application_unmark_busy(G_APPLICATION(m_gtk));
        }

        bool IsBusy()
        {
            return g_application_get_is_busy(G_APPLICATION(m_gtk)) ? true : false;
        }

        void SendNotification(const char* id, GNotification* notification)
        {
            g_application_send_notification(G_APPLICATION(m_gtk), id, notification);
        }

        void WithdrawNotification(const char* id)
        {
            g_application_withdraw_notification(G_APPLICATION(m_gtk), id);
        }

        void BindBusyProperty(void* object, const char* property)
        {
            g_application_bind_busy_property(G_APPLICATION(m_gtk), object, property);
        }

        void UnbindBusyProperty(void* object, const char* property)
        {
            g_application_unbind_busy_property(G_APPLICATION(m_gtk), object, property);
        }

    private:

        GtkApplication* m_gtk;
    };

}}}//qor::nslinux::gui

#endif//QOR_PP_H_OS_LINUX_GUI_GTK_APPLICATION