// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include <pthread.h>
#include <sched.h>
#include <sys/resource.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <sys/sysinfo.h>

#include <optional>

#include "src/qor/injection/typeidentity.h"
#include "src/qor/objectcontext/anyobject.h"
#include "src/framework/thread/currentthread.h"
#include "src/qor/reference/newref.h"
#include "currentthread.h"

namespace qor{ 
    bool qor_pp_module_interface(QOR_LINUXTHREAD) ImplementsICurrentThread() //Implement this trivial function so the linker will pull in this library to fulfil the ImplementsICurrentThread requirement. 
    {
        return true;
    }
}

namespace qor{ namespace nslinux{ namespace framework{

    bool CurrentThread::SetPriority(ICurrentThread::Priority priority)
    {
            // On Linux, we distill the choices of scheduling policy, priority, and "nice" value into 7 pre-defined levels, for simplicity and portability. The total number of possible combinations of policies and priorities is much larger, but allowing more fine-grained control would not be portable.
            int policy = 0;
            struct sched_param param = {};
            std::optional<int> nice_val = std::nullopt;
            switch (priority)
            {
            case ICurrentThread::Priority::realtime:
                // "Realtime" pre-defined priority: We use the policy `SCHED_FIFO` with the highest possible priority.
                policy = SCHED_FIFO;
                param.sched_priority = sched_get_priority_max(SCHED_FIFO);
                break;
            case ICurrentThread::Priority::highest:
                // "Highest" pre-defined priority: We use the policy `SCHED_RR` ("round-robin") with a priority in the middle of the available range.
                policy = SCHED_RR;
                param.sched_priority = sched_get_priority_min(SCHED_RR) + (sched_get_priority_max(SCHED_RR) - sched_get_priority_min(SCHED_RR)) / 2;
                break;
            case ICurrentThread::Priority::above_normal:
                // "Above normal" pre-defined priority: We use the policy `SCHED_OTHER` (the default). This policy does not accept a priority value, so priority must be 0. However, we set the "nice" value to the minimum value as given by `PRIO_MIN`, plus 2 (which should evaluate to -18). The usual range is -20 to 19 or 20, with higher values corresponding to lower priorities.
                policy = SCHED_OTHER;
                param.sched_priority = 0;
                nice_val = PRIO_MIN + 2;
                break;
            case ICurrentThread::Priority::normal:
                // "Normal" pre-defined priority: We use the policy `SCHED_OTHER`, priority must be 0, and we set the "nice" value to 0 (the default).
                policy = SCHED_OTHER;
                param.sched_priority = 0;
                nice_val = 0;
                break;
            case ICurrentThread::Priority::below_normal:
                // "Below normal" pre-defined priority: We use the policy `SCHED_OTHER`, priority must be 0, and we set the "nice" value to half the maximum value as given by `PRIO_MAX`, rounded up (which should evaluate to 10).
                policy = SCHED_OTHER;
                param.sched_priority = 0;
                nice_val = (PRIO_MAX / 2) + (PRIO_MAX % 2);
                break;
            case ICurrentThread::Priority::lowest:
                // "Lowest" pre-defined priority: We use the policy `SCHED_OTHER`, priority must be 0, and we set the "nice" value to the maximum value as given by `PRIO_MAX`, minus 3 (which should evaluate to 17).
                policy = SCHED_OTHER;
                param.sched_priority = 0;
                nice_val = PRIO_MAX - 3;
                break;
            case ICurrentThread::Priority::idle:
                // "Idle" pre-defined priority on Linux: We use the policy `SCHED_IDLE`, priority must be 0, and we don't touch the "nice" value.
                policy = SCHED_IDLE;
                param.sched_priority = 0;
                break;
            default:
                return false;
            }
            bool success = (pthread_setschedparam(pthread_self(), policy, &param) == 0);
            if (nice_val.has_value())
                success = success && (setpriority(PRIO_PROCESS, static_cast<id_t>(syscall(SYS_gettid)), nice_val.value()) == 0);
            return success;

    }

    std::optional< qor::framework::ICurrentThread::Priority > CurrentThread::GetPriority() const
    {
            // On Linux, we distill the choices of scheduling policy, priority, and "nice" value into 7 pre-defined levels, for simplicity and portability. The total number of possible combinations of policies and priorities is much larger, so if the value was set via any means other than `this_thread::set_os_thread_priority()`, it may not match one of our pre-defined values.
            int policy = 0;
            struct sched_param param = {};
            if (pthread_getschedparam(pthread_self(), &policy, &param) != 0)
            {
                return std::nullopt;
            }

            if (policy == SCHED_FIFO && param.sched_priority == sched_get_priority_max(SCHED_FIFO))
            {
                // The only pre-defined priority that uses SCHED_FIFO and the maximum available priority value is the "realtime" priority.
                return ICurrentThread::Priority::realtime;
            }

            if (policy == SCHED_RR && param.sched_priority == sched_get_priority_min(SCHED_RR) + (sched_get_priority_max(SCHED_RR) - sched_get_priority_min(SCHED_RR)) / 2)
            {
                // The only pre-defined priority that uses SCHED_RR and a priority in the middle of the available range is the "highest" priority.
                return ICurrentThread::Priority::highest;
            }
            
            if (policy == SCHED_IDLE)
            {
                // The only pre-defined priority that uses SCHED_IDLE is the "idle" priority. Note that this scheduling policy is not available on macOS.
                return ICurrentThread::Priority::idle;
            }
            
            if (policy == SCHED_OTHER)
            {
                // For SCHED_OTHER, the result depends on the "nice" value. The usual range is -20 to 19 or 20, with higher values corresponding to lower priorities. Note that `getpriority()` returns -1 on error, but since this does not correspond to any of our pre-defined values, this function will return `std::nullopt` anyway.
                const int nice_val = getpriority(PRIO_PROCESS, static_cast<id_t>(syscall(SYS_gettid)));
                switch (nice_val)
                {
                case PRIO_MIN + 2:
                    return ICurrentThread::Priority::above_normal;
                case 0:
                    return ICurrentThread::Priority::normal;
                case (PRIO_MAX / 2) + (PRIO_MAX % 2):
                    return ICurrentThread::Priority::below_normal;
                case PRIO_MAX - 3:
                    return ICurrentThread::Priority::lowest;
                default:
                    return std::nullopt;
                }
            }
            return std::nullopt;
    }

    bool CurrentThread::SetName(const std::string& name)
    {
        return pthread_setname_np(pthread_self(), name.data()) == 0;
    }

    std::optional<std::string> CurrentThread::GetName()
    {
        // On Linux thread names are limited to 16 characters, including the null terminator.
        constexpr std::size_t buffer_size = 16;
        char name[buffer_size] = {};
        if (pthread_getname_np(pthread_self(), name, buffer_size) != 0)
            return std::nullopt;
        return std::string(name);
    }

    bool CurrentThread::SetAffinity(const std::vector<bool>& affinity)
    {
        cpu_set_t cpu_set;
        CPU_ZERO(&cpu_set);
        for (std::size_t i = 0; i < std::min<std::size_t>(affinity.size(), CPU_SETSIZE); ++i)
        {
            if (affinity[i])
                CPU_SET(i, &cpu_set);
        }
        return pthread_setaffinity_np(pthread_self(), sizeof(cpu_set_t), &cpu_set) == 0;
    }

    std::optional<std::vector<bool>> CurrentThread::GetAffinity()
    {
        cpu_set_t cpu_set;
        CPU_ZERO(&cpu_set);
        if (pthread_getaffinity_np(pthread_self(), sizeof(cpu_set_t), &cpu_set) != 0)
            return std::nullopt;
        const int num_cpus = get_nprocs();
        if (num_cpus < 1)
            return std::nullopt;
        std::vector<bool> affinity(static_cast<std::size_t>(num_cpus));
        for (std::size_t i = 0; i < affinity.size(); ++i)
            affinity[i] = CPU_ISSET(i, &cpu_set);
        return affinity;
    }

}}}//qor::nslinux::framework
