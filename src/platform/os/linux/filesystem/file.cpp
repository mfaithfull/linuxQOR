// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include "src/qor/injection/typeidentity.h"
#include "src/qor/objectcontext/anyobject.h"
#include "src/framework/thread/currentthread.h"
#include "src/qor/reference/newref.h"
#include "file.h"
#include "src/platform/filesystem/ifilesystem.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <aio.h>

//Export this trivial function so the linker will pull in this library to fulfil the ImplementsIFile requirement.
namespace qor{ bool qor_pp_module_interface(QOR_LINUXFILESYSTEM) ImplementsIFile() { return true; } }//qor

namespace qor{ namespace nslinux{    

    File::File() : m_fd(-1){}
    
    File::File(int fd) : m_fd(fd){}

    File::File(const File& src) : File()
    {
        if(src.m_fd != -1)
        {
            m_fd = Validate_fcntl_Result(fcntl(src.m_fd, F_DUPFD, 0));
        }
    }

    File::File(const platform::FileIndex& direntry, int openFor, int withFlags) : m_fd(-1) , platform::File(direntry) 
    {
        int mode = 0;
        if( ( (withFlags & platform::IFileSystem::WithFlags::CreateNew) | (withFlags & platform::IFileSystem::WithFlags::TempFile) ) != 0 )
        {
            mode |= (( (openFor & platform::IFileSystem::OpenFor::Exec) != 0) ? S_IXUSR : 0);
            mode |= (( (openFor & (platform::IFileSystem::OpenFor::ReadOnly | platform::IFileSystem::OpenFor::ReadWrite)) != 0) ? S_IRUSR : 0);
            mode |= (( (openFor & (platform::IFileSystem::OpenFor::WriteOnly | platform::IFileSystem::OpenFor::ReadWrite)) != 0) ? S_IWUSR : 0);
        }
        int oflags = 0;        
        oflags |= (( (openFor & platform::IFileSystem::OpenFor::ReadOnly) != 0) ? O_RDONLY : 0);
        oflags |= (( (openFor & platform::IFileSystem::OpenFor::WriteOnly) != 0) ? O_WRONLY : 0);
        oflags |= (( (openFor & platform::IFileSystem::OpenFor::ReadWrite) != 0) ? O_RDWR : 0);

        oflags |= (( (withFlags & platform::IFileSystem::WithFlags::Append) != 0) ? O_APPEND : 0);
        oflags |= (( (withFlags & platform::IFileSystem::WithFlags::CloseExec) != 0) ? O_CLOEXEC : 0);
        //oflags |= (( (withFlags & platform::IFileSystem::WithFlags::CloseFork) != 0) ? O_CLOEXEC : 0);
        oflags |= (( (withFlags & platform::IFileSystem::WithFlags::CreateNew) != 0) ? O_CREAT : 0);
        oflags |= (( (withFlags & platform::IFileSystem::WithFlags::Directory) != 0) ? O_DIRECTORY : 0);
        oflags |= (( (withFlags & platform::IFileSystem::WithFlags::DSync) != 0) ? O_DSYNC : 0);
        oflags |= (( (withFlags & platform::IFileSystem::WithFlags::Exclusive) != 0) ? O_EXCL : 0);
        oflags |= (( (withFlags & platform::IFileSystem::WithFlags::NoCTTY) != 0) ? O_NOCTTY : 0);
        oflags |= (( (withFlags & platform::IFileSystem::WithFlags::NoFollow) != 0) ? O_NOFOLLOW : 0);
        oflags |= (( (withFlags & platform::IFileSystem::WithFlags::NonBlock) != 0) ? O_NONBLOCK : 0);
        oflags |= (( (withFlags & platform::IFileSystem::WithFlags::RSync) != 0) ? O_RSYNC : 0);
        oflags |= (( (withFlags & platform::IFileSystem::WithFlags::Sync) != 0) ? O_SYNC : 0);
        oflags |= (( (withFlags & platform::IFileSystem::WithFlags::Truncate) != 0) ? O_TRUNC : 0);
        //oflags |= (( (withFlags & platform::IFileSystem::WithFlags::TTYInit) != 0) ? O_TTY_INIT : 0);
        oflags |= (( (withFlags & platform::IFileSystem::WithFlags::TempFile) != 0) ? O_TMPFILE : 0);

        m_fd = open(direntry.ToString().c_str(), oflags, mode);        
        
        if(m_fd == -1)
        {
            File::ErrorOnOpen(errno);
        }        
    }

    File::~File()
    {
        if(m_fd != -1)
        {
            Check_fsync_Result(::fsync(m_fd));
            Check_close_Result(::close(m_fd));
        }
    }

    int File::ChangeMode(unsigned int mode)
    {
        unsigned int linuxMode = 0;
        linuxMode |= ( (mode & platform::IFileSystem::Owner_Read) != 0 ? S_IRUSR : 0 );
        linuxMode |= ( (mode & platform::IFileSystem::Owner_Write) != 0 ? S_IWUSR : 0 );
        linuxMode |= ( (mode & platform::IFileSystem::Owner_Execute) != 0 ? S_IXUSR : 0 );

        linuxMode |= ( (mode & platform::IFileSystem::Group_Read) != 0 ? S_IRGRP : 0 );
        linuxMode |= ( (mode & platform::IFileSystem::Group_Write) != 0 ? S_IWGRP : 0 );
        linuxMode |= ( (mode & platform::IFileSystem::Group_Execute) != 0 ? S_IXGRP : 0 );

        linuxMode |= ( (mode & platform::IFileSystem::Other_Read) != 0 ? S_IROTH : 0 );
        linuxMode |= ( (mode & platform::IFileSystem::Other_Write) != 0 ? S_IWOTH : 0 );
        linuxMode |= ( (mode & platform::IFileSystem::Other_Execute) != 0 ? S_IXOTH : 0 );
        return ChangeAccess(linuxMode);
    }

    int File::ChangeAccess(unsigned int mode)
    {
        return Validate_fchmod_Result(::fchmod(m_fd, static_cast<mode_t>(mode)));
    }

    int File::AdviseOnUsage(off_t offset, off_t length, int advise)
    {
        return Validate_posix_fadvise_Result(::posix_fadvise(m_fd, offset, length, advise));
    }

    ref_of<platform::IFile>::type File::Duplicate()
    {
        int fd = Validate_fcntl_Result(::fcntl(m_fd, F_DUPFD, 0));
        return new_ref<File>(fd).template AsRef<platform::IFile>();
    }

    int File::GetDescriptor() const
    {
        return m_fd;
    }

    int File::GetDescriptorMode()
    {
        return Validate_fcntl_Result(::fcntl(m_fd, F_GETFD));
    }

    int File::ChangeDescriptorMode(int flags)
    {
        return Validate_fcntl_Result(::fcntl(m_fd, F_SETFD, flags));
    }

    int File::GetOperatingMode()
    {
        return Validate_fcntl_Result(::fcntl(m_fd, F_GETFL));
    }

    int File::ChangeOperatingMode(int flags)
    {        
        return Validate_fcntl_Result(::fcntl(m_fd, F_SETFL, flags));
    }

    int File::ReserveSpace(off_t offset, off_t length)
    {
        return Validate_posix_fallocate_Result(::posix_fallocate(m_fd, offset, length));
    }

    int File::Truncate(off_t length)
    {
        return Validate_ftruncate_Result(::ftruncate(m_fd, length));
    }

    int File::SyncToSystem()
    {
        return Validate_fsync_Result(::fsync(m_fd));
    }

    uint64_t File::GetPosition()
    {
        return Validate_lseek64_Result(::lseek64(m_fd, 0, SEEK_CUR));
    }

    off_t File::SetPosition(off_t offset, int whence)
    {
        return Validate_lseek_Result(::lseek(m_fd, offset, whence));
    }

    int File::AsyncRead(byte* buffer, size_t byteCount, off_t offset)
    {
        aiocb cb;
    	memset(&cb, 0, sizeof(aiocb));
	    cb.aio_nbytes = byteCount;
	    cb.aio_fildes = m_fd;
	    cb.aio_offset = offset;
	    cb.aio_buf = buffer;
        aio_read(&cb);
        const aiocb* const list[1] = {&cb};
        //TODO here we should co_await an awaiter which does this on a pool thread
        aio_suspend(list, 1, nullptr);
        return aio_return(&cb);
    }

    int File::AsyncWrite(byte* buffer, size_t byteCount, off_t offset)
    {
        aiocb cb;
        memset(&cb, 0, sizeof(aiocb));
        cb.aio_nbytes = byteCount;
        cb.aio_fildes = m_fd;
        cb.aio_offset = offset;
        cb.aio_buf = buffer;
        aio_write(&cb);
        const aiocb* const list[1] = {&cb};
        //TODO here we should co_await an awaiter which does this on a pool thread
        aio_suspend(list, 1, nullptr);
        return aio_return(&cb);
    }

    int64_t File::Read(byte* buffer, size_t byteCount, off_t offset)
    {
        if(offset == -1)
        {
            return Validate_read_Result(::read(m_fd, buffer, byteCount));
        }
        else
        {
            return Validate_read_Result(::pread(m_fd, buffer, byteCount, offset));
        }        
    }

    int64_t File::Write(byte* buffer, size_t byteCount, off_t offset)
    {
        if(offset == -1)
        {
            return Validate_write_Result(::write(m_fd, buffer, byteCount));
        }
        else
        {
            return Validate_write_Result(::pwrite(m_fd, buffer, byteCount, offset));
        }     
    }

    int64_t File::Validate_write_Result(int64_t result)
    {
        if(result == -1)
        {
            switch (errno)
            {
            case EAGAIN:
                continuable("The O_NONBLOCK flag is set for the file descriptor and the thread would be delayed in the write() operation.\nor\nThe file descriptor is for a socket, is marked O_NONBLOCK, and write would block.");
                break;
            case EBADF:
                continuable("The fildes argument is not a valid file descriptor open for writing.");
                break;
            case EFBIG:
                continuable("An attempt was made to write a file that exceeds the implementation-defined maximum file size or the process' file size limit, and there was no room for any bytes to be written.\nor\nThe file is a regular file, nbyte is greater than 0, and the starting position is greater than or equal to the offset maximum established in the open file description associated with fildes.");
                break;
            case EINTR:
                continuable("The write operation was terminated due to the receipt of a signal, and no data was transferred.");
                break;
            case EIO:
                continuable("The process is a member of a background process group attempting to write to its controlling terminal, TOSTOP is set, the process is neither ignoring nor blocking SIGTTOU, and the process group of the process is orphaned. This error may also be returned under implementation-defined conditions.\nor\nA physical I/O error has occurred.");
                break;
            case ENOSPC:
                continuable("There was no free space remaining on the device containing the file.");
                break;
            case EPIPE:
                continuable("An attempt is made to write to a pipe or FIFO that is not open for reading by any process, or that only has one end open. A SIGPIPE signal shall also be sent to the thread.\nor\nA write was attempted on a socket that is shut down for writing, or is no longer connected. In the latter case, if the socket is of type SOCK_STREAM, the SIGPIPE signal is generated to the calling process.");
                break;
            case ERANGE:
                continuable("The transfer request size was outside the range supported by the STREAMS file associated with fildes.");
                break;
#if(EWOULDBLOCK != EAGAIN)
            case EWOULDBLOCK:
                continuable("The file descriptor is for a socket, is marked O_NONBLOCK, and write would block.");
                break;
#endif
            case ECONNRESET:
                continuable("A write was attempted on a socket that is not connected.");
                break;
            case EINVAL:
                continuable("The STREAM or multiplexer referenced by fildes is linked (directly or indirectly) downstream from a multiplexer.\nor\nThe offset argument is invalid. The value is negative.");
                break;
            case ENOBUFS:
                continuable("Insufficient resources were available in the system to perform the operation.");
                break;
            case ENXIO:
                continuable("A request was made of a nonexistent device, or the request was outside the capabilities of the device.\nor\nA hangup occurred on the STREAM being written to.");
                break;
            case EACCES:
                continuable("A write was attempted on a socket and the calling process does not have appropriate privileges.");
                break;
            case ENETDOWN:
                continuable("A write was attempted on a socket and the local network interface used to reach the destination is down.");
                break;
            case ENETUNREACH:
                continuable("A write was attempted on a socket and no route to the network is present.");
                break;
            case ESPIPE:
                continuable("fildes is associated with a pipe or FIFO.");
                break;
            default:
                serious("An unknown error has occured.");
                break;
            }
        }
        return result;
    }

    int64_t File::Validate_read_Result(int64_t result)
    {
        if(result == -1)
        {
            switch (errno)
            {
            case EAGAIN:
                continuable("The O_NONBLOCK flag is set for the file descriptor and the process would be delayed.\nor\nThe file descriptor is for a socket, is marked O_NONBLOCK, and no data is waiting to be received.");
                break;
            case EBADF:
                continuable("The fildes argument is not a valid file descriptor open for reading.");
                break;
            case EBADMSG:
                continuable("The file is a STREAM file that is set to control-normal mode and the message waiting to be read includes a control part.");
                break;
            case EINTR:
                continuable("The read operation was terminated due to the receipt of a signal, and no data was transferred.");
                break;
            case EINVAL:
                continuable("The STREAM or multiplexer referenced by fildes is linked (directly or indirectly) downstream from a multiplexer.\nor\nThe offset argument is invalid. The value is negative.");
                break;
            case EIO:
                continuable("The process is a member of a background process attempting to read from its controlling terminal, the process is ignoring or blocking the SIGTTIN signal, or the process group is orphaned. This error may also be generated for implementation-defined reasons.\nor\nA physical I/O error has occurred.");
                break;
            case EISDIR:
                continuable("The fildes argument refers to a directory and the implementation does not allow the directory to be read using read() or pread(). The readdir() function should be used instead.");
                break;
            case EOVERFLOW:
                continuable("The file is a regular file, nbyte is greater than 0, the starting position is before the end-of-file, and the starting position is greater than or equal to the offset maximum established in the open file description associated with fildes.\nor\nThe file is a regular file and an attempt was made to read at or beyond the offset maximum associated with the file.");
                break;
#if(EWOULDBLOCK != EAGAIN)
            case EWOULDBLOCK:
                continuable("The file descriptor is for a socket, is marked O_NONBLOCK, and no data is waiting to be received.");
                break;
#endif
            case ECONNRESET:
                continuable("A read was attempted on a socket and the connection was forcibly closed by its peer.");
                break;
            case ENOTCONN:
                continuable("A read was attempted on a socket that is not connected.");
                break;
            case ETIMEDOUT:
                continuable("A read was attempted on a socket and a transmission timeout occurred.");
                break;
            case ENOBUFS:
                continuable("Insufficient resources were available in the system to perform the operation.");
                break;
            case ENOMEM:
                continuable("Insufficient memory was available to fulfill the request.");
                break;
            case ENXIO:
                continuable("A request was made of a nonexistent device, or the request was outside the capabilities of the device.\nor\nA request was outside the capabilities of the device.");
                break;
            case ESPIPE:
                continuable("fildes is associated with a pipe or FIFO");
                break;
            default:
                break;
            }
        }
        return result;
    }

    off_t File::Validate_lseek_Result(off_t result)
    {
        if(result == -1)
        {
            switch(errno)
            {
            case EBADF:
                continuable("fd is not an open file descriptor.");
                break;
            case EFAULT:
                continuable("Problem with copying results to user space.");
                break;
            case EINVAL:
                continuable("whence is invalid");
                break;
            default:
                serious("An unknown error has occured.");
            }
        }
        return result;
    }

    uint64_t File::Validate_lseek64_Result(uint64_t result)
    {
        if(result == -1)
        {
            switch(errno)
            {
            case EBADF:
                continuable("fd is not an open file descriptor.");
                break;
            case EFAULT:
                continuable("Problem with copying results to user space.");
                break;
            case EINVAL:
                continuable("whence is invalid");
                break;
            default:
                serious("An unknown error has occured.");
            }
        }
        return result;
    }

    int File::Validate_ftruncate_Result(int result)
    {
        if(result == -1)
        {
            switch(errno)
            {
            case EBADF:
                continuable("The fildes argument is not a file descriptor open for writing.");
                break;
            case EINTR:
                continuable("A signal was caught during execution.");
                break;
            case EINVAL:
                continuable("The length argument was less than 0.\nor\nThe length argument was greater than the maximum file size.\nor\nThe fildes argument references a file that was opened without write permission.\nor\nThe fildes argument is not a file descriptor open for writing.");
                break;
            case EFBIG:
                continuable("The length argument was greater than the maximum file size.\nor\nThe file is a regular file and length is greater than the offset maximum established in the open file description associated with fildes.");
                break;
            case EIO:
                continuable("An I/O error occurred while reading from or writing to a file system.");
                break;
            case EROFS:
                continuable("The named file resides on a read-only file system.");
                break;
            default:
                serious("An unknown error has occured.");    
            }
        }
        return result;
    }

    int File::Validate_posix_fallocate_Result(int result)
    {
        switch(result)
        {
            case 0:
            return 0;
            case EBADF:
                continuable("fd is not a valid file descriptor, or is not opened for writing.");
                break;
            case EFBIG:
                continuable("offset+len exceeds the maximum file size.");
                break;
            case EINVAL:
                continuable("offset was less than 0, or len was less than or equal to 0.");
                break;
            case ENODEV:
                continuable("fd does not refer to a regular file.");
                break;
            case ENOSPC:
                continuable("There is not enough space left on the device containing the file referred to by fd.");
                break;
            case ESPIPE:
                continuable("fd refers to a pipe.");
                break;
            default:
                serious("An unknown error has occured.");
        }
        return result;
    }

    int File::Validate_fcntl_Result(int result)
    {
        if(result == -1)
        {
            switch(errno)
            {
                case EACCES:
                case EAGAIN:
                    continuable("The cmd argument is F_SETLK; the type of lock ( l_type) is a shared (F_RDLCK) or exclusive (F_WRLCK) lock and the segment of a file to be locked is already exclusive-locked by another process, or the type is an exclusive lock and some portion of the segment of a file to be locked is already shared-locked or exclusive-locked by another process.");
                    break;
                case EBADF:
                    continuable("The fildes argument is not a valid open file descriptor, or the argument cmd is F_SETLK or F_SETLKW, the type of lock, l_type, is a shared lock (F_RDLCK), and fildes is not a valid file descriptor open for reading, or the type of lock, l_type, is an exclusive lock (F_WRLCK), and fildes is not a valid file descriptor open for writing.");
                    break;
                case EINTR:
                    continuable("The cmd argument is F_SETLKW and the function was interrupted by a signal.");
                    break;
                case EINVAL:
                    continuable("The cmd argument is invalid, or the cmd argument is F_DUPFD and arg is negative or greater than or equal to {OPEN_MAX}, or the cmd argument is F_GETLK, F_SETLK, or F_SETLKW and the data pointed to by arg is not valid, or fildes refers to a file that does not support locking.");
                    break;
                case EMFILE:
                    continuable("The argument cmd is F_DUPFD and {OPEN_MAX} file descriptors are currently open in the calling process, or no file descriptors greater than or equal to arg are available.");
                    break;
                case ENOLCK:
                    continuable("The argument cmd is F_SETLK or F_SETLKW and satisfying the lock or unlock request would result in the number of locked regions in the system exceeding a system-imposed limit.");
                    break;
                case EOVERFLOW:
                    continuable("One of the values to be returned cannot be represented correctly.\nor\nThe cmd argument is F_GETLK, F_SETLK, or F_SETLKW and the smallest or, if l_len is non-zero, the largest offset of any byte in the requested segment cannot be represented correctly in an object of type off_t.");
                    break;
                case EDEADLK:
                    continuable("The cmd argument is F_SETLKW, the lock is blocked by a lock from another process, and putting the calling process to sleep to wait for that lock to become free would cause a deadlock.");
                    break;
                default:
                    serious("An unknown error has occured.");
            }
        }
        return result;
    }

    int File::Validate_posix_fadvise_Result(int result)
    {
        switch(result)
        {
            case 0:
            return 0;
            case EBADF:
                continuable("The fd argument is not a valid file descriptor.");
                break;
            case EINVAL:
                continuable("The value of advice is invalid.");
                break;
            case ESPIPE:
                continuable("The fd argument is associated with a pipe or FIFO");
                break;
            default:
                serious ("An unknown error has occured.");
        }
        return result;
    }

    int File::Validate_fchmod_Result(int result)
    {
        switch(result)
        {
            case 0:
            return 0;
            case EBADF:
                continuable("The fildes argument is not an open file descriptor.");
                break;
            case EPERM:
                continuable("The effective user ID does not match the owner of the file and the process does not have appropriate privilege.");
                break;
            case EROFS:
                continuable("The file referred to by fildes resides on a read-only file system.");
                break;
            case EINTR:
                continuable("The fchmod() function was interrupted by a signal.");
                break;
            case EINVAL:
                continuable("The value of the mode argument is invalid or the fildes argument refers to a pipe and the implementation disallows execution of fchmod() on a pipe.");
                break;
            default:
                serious("An unknown error has occured.");
        }
        return result;
    }

    void File::Check_close_Result(int result)
    {
        switch (result)
        {
            case 0:
            return;
            case EBADF:
                continuable("The fildes argument is not a valid file descriptor.");
                break;
            case EINTR:
                continuable("The close() function was interrupted by a signal.");
                break;
            case EIO:
                continuable("An I/O error occurred while reading from or writing to the file system.");
                break;
            default:
                serious("An unknown error occured.");
        }
    }

    int File::Validate_fsync_Result(int result)
    {
        switch (result)
        {
            case 0:
            return 0;
            case EBADF:
                continuable("The fildes argument is not a valid descriptor");
            break;
            case EINTR:
                continuable("The fsync() function was interrupted by a signal.");
            break;
            case EINVAL:
                continuable("The fildes argument does not refer to a file on which this operation is possible.");
            break;
            case EIO:
                continuable("An I/O error occurred while reading from or writing to the file system.");
            break;
            default:
                serious("An unknown error occured.");
        }
        return result;
    }
    
    void File::Check_fsync_Result(int result)
    {
        switch (result)
        {
            case 0:
            return;
            case EBADF:
                continuable("The fildes argument is not a valid descriptor");
            break;
            case EINTR:
                continuable("The fsync() function was interrupted by a signal.");
            break;
            case EINVAL:
                continuable("The fildes argument does not refer to a file on which this operation is possible.");
            break;
            case EIO:
                continuable("An I/O error occurred while reading from or writing to the file system.");
            break;
            default:
                serious("An unknown error occured.");
        }
    }

    void File::ErrorOnOpen(int err)
    {
        switch (err)
        {
            case EACCES:
                continuable("Search permission is denied on a component of the path prefix, or the file exists and the permissions specified by oflag are denied, or the file does not exist and write permission is denied for the parent directory of the file to be created, or O_TRUNC is specified and write permission is denied");
            break;
            case EEXIST:
                continuable("O_CREAT and O_EXCL are set, and the named file exists.");
            break;
            case EINTR:
                continuable("A signal was caught during open().");
            break;
            case EINVAL:
                continuable("The value of the oflag argument is not valid. Or the implementation does not support synchronized I/O for this file.");
            break;
            case EIO:
                continuable("The path argument names a STREAMS file and a hangup or error occurred during the open().");
            break;
            case EISDIR:
                continuable("The named file is a directory and oflag includes O_WRONLY or O_RDWR.");
            break;
            case ELOOP:
                continuable("A loop exists in symbolic links encountered during resolution of the path argument. Or more than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.");
            break;
            case EMFILE:
                continuable("{OPEN_MAX} file descriptors are currently open in the calling process.");
            break;
            case ENAMETOOLONG:
                continuable("The length of the path argument exceeds {PATH_MAX} or a pathname component is longer than {NAME_MAX}. Or as a result of encountering a symbolic link in resolution of the path argument, the length of the substituted pathname string exceeded {PATH_MAX}.");
            break;
            case ENFILE:
                continuable("The maximum allowable number of files is currently open in the system.");
            break;
            case ENOENT:
                continuable("O_CREAT is not set and the named file does not exist; or O_CREAT is set and either the path prefix does not exist or the path argument points to an empty string.");
            break;
            case ENOSR:
                continuable("The path argument names a STREAMS-based file and the system is unable to allocate a STREAM.");
            break;
            case ENOSPC:
                continuable("The directory or file system that would contain the new file cannot be expanded, the file does not exist, and O_CREAT is specified.");
            break;
            case ENOTDIR:
                continuable("A component of the path prefix is not a directory.");
            break;
            case ENXIO:
                continuable("O_NONBLOCK is set, the named file is a FIFO, O_WRONLY is set, and no process has the file open for reading.\nThe named file is a character special or block special file, and the device associated with this special file does not exist.");
            break;
            case EOVERFLOW:
                continuable("The named file is a regular file and the size of the file cannot be represented correctly in an object of type off_t.");
            break;
            case EROFS:
                continuable("The named file resides on a read-only file system and either O_WRONLY, O_RDWR, O_CREAT (if the file does not exist), or O_TRUNC is set in the oflag argument.");
            break;
            case EAGAIN:
                continuable("The path argument names the slave side of a pseudo-terminal device that is locked.");
            break;
            case ENOMEM:
                continuable("The path argument names a STREAMS file and the system is unable to allocate resources.");
            break;
            case ETXTBSY:
                continuable("The file is a pure procedure (shared text) file that is being executed and oflag is O_WRONLY or O_RDWR.");
            break;
            default:
                serious("An unknown error occured.");
            break;
        }
    }
}}//qor::nslinux