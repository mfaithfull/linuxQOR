// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_OS_LINUX_SYSTEM_FILESYSTEM_FILEDESCRIPTOR
#define QOR_PP_H_OS_LINUX_SYSTEM_FILESYSTEM_FILEDESCRIPTOR

namespace qor{ namespace nslinux{ 

    class qor_pp_module_interface(QOR_LINUXFILESYSTEM) FileDescriptor
    {
    public:

        FileDescriptor(int fd) : m_fd(fd)
        {
        }

        FileDescriptor(const FileDescriptor& src) : m_fd(src.m_fd)
        {
        }

        virtual ~FileDescriptor() = default;

        int Control(int command, ...)
        {
            int result = -1;
            va_list args;
            va_start(args, command);
            result = ::fcntl(m_fd, command, args);
            va_end(args);
            return result;
        }

        int Duplicate()
        {
            return Control(F_DUPFD);
        }

        int GetFlags()
        {
            return Control(F_GETFD);
        }

        int SetFlags(int flags)
        {
            return Control(F_SETFD, flags);
        }

        int SetCloseOnExec()
        {
            return SetFlags(FD_CLOEXEC);
        }

        int GetStatusAndAccessModeFlags()
        {
            return Control(F_GETFL);
        }

        int SetStatusAndAccessModeFlags(int flags)
        {
            return Control(F_SETFL);
        }

        int GetOwningProcessGroup()
        {
            //m_fd must be a socket
            return Control(F_GETOWN);
        }

        int SetOwningProcessGroup()
        {
            //m_fd must be a socket
            return Control(F_SETOWN);
        }

        int GetLock(struct flock& lock)
        {
            return Control(F_GETLK, &lock);
        }

        int SetLock(const struct flock& lock)
        {
            return Control(F_SETLK, &lock);
        }

        int SetLockW(const struct flock& lock)
        {
            return Control(F_SETLKW, &lock);
        }
        
        int Status(struct stat* buf)
        {
            return ::fstat(m_fd, buf);
        }

        int Status64(struct stat64* buf)
        {
            return ::fstat64 (m_fd, buf);
        }

        void* MemoryMap(void *address, size_t length, int protect, int flags, off_t offset)
        {
            return ::mmap (address, length, protect, flags, m_fd, offset);
        }

        void* MemoryMap64(void *address, size_t length, int protect, int flags, off64_t offset)
        {
            return ::mmap64(address, length, protect, flags, m_fd, offset);
        }

        int Close()
        {
            return ::close(m_fd);
        }

        int ChangeOwner(uid_t owner, gid_t group)
        {
            return ::fchown (m_fd, owner, group);
        }

        int IsATTY()
        {
            return ::isatty(m_fd);
        }

        off_t Seek(off_t offset, int whence)
        {
            return ::lseek(m_fd, offset, whence);
        }

        off64_t Seek64(off64_t offset, int whence)
        {
            return ::lseek64(m_fd, offset, whence);
        }

        int ChangeMode(mode_t mode)
        {
            return ::fchmod(m_fd, mode);
        }

        ssize_t Read(void* buffer, size_t size)
        {
            return ::read(m_fd, buffer, size);
        }

        ssize_t PRead (void* buffer, size_t size, off_t offset)
        {
            return ::pread(m_fd, buffer, size, offset);
        }

        ssize_t PRead64(void* buffer, size_t size, off64_t offset)
        {
            return ::pread64(m_fd, buffer, size, offset);
        }

        ssize_t Write(const void *buffer, size_t size)
        {
            return ::write(m_fd, buffer, size);
        }

        ssize_t PWrite (const void* buffer, size_t size, off_t offset)
        {
            return ::pwrite(m_fd, buffer, size, offset);
        }

        ssize_t PWrite64 (const void* buffer, size_t size, off64_t offset)
        {
            return ::pwrite64(m_fd, buffer, size, offset);
        }

        int IOControl(int command, ...)
        {
            int result = -1;
            va_list args;
            va_start(args, command);
            result = ::ioctl(m_fd, command, args);
            va_end(args);
            return result;
        }

        int ChangeDirectory()
        {
            return ::fchdir(m_fd);
        }

        ssize_t ReadV(const struct iovec *vector, int count)
        {
            return ::readv(m_fd, vector, count);
        }

        ssize_t WriteV(const struct iovec *vector, int count)
        {
            return ::writev(m_fd, vector, count);
        }

        long int GetConfigurationValues(int parameter)
        {
            return::fpathconf(m_fd, parameter);
        }

        FILE* OpenAsStream(const char* opentype)
        {
            return ::fdopen(m_fd, opentype);
        }

        int Sync()
        {
            return ::fsync(m_fd);
        }

        int DataSync()
        {
            return ::fdatasync(m_fd);
        }

        int AIO_Cancel(struct aiocb *aiocbp)
        {
            return ::aio_cancel(m_fd, aiocbp);
        }

        int AIO_Cancel64(struct aiocb64 *aiocbp)
        {
            return ::aio_cancel64 (m_fd, aiocbp);
        }

        int Allocate(off64_t offset, off64_t length)
        {
            return ::posix_fallocate64(m_fd, offset, length);
        }

        DIR* OpenAsDirectory()
        {
            return ::fdopendir(m_fd);
        }

        int UpdateTimes(const struct timeval tvp[2])
        {
            return ::futimes(m_fd, tvp);
        }

        int Truncate(off_t length)
        {
            return ::ftruncate(m_fd, length);
        }

        int Truncate64(off64_t length)
        {
            return ::ftruncate64(m_fd, length);
        }

        void BackTraceSymbols(void* const* buffer, int size)
        {
            return ::backtrace_symbols_fd(buffer, size, m_fd);
        }

    private:
        
        int m_fd;
    };
}}//qor::nslinux

#endif//QOR_PP_H_OS_LINUX_SYSTEM_FILESYSTEM_FILE

