// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include "device.h"
#include "input.h"
#include "src/platform/os/linux/x/xlib/display.h"
#include "src/platform/os/linux/x/xlib/window.h"
#include "src/qor/error/error.h"

#include <X11/Xlib.h>
#include <X11/X.h>
#include <X11/Xcms.h>
#include <X11/Xutil.h>
#include <X11/Xresource.h>
#include <X11/Xatom.h>
#include <X11/cursorfont.h>
#include <X11/keysymdef.h>
#include <X11/keysym.h>
#include <X11/Xlibint.h>
#include <X11/Xproto.h>
#include <X11/Xprotostr.h>
#include <X11/extensions/XInput.h>

#define WITH_THIS (::Display*)(m_display->Use()), (::XDevice*)(m_device)
namespace qor{ namespace platform { namespace nslinux{ namespace x{

    Device::Device(Display* dpy, void* device) : m_display(dpy), m_device(device)
    {        
    }

    Device::~Device()
    {
        XCloseDevice(WITH_THIS);
    }

    int	Device::ChangeKeyboard()
    {
        return XChangeKeyboardDevice(WITH_THIS);
    }

    int	Device::ChangePointer(int xaxis, int yaxis)
    {
        return XChangePointerDevice(WITH_THIS, xaxis, yaxis);
    }

    int	Device::Grab(Window& grabWindow, int ownerEvents, int eventCount, unsigned long* eventList, int thisDeviceMode, int otherDevicesMode, unsigned long time)
    {
        return XGrabDevice(WITH_THIS, grabWindow.GetId(), ownerEvents, eventCount, eventList, thisDeviceMode, otherDevicesMode, time);
    }

    int	Device::Ungrab(unsigned long time)
    {
        return XUngrabDevice(WITH_THIS, time);
    }

    int	Device::GrabKey(unsigned int key, unsigned int modifiers, Device& modifierDevice, Window& grabWindow, int ownerEvents, unsigned int eventCount, unsigned long* eventList, int thisDeviceMode, int otherDevicesMode)
    {
        return XGrabDeviceKey(WITH_THIS, key, modifiers, (::XDevice*)(modifierDevice.Use()), grabWindow.GetId(), ownerEvents, eventCount, eventList, thisDeviceMode, otherDevicesMode);
    }

    int	Device::UngrabKey(unsigned int key, unsigned int modifiers, Device& modifierDev, Window& grabWindow)
    {
        return XUngrabDeviceKey(WITH_THIS, key, modifiers, (::XDevice*)(modifierDev.Use()), grabWindow.GetId());
    }

    int	Device::GrabButton(unsigned int button, unsigned int modifiers, Device& modifierDevice, Window& grabWindow, int ownerEvents, unsigned int eventCount, unsigned long* eventList, int thisDeviceMode, int otherDevicesMode)
    {
        return XGrabDeviceButton(WITH_THIS, button, modifiers, (::XDevice*)(modifierDevice.Use()), grabWindow.GetId(), ownerEvents, eventCount, eventList, thisDeviceMode, otherDevicesMode);
    }

    int Device::UngrabButton(unsigned int button, unsigned int modifiers, Device& modifierDev, Window& grabWindow)
    {
        return XUngrabDeviceButton(WITH_THIS, button, modifiers, (::XDevice*)(modifierDev.Use()), grabWindow.GetId());
    }

    int Device::AllowEvents(int eventMode, unsigned long time)
    {
        return XAllowDeviceEvents(WITH_THIS, eventMode, time);
    }

    int	Device::GetFocus(unsigned long& focus, int& revert_to, unsigned long& time)
    {
        return XGetDeviceFocus(WITH_THIS, &focus, &revert_to, &time);
    }

    int	Device::SetFocus(unsigned long focus, int revert_to, unsigned long time)
    {
        return XSetDeviceFocus(WITH_THIS, focus, revert_to, time);
    }

    std::vector<FeedbackState> Device::GetFeedbackControl()
    {
        std::vector<FeedbackState> feedback;
        int count = 0;
        XFeedbackState* data = XGetFeedbackControl(WITH_THIS, &count);
        if(count != 0 && data != nullptr)
        {
            feedback.resize(count);
            memcpy(feedback.data(), data, sizeof(FeedbackState) * count);
            XFreeFeedbackList(data);
        }
        return feedback;
    }

    int	Device::ChangeFeedbackControl(unsigned long mask, FeedbackControl& f)
    {
        return XChangeFeedbackControl(WITH_THIS, mask, reinterpret_cast<XFeedbackControl*>(&f));
    }

    int	Device::Bell(unsigned long feedbackclass, unsigned long feedbackid, int percent)
    {
        return XDeviceBell(WITH_THIS, feedbackclass, feedbackid, percent);
    }

    int	Device::ChangeKeyMapping(int first, int symsPerCode, std::vector<unsigned long> keysyms)
    {
        return XChangeDeviceKeyMapping(WITH_THIS, first, symsPerCode, keysyms.data(), keysyms.size());
    }

    std::vector<unsigned char> Device::GetModifierMapping(int& maxKeyPerMod)
    {
        std::vector<unsigned char> modifiers;        
        XModifierKeymap* data = XGetDeviceModifierMapping(WITH_THIS);
        if( data != nullptr)
        {
            maxKeyPerMod = data->max_keypermod;
            int count = 8 * data->max_keypermod;
            modifiers.resize(count);
            memcpy(modifiers.data(), data, count);
            XFree(data);
        }
        return modifiers;
    }

    int	Device::SetModifierMapping(std::vector<unsigned char> map, int maxKeyPerMod)
    {
        XModifierKeymap keymap;
        keymap.max_keypermod = maxKeyPerMod;
        keymap.modifiermap = map.data();
        return XSetDeviceModifierMapping(WITH_THIS, &keymap);
    }

    int	Device::SetButtonMapping(std::vector<unsigned char>& map)
    {
        return XSetDeviceButtonMapping(WITH_THIS, map.data(), map.size());
    }

    int	Device::GetButtonMapping(std::vector<unsigned char>& map)
    {
        return XGetDeviceButtonMapping(WITH_THIS, map.data(), map.size());
    }

    std::vector<InputClass> Device::QueryState()
    {
        std::vector<InputClass> inputClasses;
        XDeviceState* data = XQueryDeviceState(WITH_THIS);
        if(data != nullptr)
        {
            inputClasses.resize(data->num_classes);
            memcpy(inputClasses.data(), data->data, sizeof(InputClass) * data->num_classes);
            XFreeDeviceState(data);
        }
        return inputClasses;
    }

    int	Device::SetMode(int mode)
    {
        return XSetDeviceMode(WITH_THIS, mode);
    }

    int	Device::SetValuators(int* valuators, int first_valuator, int num_valuators)
    {
        return XSetDeviceValuators(WITH_THIS, valuators, first_valuator, num_valuators);
    }

    DeviceControl Device::GetControl(int control)
    {
        DeviceControl deviceControl;
        XDeviceControl* data = XGetDeviceControl(WITH_THIS, control);
        if(data != nullptr)
        {
            deviceControl = *(reinterpret_cast<DeviceControl*>(data));
            XFreeDeviceControl(data);
        }
        return deviceControl;
    }

    int	Device::ChangeControl(int control, DeviceControl& d)
    {
        return XChangeDeviceControl(WITH_THIS, control, reinterpret_cast<XDeviceControl*>(&d));
    }

    int	Device::SendExtensionEvent(Window& dest, int prop, int count, unsigned long* list, Event* event)
    {
        return XSendExtensionEvent(WITH_THIS, dest.GetId(), prop, count, list, reinterpret_cast<XEvent*>(event));
    }

    std::vector<DeviceTimeCoord> Device::GetMotionEvents(unsigned long start, unsigned long stop, int* mode, int* axis_count)
    {
        std::vector<DeviceTimeCoord> events;
        int count = 0;
        XDeviceTimeCoord* data = XGetDeviceMotionEvents(WITH_THIS, start, stop, &count, mode, axis_count);
        if(count != 0 && data != nullptr)
        {
            events.resize(count);
            memcpy(events.data(), data, sizeof(DeviceTimeCoord) * count);
            XFreeDeviceMotionEvents(data);
        }
        return events;
    }

    std::vector<unsigned long> Device::ListProperties()
    {
        std::vector<unsigned long> properties;
        int count = 0;
        unsigned long* data = XListDeviceProperties(WITH_THIS, &count);
        if(count != 0 && data != nullptr)
        {
            properties.resize(count);
            memcpy(properties.data(), data, sizeof(unsigned long) * count);
            XFree(data);
        }
        return properties;
    }

    void Device::ChangeProperty(unsigned long property, unsigned long type, int format, int mode, const std::vector<unsigned char> data)
    {
        return XChangeDeviceProperty(WITH_THIS, property, type, format, mode, data.data(), data.size());
    }

    void Device::DeleteProperty(unsigned long property)
    {
        return XDeleteDeviceProperty(WITH_THIS, property);
    }

    int Device::GetProperty(unsigned long property, long offset, long length, int del, unsigned long reqType, unsigned long& actualType, int& actualFormat, unsigned long& bytesAfter, std::vector<unsigned char>& prop)
    {
        unsigned long nitems = 0;
        unsigned char* data = nullptr;
        int status = XGetDeviceProperty(WITH_THIS, property, offset, length, del, reqType, &actualType, &actualFormat, &nitems, &bytesAfter, &data);
        if( nitems != 0 && data != nullptr)
        {
            prop.clear();
            prop.resize(nitems * (actualFormat / 8));
            memcpy(prop.data(), data, nitems * (actualFormat / 8));
            XFree(data);
        }
        return status;
    }

    std::vector<unsigned long> Device::GetKeyMapping(unsigned int first,int keycount, int& symsPerCode)
    {
        std::vector<unsigned long> keyMapping;        
        unsigned long* data = XGetDeviceKeyMapping(WITH_THIS, first, keycount, &symsPerCode);
        if(data != nullptr)
        {
            keyMapping.resize(keycount);
            memcpy(keyMapping.data(), data, sizeof(unsigned long) * keycount);
            XFree(data);
        }
        return keyMapping;
    }
    
}}}}//qor::platform::nslinux::x

#undef WITH_THIS