// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "sdk/using_framework.h"
#include "src/platform/os/linux/x/xlib/xlib.h"
#include "src/platform/os/linux/x/xlib/display.h"
#include "src/platform/os/linux/x/xlib/screen.h"
#include "src/platform/os/linux/x/xlib/window.h"
#include "src/platform/os/linux/x/xlib/font.h"

const char* appName = "XRaw";

qor_pp_implement_module(appName)
qor_pp_module_requires(ICurrentThread)
qor_pp_module_requires(XClient)

int main()
{
    auto xrawApp = AppBuilder().Build(appName);

    xrawApp->SetRole<Role>(
        [](ref_of<IRole>::type role)
        {
            qor_pp_fcontext;
            
            role->AddFeature<ThreadPool>(
                [](ref_of<ThreadPool>::type threadPool)
                {
                    threadPool->SetThreadCount(2);
                    qor::framework::CurrentThread::GetCurrent().SetName("Main");
                }
            );

            role->AddFeature<qor::platform::nslinux::XClient>();
        }
    );

    return xrawApp(qor_shared).Run
    (
        make_runable(

            []()->int
            {
                auto xclient = AppBuilder().TheApplication(qor_shared)->GetRole(qor_shared)->GetFeature<qor::platform::nslinux::XClient>();
                {
                    auto defaultDisplay = xclient->GetDisplay(0);

                    int status = defaultDisplay->NoOp();                
                    int connctionNumber = defaultDisplay->ConnectionNumber();
                    int protocolVersion = defaultDisplay->ProtocolVersion();
                    int protocolRevision = defaultDisplay->ProtocolRevision();

                    std::string displayString = defaultDisplay->DisplayString();
                    std::string serverVendor = defaultDisplay->ServerVendor();
                    int vendorRelease = defaultDisplay->VendorRelease();
                    int numberOfScreens = defaultDisplay->ScreenCount();
                    int defaultScreen = defaultDisplay->DefaultScreen();

                    int depth = defaultDisplay->DefaultDepth();
                    int bitmapBitOrder = defaultDisplay->BitmapBitOrder();
                    int bitmapUnit = defaultDisplay->BitmapUnit();
                    int bitmapPad = defaultDisplay->BitmapPad();

                    unsigned long blackPixel = defaultDisplay->BlackPixel();
                    unsigned long whitePixel = defaultDisplay->WhitePixel();
                    unsigned long defaultColourmap = defaultDisplay->DefaultColourmap();
                    //defaultDisplay->DefaultGC();
                    int cells = defaultDisplay->DisplayCells();
                    int planes = defaultDisplay->DisplayPlanes();
                    int width = defaultDisplay->Width();
                    int height = defaultDisplay->Height();
                    int widthMM = defaultDisplay->WidthMM();
                    int heightMM = defaultDisplay->HeightMM();
                    std::vector<int> depths = defaultDisplay->ListDepths();

                    long maxRequestSize = defaultDisplay->MaxRequestSize();
                    auto formats = defaultDisplay->ListPixmapFormats();

                    qor::platform::nslinux::x::VisualInfoQuery visualInfoQuery;
                    visualInfoQuery.SetDepth(24);
                    visualInfoQuery.SetBitsPerRGB(8);                    

                    auto visualInfo = defaultDisplay->GetVisualInfo(visualInfoQuery);

                    auto window = defaultDisplay->DefaultRootWindow();

                    auto screen = defaultDisplay->ScreenOfDisplay(defaultDisplay->DefaultScreen());

                    {                        
                        std::vector<std::string> vecNames;
                        qor::platform::nslinux::x::FontInfoHolder f = defaultDisplay->ListFontsWithInfo("*", 200, vecNames);
                    }

                    auto extensions = defaultDisplay->ListExtensions();
                    for(auto extension : extensions)
                    {
                        std::cout << "Extension: " << extension << std::endl;
                    }
                    
                    unsigned long screenBlackPixel = screen.BlackPixel();
                    auto screenRootWindow = screen.RootWindow();

                    auto toplevelWindow = screenRootWindow.CreateChildWindow(0, 0, 800, 600, 1, 0, 0x00aabbcc);                    
                    toplevelWindow->SetBorderWidth(12);

                    qor::platform::nslinux::x::WindowChangeQuery windowChangeQuery;
                    windowChangeQuery.SetBorderWidth(0);
                    windowChangeQuery.Setx(20);
                    windowChangeQuery.Sety(20);
                    toplevelWindow->Configure(windowChangeQuery);

                    qor::platform::nslinux::x::SetWindowAttributesQuery windowSetAttribs;
                    windowSetAttribs.SetSaveUnder(1);
                    windowSetAttribs.SetBitGravity(qor::platform::nslinux::x::Window::NorthWestGravity);
                    toplevelWindow->ChangeAttributes(windowSetAttribs);
                    toplevelWindow->SetTitle("X Window");
                    std::string title = toplevelWindow->GetTitle();

                    auto hints = toplevelWindow->GetWMHints();
                    hints.flags = (1L << 1);
                    hints.initial_state = 3;
                    toplevelWindow->SetWMHints(hints);

                    //If we want the border/decorations from the Window Manager gone this is required
                    std::string motifHintsAtomName("_MOTIF_WM_HINTS");
                    unsigned long motifWMHintsProperty = defaultDisplay->GetAtom(motifHintsAtomName.data());
                    qor::platform::nslinux::x::MotifWmHints mhints = {0};
                    mhints.flags = MWM_HINTS_DECORATIONS;
                    mhints.decorations = 0;
                    //toplevelWindow->ChangeProperty(motifWMHintsProperty, motifWMHintsProperty, 32, qor::platform::nslinux::x::Window::PropModeReplace, (unsigned char*)(&mhints), sizeof(mhints)/sizeof(long));

                    //This is needed to actually position the window as the Window Manager ignores the position set when the window was created
                    long validBitsOfReturn = 0;
                    qor::platform::nslinux::x::WMSizeHints normalHints = toplevelWindow->GetNormalHints(validBitsOfReturn, status);
                    normalHints.ResetFlags();
                    normalHints.SetPosition(50,50);
                    normalHints.SetSize(800,600);
                    toplevelWindow->SetNormalHints(normalHints);


                    std::vector<unsigned long> atoms = toplevelWindow->ListProperties();
                    for(unsigned long prop : atoms)
                    {
                        std::string name(defaultDisplay->GetAtomName(prop));

                        unsigned char* data;
                        unsigned long actualType = 0;
                        int actualFormat = 0;
                        unsigned long itemsReturned = 0;
                        unsigned long bytesUnread = 0;

                        toplevelWindow->GetProperty(prop, 0, 1, 0, qor::platform::nslinux::x::Window::AnyPropertyType, &actualType, &actualFormat, &itemsReturned, &bytesUnread, &data);

                        if(bytesUnread != 0)
                        {
                            //consider getting some more
                        }
                        if(data != nullptr)
                        {
                            xclient->Free(data);//Horrible! We need to find a way to wrap the data in a Ref before returning it to this level.
                        }
                    }

                    //Set this so the Window Manager will send us a Client message for closing the window not just kill the process.
                    auto wm_delete_window = defaultDisplay->GetAtom("WM_DELETE_WINDOW");
                    toplevelWindow->SetWMProtocols(&wm_delete_window, 1);

                    //Determine what normal events we want to recieve
                    toplevelWindow->SelectInput( qor::platform::nslinux::x::KeyPressMask | qor::platform::nslinux::x::ExposureMask | qor::platform::nslinux::x::StructureNotifyMask);

                    toplevelWindow->Map();
                    defaultDisplay->Flush();

                    bool quit = false;
                    while(!quit)
                    {
                        int result = 0;
                        while(
                            defaultDisplay->ProcessEvent(
                                [&defaultDisplay, &quit](int type) -> qor::platform::nslinux::x::eventHandler
                                {
                                    switch(type)
                                    {
                                    case qor::platform::nslinux::x::ClientMessageType:
                                        return [&defaultDisplay, &quit](qor::platform::nslinux::x::Event& event) -> int
                                        {
                                            if (  event.xclient.message_type  == defaultDisplay->GetAtom("WM_PROTOCOLS")
                                                && event.xclient.data.l[0]  == defaultDisplay->GetAtom("WM_DELETE_WINDOW"))
                                            {
                                                quit = true;
                                            }                                        
                                            return 0;
                                        };
                                    case qor::platform::nslinux::x::KeyPressType:
                                        return [&defaultDisplay, &quit](qor::platform::nslinux::x::Event& event) -> int
                                        {
                                            if (defaultDisplay->LookupKeySymbol(reinterpret_cast<qor::platform::nslinux::x::KeyEvent&>(event), 0) == qor::platform::nslinux::x::XK_Escape)
                                            {
                                                quit = true;
                                            }
                                            return 0;
                                        };
                                    default:
                                        return [](qor::platform::nslinux::x::Event& event) -> int
                                        {
                                            return 0;
                                        };
                                    }
                                }, result
                            ) > 0 
                        )
                        {
                            
                        }
                    }
                    toplevelWindow->Unmap();
                }                

                return EXIT_SUCCESS;
            }
        )
    );
}

