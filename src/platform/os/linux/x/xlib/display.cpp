// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"
#include "src/qor/error/error.h"

#include "display.h"
#include "gc.h"
#include "screen.h"
#include "window.h"
#include "visual.h"
#include "pixmap.h"
#include "font.h"
#include "colourmap.h"
#include "image.h"

#include <X11/Xlib.h>
#include <X11/X.h>
#include <X11/Xcms.h>
#include <X11/Xutil.h>
#include <X11/Xresource.h>
#include <X11/Xatom.h>
#include <X11/cursorfont.h>
#include <X11/keysymdef.h>
#include <X11/keysym.h>
#include <X11/Xlibint.h>
#include <X11/Xproto.h>
#include <X11/Xprotostr.h>

#undef BlackPixel
#undef WhitePixel
#undef DefaultScreen
#undef ConnectionNumber
#undef DefaultDepth
#undef DefaultGC
#undef DefaultRootWindow
#undef DefaultScreenOfDisplay
#undef ScreenOfDisplay
#undef DefaultVisual
#undef DisplayCells
#undef DisplayPlanes
#undef DisplayString
#undef LastKnownRequestProcessed
#undef NextRequest
#undef ProtocolVersion
#undef ProtocolRevision
#undef QLength
#undef RootWindow
#undef ScreenCount
#undef ServerVendor
#undef VendorRelease
#undef ImageByteOrder
#undef BitmapUnit
#undef BitmapBitOrder
#undef BitmapPad

namespace qor{ namespace platform { namespace nslinux{ namespace x{

    typedef int(eventPred)(::Display*, XEvent*, XPointer);

    FontInfoHolder::FontInfoHolder(FontStruct* fontInfo, int count) : m_fontInfo(fontInfo), m_count(count) 
    {}

    FontInfoHolder::FontInfoHolder(FontInfoHolder&& src) : m_fontInfo(std::move(src.m_fontInfo)), m_count(std::move(src.m_count))
    {
        src.m_fontInfo = nullptr;
    }

    FontInfoHolder::~FontInfoHolder()
    {
        if(m_fontInfo)
        {
            XFreeFontInfo(nullptr, reinterpret_cast<XFontStruct*>(m_fontInfo), 0);
        }
    }

    ModifierKeymapHolder::ModifierKeymapHolder()
    {
        m_modifierKeyMap.max_keypermod = 0;
        m_modifierKeyMap.modifiermap = nullptr;
    }

    ModifierKeymapHolder::ModifierKeymapHolder(ModifierKeymap* keymapInfo)
    {
        m_modifierKeyMap.max_keypermod = keymapInfo->max_keypermod;
        m_modifierKeyMap.modifiermap = new unsigned char[ 8 * m_modifierKeyMap.max_keypermod ];
        memcpy(&m_modifierKeyMap.modifiermap[0], keymapInfo->modifiermap, 8 * m_modifierKeyMap.max_keypermod);
    }

    ModifierKeymapHolder::ModifierKeymapHolder(ModifierKeymapHolder&& src) : m_modifierKeyMap(std::move(src.m_modifierKeyMap))
    {
        src.m_modifierKeyMap.modifiermap = nullptr;
        src.m_modifierKeyMap.max_keypermod = 0;
    }

    ModifierKeymapHolder::~ModifierKeymapHolder()
    {
        if(m_modifierKeyMap.modifiermap)
        {
            delete [] m_modifierKeyMap.modifiermap;
        }
    }

    KeyboardMappingHolder::KeyboardMappingHolder(unsigned long* symbols, int count, unsigned int symsPerKeycode) : m_symsPerKeycode(symsPerKeycode)
    {
        m_keySyms.resize(count);
        memcpy(m_keySyms.data(), symbols, sizeof(unsigned long) * count);
    }

    Display::Display(const std::string& protocol, const std::string& hostname, int display_number, int screen_number) : temporary(false)
    {
        std::string name;
        if(!protocol.empty())
        {
            name = std::format("{0}/{1}:{2}.{3}", protocol, hostname, display_number, screen_number);
        }
        else if(!hostname.empty())
        {
            name = std::format("{0}:{1}.{2}", hostname, display_number, screen_number);
        }
        else
        {
            name = std::format(":{0}.{1}", display_number, screen_number);
        }
        m_display = XOpenDisplay(name.c_str());
        if(m_display == nullptr)
        {
            continuable("Failed to open X Server {0}", name);
        }
        
        //TODO Check for and initialise "Generic Event Extension" XInitExtension()
        //TODO Check for and initialise "BIG-REQUESTS" XInitExtension()
        //TODO Check for and initialise "XC-MISC" XInitExtension()
    }

    Display::Display(const char* name) : temporary(false)
    {
        m_display = XOpenDisplay(name);
        // TODO Check for and initialise "Generic Event Extension" XInitExtension()
    }

    Display::Display(void* display) : temporary(true)
    {
        m_display = display;
    }

    Display::~Display()
    {
        if(m_display && !temporary)
        {
           XCloseDisplay((::Display*)(m_display));
        }
    }

    void* Display::Use()
    {
        return m_display;
    }

    int Display::DefaultScreen()
    {
        return XDefaultScreen((::Display*)(m_display));
    }

    unsigned long Display::BlackPixel()
    {
        return BlackPixel(DefaultScreen());
    }

    unsigned long Display::BlackPixel(int screen_number)
    {
        return XBlackPixel((::Display*)(m_display), screen_number);
    }

    unsigned long Display::WhitePixel()
    {
        return WhitePixel(DefaultScreen());
    }

    unsigned long Display::WhitePixel(int screen_number)
    {
        return XWhitePixel((::Display*)(m_display), screen_number);
    }

    int Display::ConnectionNumber()
    {
        return XConnectionNumber((::Display*)(m_display));
    }

    int Display::DefaultDepth()
    {
        return DefaultDepth(DefaultScreen());
    }

    int Display::DefaultDepth(int screen_number)
    {
        return XDefaultDepth((::Display*)(m_display), screen_number);
    }

    unsigned long Display::DefaultColourmap()
    {
        return DefaultColourmap(DefaultScreen());
    }

    unsigned long Display::DefaultColourmap(int screen_number)
    {
        return XDefaultColormap((::Display*)(m_display), screen_number);
    }

    const std::vector<int> Display::ListDepths()
    {
        return ListDepths(DefaultScreen());
    }

    const std::vector<int> Display::ListDepths(int screen_number)
    {
        std::vector<int> result;
        int count = 0;
        int* depths = XListDepths((::Display*)(m_display), screen_number, &count);
        if(depths != nullptr)
        {
            result.resize(count);
            memcpy(result.data(), depths, count);
            XFree(depths);
        }
        return result;
    }
    
    GC Display::DefaultGC()
    {
        return DefaultGC(DefaultScreen());
    }

    GC Display::DefaultGC(int screen_number)
    {
        return GC(this, XDefaultGC((::Display*)(m_display), screen_number));
    }

    Window Display::DefaultRootWindow()
    {
        return Window(XDefaultRootWindow((::Display*)(m_display)), this);
    }

    Screen Display::DefaultScreenOfDisplay()
    {
        return Screen(XDefaultScreenOfDisplay((::Display*)(m_display)), this);
    }

    Screen Display::ScreenOfDisplay(int screen_number)
    {
        return Screen(XScreenOfDisplay((::Display*)(m_display), screen_number), this);
    }

    Visual Display::DefaultVisual()
    {
        return XDefaultVisual((::Display*)(m_display), DefaultScreen());
    }

    Visual Display::DefaultVisual(int screen_number)
    {
        return XDefaultVisual((::Display*)(m_display), screen_number);
    }

    int Display::DisplayCells()//entries in colour map
    {
        return XDisplayCells((::Display*)(m_display), DefaultScreen());
    }

    int Display::DisplayCells(int screen_number)//entries in colour map
    {
        return XDisplayCells((::Display*)(m_display), screen_number);
    }

    int Display::DisplayPlanes()
    {
        return XDisplayPlanes((::Display*)(m_display), DefaultScreen());
    }

    int Display::DisplayPlanes(int screen_number)
    {
        return XDisplayPlanes((::Display*)(m_display), screen_number);
    }

    const std::string Display::DisplayString()
    {
        char* szdisplay = XDisplayString((::Display*)(m_display));
        std::string display(szdisplay);
        //XFree(szdisplay);//Don't free this gets freed as part of XCloseDisplay
        return display;
    }

    long Display::MaxRequestSize()
    {
        return XMaxRequestSize((::Display*)(m_display));
    }

    unsigned long Display::LastKnownRequestProcessed()
    {
        return XLastKnownRequestProcessed((::Display*)(m_display));
    }

    unsigned long Display::NextRequest()
    {
        return XNextRequest((::Display*)(m_display));
    }

    int Display::ProtocolVersion()
    {
        return XProtocolVersion((::Display*)(m_display));
    }

    int Display::ProtocolRevision()
    {
        return XProtocolRevision((::Display*)(m_display));
    }

    int Display::QLength()
    {   
        return XQLength((::Display*)(m_display));
    }

    Window Display::RootWindow()
    {
        return Window(XRootWindow((::Display*)(m_display), DefaultScreen()), this);
    }

    Window Display::RootWindow(int screen_number)
    {
        return Window(XRootWindow((::Display*)(m_display), screen_number), this);
    }

    int Display::ScreenCount()
    {
        return XScreenCount((::Display*)(m_display));
    }

    const std::string Display::ServerVendor()
    {
        char* szvendor = XServerVendor((::Display*)(m_display));
        std::string serverVendor(szvendor);
        //XFree(szvendor);//Don't free this gets freed as part of XCloseDisplay
        return serverVendor;
    }

    const int Display::VendorRelease()
    {
        return XVendorRelease((::Display*)(m_display));
    }

    int Display::ImageByteOrder()// LSBFirst or MSBFirst
    {
        return XImageByteOrder((::Display*)(m_display));        
    }

    int Display::BitmapUnit()//scan line length in bits
    {
        return XBitmapUnit((::Display*)(m_display));
    }

    int Display::BitmapBitOrder()//LSBFirst or MSBFirst
    {
        return XBitmapBitOrder((::Display*)(m_display));
    }

    int Display::BitmapPad()//scan line modulus/padding in bits
    {
        return XBitmapPad((::Display*)(m_display));
    }

    int Display::Height()//pixels
    {
        return XDisplayHeight((::Display*)(m_display), DefaultScreen());
    }

    int Display::HeightMM()
    {
        return XDisplayHeightMM((::Display*)(m_display), DefaultScreen());
    }

    int Display::Width()//pixels
    {
        return XDisplayWidth((::Display*)(m_display), DefaultScreen());
    }

    int Display::WidthMM()
    {
        return XDisplayWidthMM((::Display*)(m_display), DefaultScreen());
    }

    int Display::Height(int screen_number)//pixels
    {
        return XDisplayHeight((::Display*)(m_display), screen_number);
    }

    int Display::HeightMM(int screen_number)
    {
        return XDisplayHeightMM((::Display*)(m_display), screen_number);
    }

    int Display::Width(int screen_number)//pixels
    {
        return XDisplayWidth((::Display*)(m_display), screen_number);
    }

    int Display::WidthMM(int screen_number)
    {
        return XDisplayWidthMM((::Display*)(m_display), screen_number);
    }

    int Display::NoOp()
    {
        return XNoOp((::Display*)(m_display));
    }

    int Display::SetCloseDownMode(int close_mode)
    {
        return XSetCloseDownMode((::Display*)(m_display), close_mode);
    }

    const std::vector<PixmapFormatValue> Display::ListPixmapFormats()
    {
        std::vector<PixmapFormatValue> result;
        int count = 0;
        PixmapFormatValue* formats = reinterpret_cast<PixmapFormatValue*>(XListPixmapFormats((::Display*)(m_display), &count));
        if(count != 0 && formats != nullptr)
        {
            result.resize(count);
            memcpy(result.data(), formats, sizeof(PixmapFormatValue) * count);
            XFree(formats);
        }
        return result;
    }

    void Display::Lock()
    {
        XLockDisplay((::Display*)(m_display));
    }
    
    void Display::Unlock()
    {
        XUnlockDisplay((::Display*)(m_display));
    }

    Pixmap Display::GetPixmap(unsigned long drawableId, unsigned int width, unsigned int height, unsigned int depth)
    {
        Pixmap p(this, drawableId, width, height, depth);
        return p;
    }

    std::vector<VisualInfo> Display::GetVisualInfo(long vinfo_mask, VisualInfo& vinfo_template)
    {
        std::vector<VisualInfo> result;
        int count = 0;
        XVisualInfo* info = XGetVisualInfo((::Display*)(m_display), vinfo_mask, reinterpret_cast<::XVisualInfo*>(&vinfo_template), &count);
        if(info != nullptr && count != 0)
        {
            result.resize(count);
            memcpy(result.data(), info, sizeof(XVisualInfo) * count);
            XFree(info);
        }
        return result;
    }

    std::vector<VisualInfo> Display::GetVisualInfo(VisualInfoQuery& visualInfoQuery)
    {
        return GetVisualInfo(visualInfoQuery.Mask(), visualInfoQuery.Info());
    }

    int Display::Flush()
    {
        return XFlush((::Display*)(m_display));
    }

    unsigned long Display::GetAtom(const char* name)
    {
        return XInternAtom((::Display*)(m_display), name, 1);
    }

    unsigned long Display::CreateAtom(const char* name)
    {
        return XInternAtom((::Display*)(m_display), name, 0);
    }

    const std::string Display::GetAtomName(unsigned long atom)
    {
        char* data = XGetAtomName((::Display*)(m_display), atom);
        std::string name(data);
        XFree(data);
        return name; 
    }

    int Display::NextEvent(Event& event)
    {
        return XNextEvent((::Display*)(m_display), reinterpret_cast<XEvent*>(&event));
    }

    int Display::Pending()
    {
        return XPending((::Display*)(m_display));
    }

    int Display::ProcessEvent(std::function< eventHandler(int)> filterType, int& result)
    {
        int more = Pending();
        if(more > 0)
        {            
            Event event;
            int status = NextEvent(event);

            eventHandler evt = filterType(event.type);
            if(evt)
            {
                result = evt(event);
            }     
        }
        return more;
    }

    int Display::LookupKeySymbol(KeyEvent& keyEvent, int index)
    {        
        return XLookupKeysym(reinterpret_cast<XKeyEvent*>(&keyEvent), index);
    }

    int Display::WarpPointer(unsigned long src_w, unsigned long dest_w, int src_x, int src_y, unsigned int src_width, unsigned int src_height, int dest_x, int dest_y)
    {
        return XWarpPointer((::Display*)(m_display), src_w, dest_w, src_x, src_y, src_width, src_height, dest_x, dest_y);
    }

    int Display::InstallColourmap(unsigned long colourmap)
    {
        return XInstallColormap((::Display*)(m_display), colourmap);
    }

    int Display::UninstallColourmap(unsigned long colourmap)
    {
        return XUninstallColormap((::Display*)(m_display), colourmap);
    }

    int Display::TranslateCoordinates(unsigned long src_w, unsigned long dest_w, int src_x, int src_y, int& dest_x_return, int& dest_y_return, unsigned long& child_return)
    {
        return XTranslateCoordinates((::Display*)(m_display), src_w, dest_w, src_x, src_y, &dest_x_return, &dest_y_return, &child_return);
    }

    int Display::Sync(bool discard)
    {
        return XSync((::Display*)(m_display), discard ? 1 : 0);
    }

    int Display::StoreBytes(const char* bytes, int nbytes)
    {
        return XStoreBytes((::Display*)(m_display), bytes, nbytes);
    }

    int Display::StoreBuffer(const char* bytes, int nbytes, int buffer)
    {
        return XStoreBuffer((::Display*)(m_display), bytes, nbytes, buffer);
    }

    int Display::GetPointerMapping(std::vector<unsigned char>& buttons)
    {
        return XGetPointerMapping((::Display*)(m_display), buttons.data(), buttons.size());
    }

    int Display::SetPointerMapping(const std::vector<unsigned char>& buttons)
    {
        return XSetPointerMapping((::Display*)(m_display), buttons.data(), buttons.size());
    }

    int Display::SetModifierMapping(ModifierKeymap& modmap)
    {
        return XSetModifierMapping((::Display*)(m_display), reinterpret_cast<XModifierKeymap*>(&modmap));
    }

    int Display::SetInputFocus(unsigned long focus, int revert_to, unsigned long time)
    {
        return XSetInputFocus((::Display*)(m_display), (::Window)(focus), revert_to, (::Time)time);
    }

    int Display::SetFontPath(std::vector<std::string> directories)
    {
        char* pathArray[directories.size()];
        int index = 0;
        for(auto str : directories)
        {
            pathArray[index++] = str.data();
        }
        return XSetFontPath((::Display*)(m_display), pathArray, directories.size());
    }

    int Display::SetAccessControl(int mode)
    {
        return XSetAccessControl((::Display*)(m_display), mode);
    }

    int Display::SendEvent(unsigned long w, int propagate, long eventMask, Event& event)
    {
        return XSendEvent((::Display*)(m_display), w, propagate, eventMask, reinterpret_cast<XEvent*>(&event));
    }

    int Display::RotateBuffers(int rotate)
    {
        return XRotateBuffers((::Display*)(m_display), rotate);
    }

    int Display::RestackWindows(std::vector<unsigned int>& windows)
    {
        return XRestackWindows((::Display*)(m_display), (::Window*)(windows.data()), windows.size());
    }

    Pixmap Display::ReadBitmapFile(unsigned long drawableId, const std::string& filename, unsigned int& widthReturn, unsigned int& heightReturn, int& xHotReturn, int& yHotReturn, int& result)
    {        
        unsigned long pixmapId = 0;
        result = XReadBitmapFile((::Display*)(m_display), drawableId, filename.data(), &widthReturn, &heightReturn, &pixmapId, &xHotReturn, &yHotReturn);
        return Pixmap(this, pixmapId, false);
    }

    int Display::QueryTextExtents16(unsigned long fontId, const Char2b* sz16, int charCount, int& directionReturn, int& fontAscentReturn, int& fontDescentReturn, CharStruct& overallReturn)
    {
        return XQueryTextExtents16((::Display*)(m_display), fontId, (XChar2b*)(sz16), charCount, &directionReturn, &fontAscentReturn, &fontDescentReturn, reinterpret_cast<XCharStruct*>(&overallReturn));
    }

    int Display::QueryTextExtents(unsigned long fontId, const std::string& str, int& directionReturn, int& fontAscentReturn, int& fontDescentReturn, CharStruct& overallReturn)
    {
        return XQueryTextExtents((::Display*)(m_display), fontId, str.c_str(), str.size(), &directionReturn, &fontAscentReturn, &fontDescentReturn, reinterpret_cast<XCharStruct*>(&overallReturn));
    }

    int Display::QueryKeymap(std::vector<char>& keysReturn)
    {
        keysReturn.resize(32);
        return XQueryKeymap((::Display*)(m_display), keysReturn.data());
    }

    Font Display::QueryFont(unsigned long fontId)// XFreeFontInfo
    {
        FontStruct* fontinfo;
        fontinfo = reinterpret_cast<FontStruct*>(XQueryFont((::Display*)(m_display), fontId));
        return Font(this, fontinfo);
    }

    int Display::QueryExtension(const std::string& name, int& majorOpcodeReturn, int& firstEventReturn, int& firstErrorReturn)
    {
        return XQueryExtension((::Display*)(m_display), name.c_str(), &majorOpcodeReturn, &firstEventReturn, &firstErrorReturn);
    }

    int Display::QueryColours(unsigned long colourmap, std::vector<Colour>& colours)
    {
        return XQueryColors((::Display*)(m_display), (::Colormap)(colourmap), reinterpret_cast<XColor*>(colours.data()), colours.size());
    }

    int Display::QueryColour(unsigned long colourmap, Colour& colour)
    {
        return XQueryColor((::Display*)(m_display), (::Colormap)(colourmap), reinterpret_cast<XColor*>(&colour));
    }

    int Display::QueryBestTile(unsigned long whichScreen, unsigned int width, unsigned int height, unsigned int& widthReturn, unsigned int& heightReturn)
    {
        return XQueryBestTile((::Display*)(m_display), whichScreen, width, height, &widthReturn, &heightReturn);
    }

    int Display::QueryBestStipple(unsigned long whichScreen, unsigned int width, unsigned int height, unsigned int&widthReturn, unsigned int& heightReturn)
    {
        return XQueryBestStipple((::Display*)(m_display), whichScreen, width, height, &widthReturn, &heightReturn);
    }

    int Display::QueryBestSize(int ofWhat, unsigned long whichScreen, unsigned int width, unsigned int height, unsigned int& widthReturn, unsigned int& heightReturn)
    {
        return XQueryBestSize((::Display*)(m_display), ofWhat, whichScreen, width, height, &widthReturn, &heightReturn);
    }

    int Display::QueryBestCursor(unsigned long whichScreen, unsigned int width, unsigned int height, unsigned int& widthReturn, unsigned int& heightReturn)
    {
        return XQueryBestCursor((::Display*)(m_display), whichScreen, width, height, &widthReturn, &heightReturn);
    }

    Font Display::LoadQueryFont(const std::string& name)
    {
        return Font(this, reinterpret_cast<FontStruct*>(XLoadQueryFont((::Display*)(m_display), name.c_str())));
    }

    Font Display::LoadFont(const std::string& name)
    {
        return Font(this, XLoadFont((::Display*)(m_display), name.c_str()));
    }

    FontInfoHolder Display::ListFontsWithInfo(const std::string& pattern, int maxNames, std::vector<std::string>& names)
    {                        
        XFontStruct* fontInfo = nullptr;
        int count = 0;
        char** data = XListFontsWithInfo((::Display*)(m_display), pattern.c_str(), maxNames, &count, &fontInfo);
        FontInfoHolder holder(reinterpret_cast<FontStruct*>(&fontInfo[0]), count);
        if(count != 0 && data != nullptr)
        {
            holder.vecFonts.clear();
            names.clear();
            holder.vecFonts.reserve(count);            
            names.reserve(count);
            for(unsigned int index = 0; index < count; ++index)
            {
                std::string name(data[index]);
                names.emplace_back(name);
                Font font(this, reinterpret_cast<FontStruct*>(&fontInfo[index]), true);
                holder.vecFonts.emplace_back(font);
            }
            XFreeFontNames(data);
        }
        return holder;
    }

    std::vector<std::string> Display::ListFonts(const std::string& pattern, int maxNames)
    {
        std::vector<std::string> names;
        int count = 0;
        char** data = XListFonts((::Display*)(m_display), pattern.c_str(), maxNames, &count);
        if(count != 0 && data != nullptr)
        {
            names.reserve(count);
            for(unsigned index = 0; index < count; ++index)
            {
                std::string name(data[index]);
                names.emplace_back(name);
            }
            XFreeFontNames(data);
        }
        return names;
    }

    std::vector<std::string> Display::ListExtensions()
    {
        std::vector<std::string> extensions;
        int count = 0;
        char** data = XListExtensions((::Display*)(m_display), &count);
        if( count != 0 && data != nullptr)
        {
            extensions.reserve(count);
            for(unsigned index = 0; index < count; ++index)
            {
                std::string extension(data[index]);
                extensions.emplace_back(extension);
            }
            XFreeExtensionList(data);
        }
        return extensions;
    }
    
    unsigned long Display::GetSelectionOwner(unsigned long selection)
    {
        return XGetSelectionOwner((::Display*)(m_display), (::Atom)(selection));
    }

    int Display::GetPointerControl(int& accel_numerator_return, int& accel_denominator_return, int& threshold_return)
    {
        return XGetPointerControl((::Display*)(m_display), &accel_numerator_return, &accel_denominator_return, &threshold_return);
    }

    ModifierKeymapHolder Display::GetModifierMapping()
    {                
        XModifierKeymap* data = XGetModifierMapping((::Display*)(m_display));
        if( data != nullptr)
        {
            ModifierKeymapHolder holder(reinterpret_cast<ModifierKeymap*>(data));
            XFree(data);
            return holder;
        }
        return ModifierKeymapHolder();
    }

    KeyboardMappingHolder Display::GetKeyboardMapping(unsigned char firstKeycode, int keycodeCount, int& keysymsPerKeycodeReturn)
    {
        KeySym* data = XGetKeyboardMapping((::Display*)(m_display), firstKeycode, keycodeCount, &keysymsPerKeycodeReturn);
        if( data != nullptr && keysymsPerKeycodeReturn != 0)
        {
            KeyboardMappingHolder holder(reinterpret_cast<unsigned long*>(data), keycodeCount * keysymsPerKeycodeReturn, keysymsPerKeycodeReturn);
            XFree(data);
            return holder;
        }
        return KeyboardMappingHolder();
    }

    int Display::GetKeyboardControl(KeyboardState& keyboardState)
    {
        return XGetKeyboardControl((::Display*)(m_display), reinterpret_cast<XKeyboardState*>(&keyboardState));
    }

    int Display::GetInputFocus(unsigned long& focusReturn, int revertToReturn)
    {
        return XGetInputFocus((::Display*)(m_display), &focusReturn, &revertToReturn);
    }

    Image Display::GetImage(unsigned long drawableId, int x, int y, unsigned int width, unsigned int height, unsigned long planeMask, int format)
    {
        XImage* image = XGetImage((::Display*)(m_display), drawableId, x, y, width, height, planeMask, format);
        return Image(this, image);
    }

    int Display::GetGeometry(unsigned long drawableId, unsigned long& rootReturn, int& xReturn, int& yReturn, unsigned int& widthReturn, unsigned int& heightReturn, unsigned int& borderWidthReturn, unsigned int& depthReturn)
    {
        return XGetGeometry((::Display*)(m_display), (::Drawable)(drawableId), &rootReturn, &xReturn, &yReturn, &widthReturn, &heightReturn, &borderWidthReturn, &depthReturn);
    }

    std::vector<std::string> Display::GetFontPath()
    {
        std::vector<std::string> path;
        int count = 0;
        char** data = XGetFontPath((::Display*)(m_display), &count);
        if(count != 0)
        {
            path.resize(count);
            for(unsigned int index = 0; index < count; ++index)
            {
                std::string folder(data[index]);
                path.emplace_back(folder);
            }
            XFree(data);
        }
        return path;
    }

    std::vector<char> Display::FetchBytes()
    {
        std::vector<char> bytes;
        int count = 0;
        char* data = XFetchBytes((::Display*)(m_display), &count);
        if(data != nullptr && count != 0)
        {
            bytes.resize(count);
            memcpy(bytes.data(), data, count);
            XFree(data);
        }
        return bytes;
    }

    int Display::EnableAccessControl()
    {
        return XEnableAccessControl((::Display*)(m_display));
    }

    int Display::DisableAccessControl()
    {
        return XDisableAccessControl((::Display*)(m_display));
    }

    int Display::ConvertSelection(unsigned long selection, unsigned long target, unsigned long property, unsigned long requestor, unsigned long time)
    {
        return XConvertSelection((::Display*)(m_display), selection, target, property, requestor, time);
    }

    int Display::ChangePointerControl(int do_accel, int do_threshold, int accel_numerator, int accel_denominator, int threshold)
    {
        return XChangePointerControl((::Display*)(m_display), do_accel, do_threshold, accel_numerator, accel_denominator, threshold);
    }

    int Display::ChangeKeyboardMapping(int firstKeycode, int keySymsPerKeycode, std::vector<unsigned long>& keySyms)
    {
        return XChangeKeyboardMapping((::Display*)(m_display), firstKeycode, keySymsPerKeycode, reinterpret_cast<::KeySym*>(keySyms.data()), keySyms.size());
    }

    int Display::ChangeActivePointerGrab(unsigned int eventMask, unsigned long cursor, unsigned long time)
    {
        return XChangeActivePointerGrab((::Display*)(m_display), eventMask, cursor, time);
    }

    int Display::Bell(int percent)
    {
        return XBell((::Display*)(m_display), percent);
    }

    int Display::AutoRepeatOn()
    {
        return XAutoRepeatOn((::Display*)(m_display));
    }

    int Display::AutoRepeatOff()
    {
        return XAutoRepeatOff((::Display*)(m_display));
    }

    int Display::AllowEvents(int eventMode, unsigned long time)
    {
        return XAllowEvents((::Display*)(m_display), eventMode, time);
    }

    int Display::IfEvent(Event& event, int(predicate)(void*, Event*, char*), void* arg)
    {
        return XIfEvent((::Display*)(m_display), reinterpret_cast<XEvent*>(&event), reinterpret_cast<eventPred*>(predicate), reinterpret_cast<XPointer>(arg));
    }

    int Display::CheckMaskEvent(long mask, Event& event)
    {
        return XCheckMaskEvent((::Display*)(m_display), mask, reinterpret_cast<XEvent*>(&event));
    }

}}}}//qor::platform::nslinux::x