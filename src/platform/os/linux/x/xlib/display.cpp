// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"
#include "src/qor/error/error.h"

#include "display.h"
#include "gc.h"
#include "screen.h"
#include "window.h"
#include "visual.h"
#include "pixmap.h"

#include <X11/Xlib.h>
#include <X11/X.h>
#include <X11/Xcms.h>
#include <X11/Xutil.h>
#include <X11/Xresource.h>
#include <X11/Xatom.h>
#include <X11/cursorfont.h>
#include <X11/keysymdef.h>
#include <X11/keysym.h>
#include <X11/Xlibint.h>
#include <X11/Xproto.h>
#include <X11/Xprotostr.h>

#undef BlackPixel
#undef WhitePixel
#undef DefaultScreen
#undef ConnectionNumber
#undef DefaultDepth
#undef DefaultGC
#undef DefaultRootWindow
#undef DefaultScreenOfDisplay
#undef ScreenOfDisplay
#undef DefaultVisual
#undef DisplayCells
#undef DisplayPlanes
#undef DisplayString
#undef LastKnownRequestProcessed
#undef NextRequest
#undef ProtocolVersion
#undef ProtocolRevision
#undef QLength
#undef RootWindow
#undef ScreenCount
#undef ServerVendor
#undef VendorRelease
#undef ImageByteOrder
#undef BitmapUnit
#undef BitmapBitOrder
#undef BitmapPad

namespace qor{ namespace platform { namespace nslinux{ namespace x{

    Display::Display(const std::string& protocol, const std::string& hostname, int display_number, int screen_number) : temporary(false)
    {
        std::string name;
        if(!protocol.empty())
        {
            name = std::format("{0}/{1}:{2}.{3}", protocol, hostname, display_number, screen_number);
        }
        else if(!hostname.empty())
        {
            name = std::format("{0}:{1}.{2}", hostname, display_number, screen_number);
        }
        else
        {
            name = std::format(":{0}.{1}", display_number, screen_number);
        }
        m_display = XOpenDisplay(name.c_str());
        if(m_display == nullptr)
        {
            continuable("Failed to open X Server {0}", name);
        }
    }

    Display::Display(const char* name) : temporary(false)
    {
        m_display = XOpenDisplay(name);
    }

    Display::Display(void* display) : temporary(true)
    {
        m_display = display;
    }

    Display::~Display()
    {
        if(m_display && !temporary)
        {
           XCloseDisplay((::Display*)(m_display));
        }
    }

    void* Display::Use()
    {
        return m_display;
    }

    int Display::DefaultScreen()
    {
        return XDefaultScreen((::Display*)(m_display));
    }

    unsigned long Display::BlackPixel()
    {
        return BlackPixel(DefaultScreen());
    }

    unsigned long Display::BlackPixel(int screen_number)
    {
        return XBlackPixel((::Display*)(m_display), screen_number);
    }

    unsigned long Display::WhitePixel()
    {
        return WhitePixel(DefaultScreen());
    }

    unsigned long Display::WhitePixel(int screen_number)
    {
        return XWhitePixel((::Display*)(m_display), screen_number);
    }

    int Display::ConnectionNumber()
    {
        return XConnectionNumber((::Display*)(m_display));
    }

    int Display::DefaultDepth()
    {
        return DefaultDepth(DefaultScreen());
    }

    int Display::DefaultDepth(int screen_number)
    {
        return XDefaultDepth((::Display*)(m_display), screen_number);
    }

    unsigned long Display::DefaultColourmap()
    {
        return DefaultColourmap(DefaultScreen());
    }

    unsigned long Display::DefaultColourmap(int screen_number)
    {
        return XDefaultColormap((::Display*)(m_display), screen_number);
    }

    const std::vector<int> Display::ListDepths()
    {
        return ListDepths(DefaultScreen());
    }

    const std::vector<int> Display::ListDepths(int screen_number)
    {
        std::vector<int> result;
        int count = 0;
        int* depths = XListDepths((::Display*)(m_display), screen_number, &count);
        if(depths != nullptr)
        {
            result.resize(count);
            memcpy(result.data(), depths, count);
            XFree(depths);
        }
        return result;
    }
    
    GC Display::DefaultGC()
    {
        return DefaultGC(DefaultScreen());
    }

    GC Display::DefaultGC(int screen_number)
    {
        return GC(this, XDefaultGC((::Display*)(m_display), screen_number));
    }

    Window Display::DefaultRootWindow()
    {
        return Window(XDefaultRootWindow((::Display*)(m_display)), this);
    }

    Screen Display::DefaultScreenOfDisplay()
    {
        return Screen(XDefaultScreenOfDisplay((::Display*)(m_display)), this);
    }

    Screen Display::ScreenOfDisplay(int screen_number)
    {
        return Screen(XScreenOfDisplay((::Display*)(m_display), screen_number), this);
    }

    Visual Display::DefaultVisual()
    {
        return XDefaultVisual((::Display*)(m_display), DefaultScreen());
    }

    Visual Display::DefaultVisual(int screen_number)
    {
        return XDefaultVisual((::Display*)(m_display), screen_number);
    }

    int Display::DisplayCells()//entries in colour map
    {
        return XDisplayCells((::Display*)(m_display), DefaultScreen());
    }

    int Display::DisplayCells(int screen_number)//entries in colour map
    {
        return XDisplayCells((::Display*)(m_display), screen_number);
    }

    int Display::DisplayPlanes()
    {
        return XDisplayPlanes((::Display*)(m_display), DefaultScreen());
    }

    int Display::DisplayPlanes(int screen_number)
    {
        return XDisplayPlanes((::Display*)(m_display), screen_number);
    }

    const std::string Display::DisplayString()
    {
        char* szdisplay = XDisplayString((::Display*)(m_display));
        std::string display(szdisplay);
        //XFree(szdisplay);//Don't free this gets freed as part of XCloseDisplay
        return display;
    }

    long Display::MaxRequestSize()
    {
        return XMaxRequestSize((::Display*)(m_display));
    }

    unsigned long Display::LastKnownRequestProcessed()
    {
        return XLastKnownRequestProcessed((::Display*)(m_display));
    }

    unsigned long Display::NextRequest()
    {
        return XNextRequest((::Display*)(m_display));
    }

    int Display::ProtocolVersion()
    {
        return XProtocolVersion((::Display*)(m_display));
    }

    int Display::ProtocolRevision()
    {
        return XProtocolRevision((::Display*)(m_display));
    }

    int Display::QLength()
    {   
        return XQLength((::Display*)(m_display));
    }

    Window Display::RootWindow()
    {
        return Window(XRootWindow((::Display*)(m_display), DefaultScreen()), this);
    }

    Window Display::RootWindow(int screen_number)
    {
        return Window(XRootWindow((::Display*)(m_display), screen_number), this);
    }

    int Display::ScreenCount()
    {
        return XScreenCount((::Display*)(m_display));
    }

    const std::string Display::ServerVendor()
    {
        char* szvendor = XServerVendor((::Display*)(m_display));
        std::string serverVendor(szvendor);
        //XFree(szvendor);//Don't free this gets freed as part of XCloseDisplay
        return serverVendor;
    }

    const int Display::VendorRelease()
    {
        return XVendorRelease((::Display*)(m_display));
    }

    int Display::ImageByteOrder()// LSBFirst or MSBFirst
    {
        return XImageByteOrder((::Display*)(m_display));        
    }

    int Display::BitmapUnit()//scan line length in bits
    {
        return XBitmapUnit((::Display*)(m_display));
    }

    int Display::BitmapBitOrder()//LSBFirst or MSBFirst
    {
        return XBitmapBitOrder((::Display*)(m_display));
    }

    int Display::BitmapPad()//scan line modulus/padding in bits
    {
        return XBitmapPad((::Display*)(m_display));
    }

    int Display::Height()//pixels
    {
        return XDisplayHeight((::Display*)(m_display), DefaultScreen());
    }

    int Display::HeightMM()
    {
        return XDisplayHeightMM((::Display*)(m_display), DefaultScreen());
    }

    int Display::Width()//pixels
    {
        return XDisplayWidth((::Display*)(m_display), DefaultScreen());
    }

    int Display::WidthMM()
    {
        return XDisplayWidthMM((::Display*)(m_display), DefaultScreen());
    }

    int Display::Height(int screen_number)//pixels
    {
        return XDisplayHeight((::Display*)(m_display), screen_number);
    }

    int Display::HeightMM(int screen_number)
    {
        return XDisplayHeightMM((::Display*)(m_display), screen_number);
    }

    int Display::Width(int screen_number)//pixels
    {
        return XDisplayWidth((::Display*)(m_display), screen_number);
    }

    int Display::WidthMM(int screen_number)
    {
        return XDisplayWidthMM((::Display*)(m_display), screen_number);
    }

    int Display::NoOp()
    {
        return XNoOp((::Display*)(m_display));
    }

    int Display::SetCloseDownMode(int close_mode)
    {
        return XSetCloseDownMode((::Display*)(m_display), close_mode);
    }

    const std::vector<PixmapFormatValue> Display::ListPixmapFormats()
    {
        std::vector<PixmapFormatValue> result;
        int count = 0;
        PixmapFormatValue* formats = reinterpret_cast<PixmapFormatValue*>(XListPixmapFormats((::Display*)(m_display), &count));
        if(count != 0 && formats != nullptr)
        {
            result.resize(count);
            memcpy(result.data(), formats, sizeof(PixmapFormatValue) * count);
            XFree(formats);
        }
        return result;
    }

    void Display::Lock()
    {
        XLockDisplay((::Display*)(m_display));
    }
    
    void Display::Unlock()
    {
        XUnlockDisplay((::Display*)(m_display));
    }

    Pixmap Display::GetPixmap(unsigned long drawableId, unsigned int width, unsigned int height, unsigned int depth)
    {
        Pixmap p(this, drawableId, width, height, depth);
        return p;
    }

    std::vector<VisualInfo> Display::GetVisualInfo(long vinfo_mask, VisualInfo& vinfo_template)
    {
        std::vector<VisualInfo> result;
        int count = 0;
        XVisualInfo* info = XGetVisualInfo((::Display*)(m_display), vinfo_mask, reinterpret_cast<::XVisualInfo*>(&vinfo_template), &count);
        if(info != nullptr && count != 0)
        {
            result.resize(count);
            memcpy(result.data(), info, sizeof(XVisualInfo) * count);
            XFree(info);
        }
        return result;
    }

    std::vector<VisualInfo> Display::GetVisualInfo(VisualInfoQuery& visualInfoQuery)
    {
        return GetVisualInfo(visualInfoQuery.Mask(), visualInfoQuery.Info());
    }

    int Display::Flush()
    {
        return XFlush((::Display*)(m_display));
    }

    unsigned long Display::GetAtom(const char* name)
    {
        return XInternAtom((::Display*)(m_display), name, 1);
    }

    unsigned long Display::CreateAtom(char* name)
    {
        return XInternAtom((::Display*)(m_display), name, 0);
    }

    const std::string Display::GetAtomName(unsigned long atom)
    {
        char* data = XGetAtomName((::Display*)(m_display), atom);
        std::string name(data);
        XFree(data);
        return name; 
    }

    int Display::NextEvent(Event& event)
    {
        return XNextEvent((::Display*)(m_display), reinterpret_cast<XEvent*>(&event));
    }

    int Display::Pending()
    {
        return XPending((::Display*)(m_display));
    }

    int Display::ProcessEvent(std::function< eventHandler(int)> filterType, int& result)
    {
        int more = Pending();
        if(more > 0)
        {            
            Event event;
            int status = NextEvent(event);

            eventHandler evt = filterType(event.type);
            if(evt)
            {
                result = evt(event);
            }     
        }
        return more;
    }

    int Display::LookupKeySymbol(KeyEvent& keyEvent, int index)
    {        
        return XLookupKeysym(reinterpret_cast<XKeyEvent*>(&keyEvent), index);
    }

    int Display::WarpPointer(unsigned long src_w, unsigned long dest_w, int src_x, int src_y, unsigned int src_width, unsigned int src_height, int dest_x, int dest_y)
    {
        return XWarpPointer((::Display*)(m_display), src_w, dest_w, src_x, src_y, src_width, src_height, dest_x, dest_y);
    }

    int Display::InstallColourmap(unsigned long colourmap)
    {
        return XInstallColormap((::Display*)(m_display), colourmap);
    }

    int Display::UninstallColourmap(unsigned long colourmap)
    {
        return XUninstallColormap((::Display*)(m_display), colourmap);
    }

    int Display::TranslateCoordinates(unsigned long src_w, unsigned long dest_w, int src_x, int src_y, int& dest_x_return, int& dest_y_return, unsigned long& child_return)
    {
        return XTranslateCoordinates((::Display*)(m_display), src_w, dest_w, src_x, src_y, &dest_x_return, &dest_y_return, &child_return);
    }

    int Display::Sync(bool discard)
    {
        return XSync((::Display*)(m_display), discard ? 1 : 0);
    }

    int Display::StoreBytes(const char* bytes, int nbytes)
    {
        return XStoreBytes((::Display*)(m_display), bytes, nbytes);
    }

    int Display::StoreBuffer(const char* bytes, int nbytes, int buffer)
    {
        return XStoreBuffer((::Display*)(m_display), bytes, nbytes, buffer);
    }

    int Display::GetPointerMapping(std::vector<unsigned char>& buttons)
    {
        return XGetPointerMapping((::Display*)(m_display), buttons.data(), buttons.size());
    }

    int Display::SetPointerMapping(const std::vector<unsigned char>& buttons)
    {
        return XSetPointerMapping((::Display*)(m_display), buttons.data(), buttons.size());
    }

    int Display::SetModifierMapping(ModifierKeymap& modmap)
    {
        return XSetModifierMapping((::Display*)(m_display), reinterpret_cast<XModifierKeymap*>(&modmap));
    }

    int Display::SetInputFocus(unsigned long focus, int revert_to, unsigned long time)
    {
        return XSetInputFocus((::Display*)(m_display), (::Window)(focus), revert_to, (::Time)time);
    }
    
}}}}//qor::platform::nslinux::x