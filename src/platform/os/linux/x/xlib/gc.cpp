// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include "gc.h"
#include "display.h"
#include "window.h"

#include <X11/Xlib.h>
#include <X11/X.h>
#include <X11/Xcms.h>
#include <X11/Xutil.h>
#include <X11/Xresource.h>
#include <X11/Xatom.h>
#include <X11/cursorfont.h>
#include <X11/keysymdef.h>
#include <X11/keysym.h>
#include <X11/Xlibint.h>
#include <X11/Xproto.h>
#include <X11/Xprotostr.h>

namespace qor{ namespace platform { namespace nslinux{ namespace x{

    GC::GC(Display* display, Window* window, void* gc) : m_display(display), m_window(window), m_gc(gc), m_temporary(false)
    {
    }

    GC::GC(Display* display, void* gc) : m_display(display), m_window(nullptr), m_gc(gc), m_temporary(true)
    {        
    }

    GC::~GC()
    {
        if(!m_temporary)
        {
            XFreeGC((::Display*)(m_display),(::GC)(m_gc));
        }
    }

    void* GC::Use()
    {
        return m_gc;
    }

    unsigned long GC::GetID()
    {
        return XGContextFromGC((::GC)(m_gc));
    }

    void GC::Flush()
    {
        XFlushGC((::Display*)(m_display),(::GC)(m_gc));
    }

    int GC::Copy(GC& dest, unsigned long valuemask)
    {
        return XCopyGC((::Display*)(m_display), (::GC)(m_gc), valuemask, (::GC)(dest.Use()));
    }

    int GC::Change(unsigned long valueMask, GCValues& values)
    {
        return XChangeGC((::Display*)(m_display), (::GC)(m_gc), valueMask, reinterpret_cast<XGCValues*>(&values));
    }

    int GC::GetValues(unsigned long valueMask, GCValues& valuesReturn)
    {
        return XGetGCValues((::Display*)(m_display), (::GC)(m_gc), valueMask, reinterpret_cast<XGCValues*>(&valuesReturn));
    }

    int GC::SetState(unsigned long foreground, unsigned long background, int function, unsigned long plane_mask)
    {
        return XSetState((::Display*)(m_display), (::GC)(m_gc), foreground, background, function, plane_mask);        
    }

    int GC::SetForeground(unsigned long foreground)
    {
        return XSetForeground((::Display*)(m_display), (::GC)(m_gc), foreground);
    }

    int GC::SetBackground(unsigned long background)
    {
        return XSetBackground((::Display*)(m_display), (::GC)(m_gc), background);
    }

    int GC::SetFunction(int function)
    {
        return XSetFunction((::Display*)(m_display), (::GC)(m_gc), function);
    }

    int GC::SetPlaneMask(unsigned long plane_mask)
    {
        return XSetPlaneMask((::Display*)(m_display), (::GC)(m_gc), plane_mask);
    }

    int GC::SetLineAttributes(unsigned int line_width, int line_style, int cap_style, int join_style)
    {
        return XSetLineAttributes((::Display*)(m_display), (::GC)(m_gc), line_width, line_style, cap_style, join_style);
    }

    int GC::SetDashes(int dash_offset, const char* dash_list, int n)
    {
        return XSetDashes((::Display*)(m_display), (::GC)(m_gc), dash_offset, dash_list, n);
    }

    int GC::SetFillStyle(int fill_style)
    {
        return XSetFillStyle((::Display*)(m_display), (::GC)(m_gc), fill_style);
    }

    int GC::SetFillRule(int fill_rule)
    {
        return XSetFillRule((::Display*)(m_display), (::GC)(m_gc), fill_rule);
    }

    int GC::SetTile(Pixmap& tile)
    {
        return XSetTile((::Display*)(m_display), (::GC)(m_gc), tile.GetId());
    }

    int GC::SetStipple(Pixmap& stipple)
    {
        return XSetStipple((::Display*)(m_display), (::GC)(m_gc), stipple.GetId());
    }

    int GC::SetTSOrigin(int ts_x_origin, int ts_y_origin)
    {
        return XSetTSOrigin((::Display*)(m_display), (::GC)(m_gc), ts_x_origin, ts_y_origin);
    }

    int GC::SetFont(unsigned long font)
    {
        return XSetFont((::Display*)(m_display), (::GC)(m_gc), font);
    }

    int GC::SetClipOrigin(int clip_x_origin, int clip_y_origin)
    {
        return XSetClipOrigin((::Display*)(m_display), (::GC)(m_gc), clip_x_origin, clip_y_origin);
    }

    int GC::SetClipMask(Pixmap& pixmap)
    {
        return XSetClipMask((::Display*)(m_display), (::GC)(m_gc), pixmap.GetId());
    }

    int GC::SetClipRectangles(int clip_x_origin, int clip_y_origin, Rectangle rectangles[], int n, int ordering)
    {
        return XSetClipRectangles((::Display*)(m_display), (::GC)(m_gc), clip_x_origin, clip_y_origin, reinterpret_cast<XRectangle*>(rectangles), n, ordering);
    }

    int GC::SetArcMode(int arc_mode)
    {
        return XSetArcMode((::Display*)(m_display), (::GC)(m_gc), arc_mode);
    }

    int GC::SetSubWindowMode(int subwindow_mode)
    {
        return XSetSubwindowMode((::Display*)(m_display), (::GC)(m_gc), subwindow_mode);
    }
    
    int GC::SetGraphicsExposures(int graphics_exposures)
    {
        return XSetGraphicsExposures((::Display*)(m_display), (::GC)(m_gc), graphics_exposures);
    }

    int GC::PutImage(unsigned long drawableTarget, void* image, int srcX, int srcY, int destX, int destY, unsigned int width, unsigned int height)
    {
        return XPutImage((::Display*)(m_display), (::Drawable)(drawableTarget), (::GC)(m_gc), reinterpret_cast<XImage*>(image), srcX, srcY, destX, destY, width, height);
    }

    int GC::FillRectangles(unsigned long drawableTarget, std::vector<Rectangle>& rectangles)
    {
        return XFillRectangles((::Display*)(m_display), drawableTarget, (::GC)(m_gc), reinterpret_cast<XRectangle*>(rectangles.data()), static_cast<int>(rectangles.size()));
    }

    int GC::FillRectangle(unsigned long drawableTarget, int x, int y, unsigned int width, unsigned int height)
    {
        return XFillRectangle((::Display*)(m_display), drawableTarget, (::GC)(m_gc), x, y, width, height);
    }

    int GC::FillPolygon(unsigned long drawableTarget, std::vector<Point> points, int shape, int mode)
    {
        return XFillPolygon((::Display*)(m_display), drawableTarget, (::GC)(m_gc), reinterpret_cast<XPoint*>(points.data()), points.size(), shape, mode);
    }

    int GC::FillArcs(unsigned long drawableTarget, std::vector<Arc>& arcs)
    {
        return XFillArcs((::Display*)(m_display), drawableTarget, (::GC)(m_gc), reinterpret_cast<XArc*>(arcs.data()), arcs.size());
    }

    int GC::FillArc(unsigned long drawableTarget, Arc& src)
    {
        return XFillArc((::Display*)(m_display), drawableTarget, (::GC)(m_gc), src.x, src.y, src.width, src.height, src.angle1, src.angle2);
    }

    int GC::DrawText16(unsigned long drawableTarget, int x, int y, std::vector<TextItem16>& items)
    {
        return XDrawText16((::Display*)(m_display), drawableTarget, (::GC)(m_gc), x, y, reinterpret_cast<XTextItem16*>(items.data()), items.size());
    }

    int GC::DrawText(unsigned long drawableTarget, int x, int y, std::vector<TextItem>& items)
    {
        return XDrawText((::Display*)(m_display), drawableTarget,(::GC)(m_gc), x, y, reinterpret_cast<XTextItem*>(items.data()), items.size());
    }

    int GC::DrawString16(unsigned long drawableTarget, int x, int y, std::vector<Char2b>& str)
    {
        return XDrawString16((::Display*)(m_display), drawableTarget,(::GC)(m_gc), x, y, reinterpret_cast<const XChar2b*>(str.data()), str.size());
    }

    int GC::DrawString(unsigned long drawableTarget, int x, int y, std::string& str)
    {
        return XDrawString((::Display*)(m_display), drawableTarget, (::GC)(m_gc), x, y, str.c_str(), str.size());
    }

    int GC::DrawSegments(unsigned long drawableTarget, std::vector<Segment>& segments)
    {
        return XDrawSegments((::Display*)(m_display), drawableTarget, (::GC)(m_gc), reinterpret_cast<XSegment*>(segments.data()), segments.size());
    }

    int GC::DrawRectangles(unsigned long drawableTarget, std::vector<Rectangle>& rectangles)
    {
        return XDrawRectangles((::Display*)(m_display), drawableTarget, (::GC)(m_gc), reinterpret_cast<XRectangle*>(rectangles.data()), rectangles.size());
    }

    int GC::DrawRectangle(unsigned long drawableTarget, int x, int y, unsigned int width, unsigned int height)
    {
        return XDrawRectangle((::Display*)(m_display), drawableTarget, (::GC)(m_gc), x, y, width, height);
    }

    int GC::DrawPoint(unsigned long drawableTarget, int x, int y)
    {
        return XDrawPoint((::Display*)(m_display), drawableTarget, (::GC)(m_gc), x, y);
    }

    int GC::DrawPoints(unsigned long drawableTarget, std::vector<Point>& points, int mode)
    {
        return XDrawPoints((::Display*)(m_display), drawableTarget, (::GC)(m_gc), reinterpret_cast<XPoint*>(points.data()), points.size(), mode);
    }

    int GC::DrawLines(unsigned long drawableTarget, std::vector<Point>& points, int mode)
    {
        return XDrawLines((::Display*)(m_display), drawableTarget, (::GC)(m_gc), reinterpret_cast<XPoint*>(points.data()), points.size(), mode);
    }

    int GC::DrawLine(unsigned long drawableTarget, int x1, int y1, int x2, int y2)
    {
        return XDrawLine((::Display*)(m_display), drawableTarget, (::GC)(m_gc), x1, y1, x2, y2);
    }

    int GC::DrawImageString16(unsigned long drawableTarget, int x, int y, std::vector<Char2b>& str)
    {
        return XDrawImageString16((::Display*)(m_display), drawableTarget, (::GC)(m_gc), x, y, reinterpret_cast<const XChar2b *>(str.data()), str.size());
    }

    int GC::DrawImageString(unsigned long drawableTarget, int x, int y, std::string& str)
    {
        return XDrawImageString((::Display*)(m_display), drawableTarget, (::GC)(m_gc), x, y, str.c_str(), str.size());
    }

    int GC::DrawArcs(unsigned long drawableTarget, std::vector<Arc>& arcs)
    {
        return XDrawArcs((::Display*)(m_display), drawableTarget, (::GC)(m_gc), reinterpret_cast<XArc*>(arcs.data()), arcs.size());
    }

    int GC::DrawArc(unsigned long drawableTarget, int x, int y, unsigned int width, unsigned int height, int angle1, int angle2)
    {
        return XDrawArc((::Display*)(m_display), drawableTarget, (::GC)(m_gc), x, y, width, height, angle1, angle2);
    }

    int GC::CopyPlane(unsigned long src, unsigned long dest, int src_x, int src_y, unsigned int width, unsigned int height, int dest_x, int dest_y, unsigned long plane)
    {
        return XCopyPlane((::Display*)(m_display), src, dest, (::GC)(m_gc), src_x, src_y, width, height, dest_x, dest_y, plane);
    }

    int GC::CopyArea(unsigned long src, unsigned long dest, int src_x, int src_y, unsigned int width, unsigned int height, int dest_x, int dest_y)
    {
        return XCopyArea((::Display*)(m_display), src, dest, (::GC)(m_gc), src_x, src_y, width, height, dest_x, dest_y);
    }

}}}}//qor::platform::nslinux::x
