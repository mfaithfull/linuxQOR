// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include "window.h"
#include "display.h"
#include "visual.h"

#include <X11/Xlib.h>
#include <X11/X.h>
#include <X11/Xcms.h>
#include <X11/Xutil.h>
#include <X11/Xresource.h>
#include <X11/Xatom.h>
#include <X11/cursorfont.h>
#include <X11/keysymdef.h>
#include <X11/keysym.h>
#include <X11/Xlibint.h>
#include <X11/Xproto.h>
#include <X11/Xprotostr.h>

#define WITH_THIS (::Display*)(m_display->Use()), (::Window)(m_Id)

namespace qor{ namespace platform { namespace nslinux{ namespace x{

    Window::Window(unsigned long drawableId, Display* display) : Drawable(drawableId), m_display(display), temporary(true)
    {
    }
    
    Window::Window(Display* display, unsigned long parent, int x, int y, unsigned int width, unsigned int height, unsigned int border_width, unsigned long border, unsigned long background) : Drawable(0), m_display(display), temporary(false)
    {
        //XCreateSimpleWindow creates a window that inherits its attributes from its parent window.
        m_Id = XCreateSimpleWindow((::Display*)(m_display->Use()), (::Window)(parent), x, y, width, height, border_width, border, background);
    }

    Window::Window(Display* display, unsigned long parent, int x, int y, unsigned int width, unsigned int height, unsigned int border_width, int depth, unsigned int type, Visual* visual, unsigned long valuemask, SetWindowAttributes& attributes) : Drawable(0), m_display(display), temporary(false)
    {
        m_Id = XCreateWindow((::Display*)(m_display->Use()), (::Window)(parent), x, y, width, height, border_width, depth, type, (::Visual*)(visual->Use()), valuemask, reinterpret_cast<XSetWindowAttributes*>(&attributes));
    }

    qor::ref_of<Window>::type Window::CreateChildWindow(int x, int y, unsigned int width, unsigned int height, unsigned int border_width, unsigned long border, unsigned long background)
    {
        return new_ref<Window>(m_display, m_Id, x, y, width, height, border_width, border, background);
    }

    Window::~Window()
    {
        if(!temporary)
        {
            XDestroyWindow(WITH_THIS);
            m_Id = 0;
        }
    }

    int Window::Reparent(unsigned long parent, int x, int y)
    {
        return XReparentWindow(WITH_THIS, parent, x, y);
    }
    
    int Window::Raise()
    {
        return XRaiseWindow(WITH_THIS);
    }

    int Window::Lower()
    {
        return XLowerWindow(WITH_THIS);
    }

    int Window::Move(int x, int y)
    {
        return XMoveWindow(WITH_THIS, x, y);
    }

    int Window::Resize(unsigned int width, unsigned int height)
    {
        return XResizeWindow(WITH_THIS, width, height);
    }

    int Window::MoveResize(int x, int y, unsigned int width, unsigned int height)
    {
        return XMoveResizeWindow(WITH_THIS, x, y, width, height);
    }

    int Window::DestroySubwindows()
    {
        return XDestroySubwindows(WITH_THIS);
    }

    int Window::ChangeAttributes(unsigned long valuemask, SetWindowAttributes& attributes)
    {
        return XChangeWindowAttributes(WITH_THIS, valuemask, reinterpret_cast<XSetWindowAttributes*>(&attributes));
    }

    int Window::ChangeAttributes(SetWindowAttributesQuery& setAttributesQuery)
    {
        return ChangeAttributes(setAttributesQuery.Mask(), setAttributesQuery.Attributes());
    }

    int Window::Configure(unsigned long value_mask, WindowChanges& values)
    {
        return XConfigureWindow(WITH_THIS, value_mask, reinterpret_cast<XWindowChanges*>(&values));
    }

    int Window::Configure(WindowChangeQuery& windowChangeQuery)
    {
        return Configure(windowChangeQuery.Mask(), windowChangeQuery.Info());    
    }

    int Window::SetBorderWidth(int width)
    {
        return XSetWindowBorderWidth(WITH_THIS, width);
    }

    int Window::SetBackground(unsigned long background_pixel)
    {
        return XSetWindowBackground(WITH_THIS, background_pixel);
    }

    int Window::SetBackgroundPixmap(unsigned long background_pixmap)
    {
        return XSetWindowBackgroundPixmap(WITH_THIS, background_pixmap);
    }

    int Window::SetBorder(unsigned long border_pixel)
    {
        return XSetWindowBorder(WITH_THIS, border_pixel);
    }

    int Window::SetBorderPixmap(unsigned long border_pixmap)
    {
        return XSetWindowBorderPixmap(WITH_THIS, border_pixmap);
    }

    int Window::MapSubwindows()
    {
        return XMapSubwindows(WITH_THIS);
    }

    int Window::UnmapSubwindows()
    {
        return XUnmapSubwindows(WITH_THIS);
    }

    int Window::Map()
    {
        return XMapWindow(WITH_THIS);
    }

    int Window::MapRaised()
    {
        return XMapRaised(WITH_THIS);
    }

    int Window::Unmap()
    {
        return XUnmapWindow(WITH_THIS);
    }

    int Window::SetColourmap(unsigned long colormap)
    {
        return XSetWindowColormap(WITH_THIS, colormap);
    }

    int Window::CirculateSubwindows(int direction)
    {
        return XCirculateSubwindows(WITH_THIS, direction);
    }

    int Window::DefineCursor(unsigned long cursor)
    {
        return XDefineCursor(WITH_THIS, cursor);
    }

    int Window::UndefineCursor()
    {
        return XUndefineCursor(WITH_THIS);
    }

    int Window::Clear()
    {
        return XClearWindow(WITH_THIS);
    }

    int Window::ClearArea(int x, int y, unsigned width, unsigned height, int exposures)
    {
        return XClearArea(WITH_THIS, x, y, width, height, exposures);
    }

    /*The built-in property types are:
ARC	
PIXMAP
ATOM	
POINT
BITMAP	
RGB_COLOR_MAP
CARDINAL	
RECTANGLE
COLORMAP	
STRING
CURSOR	
VISUALID
DRAWABLE	
WINDOW
FONT	
WM_HINTS
INTEGER	
WM_SIZE_HINTS*/

/*The built-in property names are:

CUT_BUFFER0	RESOURCE_MANAGER
CUT_BUFFER1	WM_CLASS
CUT_BUFFER2	WM_CLIENT_MACHINE
CUT_BUFFER3	WM_COLORMAP_WINDOWS
CUT_BUFFER4	WM_COMMAND
CUT_BUFFER5	WM_HINTS
CUT_BUFFER6	WM_ICON_NAME
CUT_BUFFER7	WM_ICON_SIZE
RGB_BEST_MAP	WM_NAME
RGB_BLUE_MAP	WM_NORMAL_HINTS
RGB_DEFAULT_MAP	WM_PROTOCOLS
RGB_GRAY_MAP	WM_STATE
RGB_GREEN_MAP	WM_TRANSIENT_FOR
RGB_RED_MAP	WM_ZOOM_HINTS*/

    int Window::GetProperty(unsigned long property, long long_offset, long long_length, int del, unsigned long req_type, unsigned long* actual_type_return, int* actual_format_return, unsigned long* nitems_return, unsigned long* bytes_after_return, unsigned char** prop_return)
    {
        return XGetWindowProperty(WITH_THIS, property, long_offset, long_length, del, req_type, actual_type_return, actual_format_return, nitems_return, bytes_after_return, prop_return);        
    }

    std::vector<unsigned long> Window::ListProperties()
    {
        std::vector<unsigned long> properties;
        int numProperties = 0;
        unsigned long* data = XListProperties(WITH_THIS, &numProperties);
        if(data != nullptr && numProperties != 0)
        {
            properties.resize(numProperties);
            memcpy(properties.data(), data, sizeof(unsigned long) * numProperties);
            XFree(data);
        }
        return properties;
    }

    //mode = PropModeReplace, PropModePrepend, or PropModeAppend.
    //format appears to be bits per element
    int Window::ChangeProperty(unsigned long property, unsigned long type, int format, int mode, unsigned char* data, int nelements)
    {
        return XChangeProperty(WITH_THIS, property, type, format, mode, data, nelements);
    }
        
    WMHints Window::GetWMHints()
    {
        WMHints hints = {0};
        XWMHints* data = XGetWMHints(WITH_THIS);
        if(data != nullptr)
        {
            memcpy(&hints, data, sizeof(WMHints));
            XFree(data);
        }
        return hints;
    }

    int Window::SetWMHints(WMHints& hints)
    {
        XWMHints* data = XAllocWMHints();
        memcpy(data, &hints, sizeof(WMHints));
        int result = XSetWMHints(WITH_THIS, data);
        //XFree(data);//TODO:?
        return result;
    }
        



}}}}//qor::platform::nslinux::x

#undef WITH_THIS
