// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include "window.h"
#include "display.h"
#include "visual.h"
#include "gc.h"
#include "colourmap.h"

#include <X11/Xlib.h>
#include <X11/X.h>
#include <X11/Xcms.h>
#include <X11/Xutil.h>
#include <X11/Xresource.h>
#include <X11/Xatom.h>
#include <X11/cursorfont.h>
#include <X11/keysymdef.h>
#include <X11/keysym.h>
#include <X11/Xlibint.h>
#include <X11/Xproto.h>
#include <X11/Xprotostr.h>

#define WITH_THIS (::Display*)(m_display->Use()), (::Window)(m_Id)

namespace qor{ namespace platform { namespace nslinux{ namespace x{

    Window::Window(unsigned long drawableId, Display* display) : Drawable(drawableId), m_display(display), temporary(true)
    {
    }
    
    Window::Window(Display* display, unsigned long parent, int x, int y, unsigned int width, unsigned int height, unsigned int border_width, unsigned long border, unsigned long background) : Drawable(0), m_display(display), temporary(false)
    {
        //XCreateSimpleWindow creates a window that inherits its attributes from its parent window.
        m_Id = XCreateSimpleWindow((::Display*)(m_display->Use()), (::Window)(parent), x, y, width, height, border_width, border, background);
    }

    Window::Window(Display* display, unsigned long parent, int x, int y, unsigned int width, unsigned int height, unsigned int border_width, int depth, unsigned int type, Visual* visual, unsigned long valuemask, SetWindowAttributes& attributes) : Drawable(0), m_display(display), temporary(false)
    {
        m_Id = XCreateWindow((::Display*)(m_display->Use()), (::Window)(parent), x, y, width, height, border_width, depth, type, (::Visual*)(visual->Use()), valuemask, reinterpret_cast<XSetWindowAttributes*>(&attributes));
    }

    qor::ref_of<Window>::type Window::CreateChildWindow(int x, int y, unsigned int width, unsigned int height, unsigned int border_width, unsigned long border, unsigned long background)
    {
        return new_ref<Window>(m_display, m_Id, x, y, width, height, border_width, border, background);
    }

    Window::~Window()
    {
        if(!temporary)
        {
            XDestroyWindow(WITH_THIS);
            m_Id = 0;
        }
    }

    int Window::Reparent(unsigned long parent, int x, int y)
    {
        return XReparentWindow(WITH_THIS, parent, x, y);
    }
    
    int Window::Raise()
    {
        return XRaiseWindow(WITH_THIS);
    }

    int Window::Lower()
    {
        return XLowerWindow(WITH_THIS);
    }

    int Window::Move(int x, int y)
    {
        return XMoveWindow(WITH_THIS, x, y);
    }

    int Window::Resize(unsigned int width, unsigned int height)
    {
        return XResizeWindow(WITH_THIS, width, height);
    }

    int Window::MoveResize(int x, int y, unsigned int width, unsigned int height)
    {
        return XMoveResizeWindow(WITH_THIS, x, y, width, height);
    }

    int Window::DestroySubwindows()
    {
        return XDestroySubwindows(WITH_THIS);
    }

    int Window::ChangeAttributes(unsigned long valuemask, SetWindowAttributes& attributes)
    {
        return XChangeWindowAttributes(WITH_THIS, valuemask, reinterpret_cast<XSetWindowAttributes*>(&attributes));
    }

    int Window::ChangeAttributes(SetWindowAttributesQuery& setAttributesQuery)
    {
        return ChangeAttributes(setAttributesQuery.Mask(), setAttributesQuery.Attributes());
    }

    int Window::Configure(unsigned long value_mask, WindowChanges& values)
    {
        return XConfigureWindow(WITH_THIS, value_mask, reinterpret_cast<XWindowChanges*>(&values));
    }

    int Window::Configure(WindowChangeQuery& windowChangeQuery)
    {
        return Configure(windowChangeQuery.Mask(), windowChangeQuery.Info());    
    }

    int Window::SetBorderWidth(int width)
    {
        return XSetWindowBorderWidth(WITH_THIS, width);
    }

    int Window::SetBackground(unsigned long background_pixel)
    {
        return XSetWindowBackground(WITH_THIS, background_pixel);
    }

    int Window::SetBackgroundPixmap(unsigned long background_pixmap)
    {
        return XSetWindowBackgroundPixmap(WITH_THIS, background_pixmap);
    }

    int Window::SetBorder(unsigned long border_pixel)
    {
        return XSetWindowBorder(WITH_THIS, border_pixel);
    }

    int Window::SetBorderPixmap(unsigned long border_pixmap)
    {
        return XSetWindowBorderPixmap(WITH_THIS, border_pixmap);
    }

    int Window::MapSubwindows()
    {
        return XMapSubwindows(WITH_THIS);
    }

    int Window::UnmapSubwindows()
    {
        return XUnmapSubwindows(WITH_THIS);
    }

    int Window::Map()
    {
        return XMapWindow(WITH_THIS);
    }

    int Window::MapRaised()
    {
        return XMapRaised(WITH_THIS);
    }

    int Window::Unmap()
    {
        return XUnmapWindow(WITH_THIS);
    }

    int Window::SetColourmap(unsigned long colormap)
    {
        return XSetWindowColormap(WITH_THIS, colormap);
    }

    int Window::CirculateSubwindows(int direction)
    {
        return XCirculateSubwindows(WITH_THIS, direction);
    }

    int Window::DefineCursor(unsigned long cursor)
    {
        return XDefineCursor(WITH_THIS, cursor);
    }

    int Window::UndefineCursor()
    {
        return XUndefineCursor(WITH_THIS);
    }

    int Window::Clear()
    {
        return XClearWindow(WITH_THIS);
    }

    int Window::ClearArea(int x, int y, unsigned width, unsigned height, int exposures)
    {
        return XClearArea(WITH_THIS, x, y, width, height, exposures);
    }

    /*The built-in property types are:
ARC	
PIXMAP
ATOM	
POINT
BITMAP	
RGB_COLOR_MAP
CARDINAL	
RECTANGLE
COLORMAP	
STRING
CURSOR	
VISUALID
DRAWABLE	
WINDOW
FONT	
WM_HINTS
INTEGER	
WM_SIZE_HINTS*/

/*The built-in property names are:

CUT_BUFFER0	RESOURCE_MANAGER
CUT_BUFFER1	WM_CLASS
CUT_BUFFER2	WM_CLIENT_MACHINE
CUT_BUFFER3	WM_COLORMAP_WINDOWS
CUT_BUFFER4	WM_COMMAND
CUT_BUFFER5	WM_HINTS
CUT_BUFFER6	WM_ICON_NAME
CUT_BUFFER7	WM_ICON_SIZE
RGB_BEST_MAP	WM_NAME
RGB_BLUE_MAP	WM_NORMAL_HINTS
RGB_DEFAULT_MAP	WM_PROTOCOLS
RGB_GRAY_MAP	WM_STATE
RGB_GREEN_MAP	WM_TRANSIENT_FOR
RGB_RED_MAP	WM_ZOOM_HINTS*/

    int Window::GetProperty(unsigned long property, long long_offset, long long_length, int del, unsigned long req_type, unsigned long* actual_type_return, int* actual_format_return, unsigned long* nitems_return, unsigned long* bytes_after_return, unsigned char** prop_return)
    {
        return XGetWindowProperty(WITH_THIS, property, long_offset, long_length, del, req_type, actual_type_return, actual_format_return, nitems_return, bytes_after_return, prop_return);        
    }

    std::vector<unsigned long> Window::ListProperties()
    {
        std::vector<unsigned long> properties;
        int numProperties = 0;
        unsigned long* data = XListProperties(WITH_THIS, &numProperties);
        if(data != nullptr && numProperties != 0)
        {
            properties.resize(numProperties);
            memcpy(properties.data(), data, sizeof(unsigned long) * numProperties);
            XFree(data);
        }
        return properties;
    }

    //mode = PropModeReplace, PropModePrepend, or PropModeAppend.
    //format appears to be bits per element
    int Window::ChangeProperty(unsigned long property, unsigned long type, int format, int mode, unsigned char* data, int nelements)
    {
        return XChangeProperty(WITH_THIS, property, type, format, mode, data, nelements);
    }
        
    WMHints Window::GetWMHints()
    {
        WMHints hints = {0};
        XWMHints* data = XGetWMHints(WITH_THIS);
        if(data != nullptr)
        {
            memcpy(&hints, data, sizeof(WMHints));
            XFree(data);
        }
        return hints;
    }

    int Window::SetWMHints(WMHints& hints)
    {
        XWMHints* data = XAllocWMHints();
        memcpy(data, &hints, sizeof(WMHints));
        int result = XSetWMHints(WITH_THIS, data);
        XFree(data);
        return result;
    }

    WMSizeHints Window::GetNormalHints(long& validBitsOfReturn, int& status)
    {      
        WMSizeHints hints = {0};
        validBitsOfReturn = 0;
        status = XGetWMNormalHints(WITH_THIS, reinterpret_cast<XSizeHints*>(&hints), &validBitsOfReturn);
        return hints;
    }

    void Window::SetNormalHints(WMSizeHints& hints)
    {
        XSetWMNormalHints(WITH_THIS, reinterpret_cast<XSizeHints*>(&hints));
    }
        
    int Window::SetTitle(const std::string& title)
    {
        return XStoreName(WITH_THIS, title.c_str());
    }
    
    std::string Window::GetTitle()
    {
        std::string title;
        char* buffer = nullptr;
        XFetchName(WITH_THIS, &buffer);
        if(buffer != nullptr)
        {
            title = std::string(buffer);
            XFree(buffer);
        }
        return title;
    }

    int Window::SelectInput(long eventMask)
    {
        return XSelectInput(WITH_THIS, eventMask);
    }

    int Window::SetWMProtocols(unsigned long* atoms, int count)
    {
        return XSetWMProtocols( WITH_THIS, atoms, count);
    }

    GC Window::CreateGC(unsigned long mask, GCValues& values )
    {
        ::GC gc = XCreateGC(WITH_THIS, mask, reinterpret_cast<XGCValues*>(&values));
        return GC(m_display, this, gc);
    }

    int Window::Withdraw(int screen_number)
    {
        return XWithdrawWindow(WITH_THIS, screen_number);
    }

    int Window::SetZoomHints(WMSizeHints& zhints)
    {
        return XSetZoomHints(WITH_THIS, reinterpret_cast<XSizeHints*>(&zhints));
    }

    int Window::SetColourmap(Colourmap& colourmap)
    {
        return XSetWindowColormap(WITH_THIS, colourmap.GetId());
    }

    void Window::SetWMProperties(TextProperty* window_name, TextProperty* icon_name, char** argv, int argc, WMSizeHints* normal_hints, WMHints* wm_hints, ClassHint* class_hints)
    {
        XSetWMProperties(WITH_THIS, reinterpret_cast<XTextProperty*>(window_name), reinterpret_cast<XTextProperty*>(icon_name), argv, argc, reinterpret_cast<XSizeHints*>(normal_hints), reinterpret_cast<XWMHints*>(wm_hints), reinterpret_cast<XClassHint*>(class_hints));
    }

    void Window::SetWMName(TextProperty& windowName)
    {
        XSetWMName(WITH_THIS, reinterpret_cast<XTextProperty*>(&windowName));
    }

    void Window::SetWMIconName(TextProperty& iconName)
    {
        XSetWMIconName(WITH_THIS, reinterpret_cast<XTextProperty*>(&iconName));
    }

    int Window::SetWMHints(WMSizeHints& normalHints)
    {
        return XSetWMHints(WITH_THIS, reinterpret_cast<XWMHints*>(&normalHints));
    }

    int Window::SetWMColourmapWindows(std::vector<unsigned long> colourmapWindows)
    {
        return XSetWMColormapWindows(WITH_THIS, colourmapWindows.data(), colourmapWindows.size());
    }

    void Window::SetWMClientMachine(TextProperty& clientMachine)
    {
        XSetWMClientMachine(WITH_THIS, reinterpret_cast<XTextProperty*>(&clientMachine));
    }

    int Window::SetTransientForHint(Window& propWindow)
    {
        return XSetTransientForHint(WITH_THIS, propWindow.GetId());
    }

    void Window::SetTextProperty(TextProperty& textProp, unsigned long property)
    {
        XSetTextProperty(WITH_THIS, reinterpret_cast<XTextProperty*>(&textProp), property);
    }

    void Window::SetRGBColourmaps(std::vector<StandardColourmap> colourMaps, unsigned long property)
    {
        XSetRGBColormaps(WITH_THIS, reinterpret_cast<XStandardColormap*>(colourMaps.data()), colourMaps.size(), (::Atom)(property));
    }

    int Window::GetIconSizes(std::vector<IconSize>& size_list_return)
    {
        int count;
        XIconSize* data = nullptr;
        int status = XGetIconSizes(WITH_THIS, &data, &count);
        if(data != nullptr && count != 0)
        {
            size_list_return.resize(count);
            memcpy(size_list_return.data(), data, sizeof(IconSize)* count);
            XFree(data);
        }
        return status;
    }

}}}}//qor::platform::nslinux::x

#undef WITH_THIS
