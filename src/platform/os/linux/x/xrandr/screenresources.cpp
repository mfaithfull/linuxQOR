// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include "randr.h"
#include "screenresources.h"
#include "outputinfo.h"
#include "crtcinfo.h"
#include "crtctransformattributes.h"
#include "providerinfo.h"

#include "src/platform/os/linux/x/xlib/display.h"
#include "src/platform/os/linux/x/xlib/window.h"
#include "src/qor/error/error.h"

#include <X11/Xlib.h>
#include <X11/X.h>
#include <X11/Xcms.h>
#include <X11/Xutil.h>
#include <X11/Xresource.h>
#include <X11/Xatom.h>
#include <X11/cursorfont.h>
#include <X11/keysymdef.h>
#include <X11/keysym.h>
#include <X11/Xlibint.h>
#include <X11/Xproto.h>
#include <X11/Xprotostr.h>
#include <X11/extensions/Xrandr.h>

namespace qor{ namespace platform { namespace nslinux{ namespace x{

    ScreenResources::ScreenResources(Display* dpy, Window& window) : m_display(dpy)
    {
        m_resources = XRRGetScreenResourcesCurrent((::Display*)(m_display->Use()), window.GetId());
    }

    ScreenResources::ScreenResources(Display* dpy, void* resources) : m_display(dpy), m_resources(resources)
    {        
    }

    ScreenResources::~ScreenResources()
    {        
        XRRFreeScreenResources((::XRRScreenResources*)(m_resources));
    }

    OutputInfo ScreenResources::GetOutputInfo(unsigned long output)
    {
        XRROutputInfo* data = XRRGetOutputInfo((::Display*)(m_display->Use()), (::XRRScreenResources*)(m_resources), output);
        return OutputInfo(data);
    }

    CrtcInfo ScreenResources::GetCrtcInfo(unsigned long crtc)
    {
        XRRCrtcInfo* data = XRRGetCrtcInfo((::Display*)(m_display->Use()), (::XRRScreenResources*)(m_resources), crtc);
        return CrtcInfo(data);
    }

    int ScreenResources::SetCrtcConfig(unsigned long crtc, unsigned long timestamp, int x, int y, unsigned long mode, unsigned short rotation, std::vector<unsigned long>& outputs)
    {
        return XRRSetCrtcConfig((::Display*)(m_display->Use()), (::XRRScreenResources*)(m_resources), crtc, timestamp, x, y, mode, rotation, outputs.data(), outputs.size());
    }

    int ScreenResources::GetCrtcGammaSize(unsigned long crtc)
    {
        return XRRGetCrtcGammaSize((::Display*)(m_display->Use()), crtc);
    }

    CrtcGamma ScreenResources::GetCrtcGamma(unsigned long crtc)
    {
        XRRCrtcGamma* data = XRRGetCrtcGamma((::Display*)(m_display->Use()), crtc);
        if(data != nullptr)
        {
            CrtcGamma gamma = *(reinterpret_cast<CrtcGamma*>(data));
            XFree(data);
            return gamma;
        }
        return CrtcGamma {};
    }

    void ScreenResources::SetCrtcGamma(unsigned long crtc, CrtcGamma& gamma)
    {
        XRRSetCrtcGamma((::Display*)(m_display->Use()), crtc, reinterpret_cast<XRRCrtcGamma*>(&gamma));
    }
    
    Panning ScreenResources::GetPanning(unsigned long crtc)
    {
        XRRPanning* data = XRRGetPanning((::Display*)(m_display->Use()), (::XRRScreenResources*)(m_resources), crtc);
        if( data != nullptr)
        {
            Panning panning = *(reinterpret_cast<Panning*>(data));
            XRRFreePanning(data);
            return panning;
        }
        return Panning {};
    }
        
    int ScreenResources::SetPanning(unsigned long crtc, Panning& panning)
    {
        return XRRSetPanning((::Display*)(m_display->Use()), (::XRRScreenResources*)(m_resources), crtc, reinterpret_cast<XRRPanning*>(&panning));
    }
    
    CrtcTransformAttributes ScreenResources::GetCrtcTransform(unsigned long crtc, int& status)
    {
        XRRCrtcTransformAttributes* data = nullptr;
        status = XRRGetCrtcTransform((::Display*)(m_display->Use()), crtc, &data);
        return CrtcTransformAttributes(data);
    }

    void ScreenResources::SetCrtcTransform(unsigned long crtc, Transform* transform, const char* filter, Fixed* params, int nparams)
    {
        XRRSetCrtcTransform((::Display*)(m_display->Use()),crtc, reinterpret_cast<XTransform*>(transform), filter, reinterpret_cast<XFixed*>(params), nparams);
    }
        
    ProviderInfo ScreenResources::GetProviderInfo(unsigned long provider)
    {
        XRRProviderInfo* data = XRRGetProviderInfo((::Display*)(m_display->Use()), (::XRRScreenResources*)(m_resources), provider);
        return ProviderInfo(data);
    }
        

}}}}//qor::platform::nslinux::x
