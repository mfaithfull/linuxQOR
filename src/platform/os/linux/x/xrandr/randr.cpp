// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include "randr.h"
#include "screenconfiguration.h"
#include "screenresources.h"
#include "propertyinfo.h"
#include "provider.h"
#include "monitorinfo.h"

#include "src/platform/os/linux/x/xlib/display.h"
#include "src/platform/os/linux/x/xlib/window.h"
#include "src/platform/os/linux/x/xlib/cursor.h"
#include "src/qor/error/error.h"

#include <X11/Xlib.h>
#include <X11/X.h>
#include <X11/Xcms.h>
#include <X11/Xutil.h>
#include <X11/Xresource.h>
#include <X11/Xatom.h>
#include <X11/cursorfont.h>
#include <X11/keysymdef.h>
#include <X11/keysym.h>
#include <X11/Xlibint.h>
#include <X11/Xproto.h>
#include <X11/Xprotostr.h>

#include <X11/extensions/Xrandr.h>

namespace qor{ namespace platform { namespace nslinux{ namespace x{

    RandR::RandR(Display* dpy) : m_display(dpy)
    {        
        XExtCodes* data = XInitExtension((::Display*)(m_display->Use()), "RANDR");
        m_extCodes = *(reinterpret_cast<ExtCodes*>(data));
        XFree(data);
    }

    RandR::~RandR()
    {
    }

    int RandR::QueryExtension(int& eventBaseReturn, int& errorBaseReturn)
    {
        return XRRQueryExtension((::Display*)(m_display->Use()), &eventBaseReturn, &errorBaseReturn);
    }

    int RandR::QueryVersion(int& majorVersionReturn, int& minorVersionReturn)
    {
        return XRRQueryVersion((::Display*)(m_display->Use()), &majorVersionReturn, &minorVersionReturn);
    }

    ScreenConfiguration RandR::GetScreenInfo(Window window)
    {
        XRRScreenConfiguration* data = XRRGetScreenInfo((::Display*)(m_display->Use()), window.GetId());
        ScreenConfiguration screenInfo(m_display, data);
        return screenInfo;
    }

    unsigned short RandR::Rotations(int screen, unsigned short& currentRotation)
    {
        return XRRRotations((::Display*)(m_display->Use()), screen, &currentRotation);
    }

    std::vector<ScreenSize> RandR::Sizes(int screen)
    {
        std::vector<ScreenSize> sizes;
        int count = 0;
        XRRScreenSize* data = XRRSizes((::Display*)(m_display->Use()), screen, &count);
        if(count !=0 && data != nullptr)
        {
            sizes.resize(count);
            memcpy(sizes.data(), data, sizeof(ScreenSize) * count);
            XFree(data);
        }
        return sizes;
    }

    std::vector<short> RandR::Rates(int screen, int sizeID)
    {
        std::vector<short> rates;
        int count = 0;
        short* data = XRRRates((::Display*)(m_display->Use()), screen, sizeID, &count);
        if( count != 0 && data != nullptr)
        {
            rates.resize(count);
            memcpy(rates.data(), data, sizeof(short) * count);
            XFree(data);
        }
        return rates;
    }

    unsigned long RandR::Times(int screen, unsigned long& configTimestamp)
    {
        return XRRTimes((::Display*)(m_display->Use()), screen, &configTimestamp);
    }

    int RandR::RootToScreen(Window& root)
    {
        return XRRRootToScreen((::Display*)(m_display->Use()), root.GetId());
    }

    void RandR::SelectInput(Window& window, int mask)
    {
        XRRSelectInput((::Display*)(m_display->Use()), window.GetId(), mask);
    }

    int RandR::GetScreenSizeRange(Window& window, int& minWidth, int& minHeight, int& maxWidth, int& maxHeight)
    {
        return XRRGetScreenSizeRange((::Display*)(m_display->Use()), window.GetId(), &minWidth, &minHeight, &maxWidth, &maxHeight);
    }

    void RandR::SetScreenSize(Window& window, int width, int height, int mmWidth, int mmHeight)
    {
        XRRSetScreenSize((::Display*)(m_display->Use()), window.GetId(), width, height, mmWidth, mmHeight);
    }

    ScreenResources RandR::GetScreenResources(Window& window)
    {
        XRRScreenResources* data = XRRGetScreenResources((::Display*)(m_display->Use()), window.GetId());
        ScreenResources screenResources(m_display, data);
        return screenResources;
    }
        
    std::vector<unsigned long> RandR::ListOutputProperties(unsigned long output)
    {
        std::vector<unsigned long> properties;
        int count = 0;
        Atom* data = XRRListOutputProperties((::Display*)(m_display->Use()), output, &count);
        if(count != 0 && data != nullptr)
        {
            properties.resize(count);
            memcpy(properties.data(), data, sizeof(unsigned long) * count);
            XFree(data);
        }
        return properties;
    }

    PropertyInfo RandR::QueryOutputProperty(unsigned long output, unsigned long property)
    {
        XRRPropertyInfo* data = XRRQueryOutputProperty((::Display*)(m_display->Use()), output, property);
        return PropertyInfo(data);
    }

    void RandR::ConfigureOutputProperty(unsigned long output, unsigned long property, int pending, int range, std::vector<long>& values)
    {
        XRRConfigureOutputProperty((::Display*)(m_display->Use()), output, property, pending, range, values.size(), values.data());
    }

    void RandR::ChangeOutputProperty(unsigned long output, unsigned long property, unsigned long type, int format, int mode, const std::vector<unsigned char> data)
    {
        XRRChangeOutputProperty((::Display*)(m_display->Use()), output, property, type, format, mode, data.data(), data.size());
    }

    void RandR::DeleteOutputProperty(unsigned long output, unsigned long property)
    {
        XRRDeleteOutputProperty((::Display*)(m_display->Use()), output, property);
    }

    int RandR::GetOutputProperty(unsigned long output, unsigned long property, 
        long offset, long length, int _delete, int pending, unsigned long reqType, unsigned long& actualType, int& actualFormat, unsigned long& bytesAfter, std::vector<unsigned char>& value)
    {
        unsigned char* prop = nullptr;
        unsigned long nitems = 0;
        int status = XRRGetOutputProperty((::Display*)(m_display->Use()), output, property, offset, length, _delete, pending, reqType, &actualType,
            &actualFormat, &nitems, &bytesAfter, &prop);
        if(nitems != 0 && prop != nullptr)
        {
            value.clear();//TODO:
            value.resize(nitems * ( actualFormat / 8));
            memcpy(value.data(), prop, nitems * (actualFormat / 8));
            XFree(prop);
        }
        return status;
    }

    void RandR::AddOutputMode(unsigned long output, unsigned long mode)
    {
        XRRAddOutputMode((::Display*)(m_display->Use()), output, mode);
    }

    void RandR::DeleteOutputMode(unsigned long output, unsigned long mode)
    {
        XRRDeleteOutputMode((::Display*)(m_display->Use()), output, mode);
    }

    void RandR::SetOutputPrimary(Window& window, unsigned long output)
    {
        XRRSetOutputPrimary((::Display*)(m_display->Use()), window.GetId(), output);
    }

    unsigned long RandR::GetOutputPrimary(Window& window)
    {
        return XRRGetOutputPrimary((::Display*)(m_display->Use()), window.GetId());
    }

    std::vector<Provider> RandR::GetProviderResources(Window& window, unsigned long& timeStamp)
    {
        std::vector<Provider> providers;
        XRRProviderResources* data = XRRGetProviderResources((::Display*)(m_display->Use()), window.GetId());
        if(data != nullptr)
        {
            timeStamp = data->timestamp;
            providers.resize(data->nproviders);
            for(unsigned int index = 0; index < data->nproviders; ++index)
            {
                Provider prov(m_display, data->providers[index]);
                providers.emplace_back(prov);
            }
            XRRFreeProviderResources(data);
        }
        return providers;
    }        

    MonitorInfo RandR::GetMonitors(Window& window, int getActive)
    {
        int count = 0;
        XRRMonitorInfo* data = XRRGetMonitors((::Display*)(m_display->Use()), window.GetId(), getActive, &count);
        return MonitorInfo(data);        
    }

    void RandR::SetMonitor(Window& window, MonitorInfo& monitorInfo)
    {
        XRRSetMonitor((::Display*)(m_display->Use()), window.GetId(), (::XRRMonitorInfo*)(monitorInfo.Use()));
    }

    void RandR::DeleteMonitor(Window& window, unsigned long name)
    {
        XRRDeleteMonitor((::Display*)(m_display->Use()), window.GetId(), name);
    }

    int RandR::UpdateConfiguration(Event* event)
    {
        return XRRUpdateConfiguration(reinterpret_cast<XEvent*>(event));
    }

}}}}//qor::platform::nslinux::x