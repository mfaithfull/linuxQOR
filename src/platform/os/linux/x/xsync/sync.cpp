// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include "sync.h"
#include "src/platform/os/linux/x/xlib/display.h"
#include "src/platform/os/linux/x/xlib/window.h"
#include "src/platform/os/linux/x/xlib/cursor.h"
#include "src/qor/error/error.h"

#include <X11/Xlib.h>
#include <X11/X.h>
#include <X11/Xcms.h>
#include <X11/Xutil.h>
#include <X11/Xresource.h>
#include <X11/Xatom.h>
#include <X11/cursorfont.h>
#include <X11/keysymdef.h>
#include <X11/keysym.h>
#include <X11/Xlibint.h>
#include <X11/Xproto.h>
#include <X11/Xprotostr.h>

#include <X11/extensions/sync.h>

namespace qor{ namespace platform { namespace nslinux{ namespace x{

    XSync::XSync(Display* dpy) : m_display(dpy)
    {        
        XExtCodes* data = XInitExtension((::Display*)(m_display->Use()), "XSYNC");
        m_extCodes = *(reinterpret_cast<ExtCodes*>(data));
        XFree(data);
    }

    XSync::~XSync()
    {
    }

    void XSync::IntToValue(SyncValue* pv, int i)
    {
        XSyncIntToValue(reinterpret_cast<XSyncValue*>(pv), i);
    }

    void XSync::IntsToValue(SyncValue* pv, unsigned int l, int h)
    {
        XSyncIntsToValue(reinterpret_cast<XSyncValue*>(pv), l, h);
    }

    int XSync::ValueGreaterThan(SyncValue a, SyncValue b)
    {
        return XSyncValueGreaterThan(*(reinterpret_cast<XSyncValue*>(&a)), *(reinterpret_cast<XSyncValue*>(&b)));
    }

    int XSync::ValueLessThan(SyncValue a, SyncValue b)
    {
        return XSyncValueLessThan(*(reinterpret_cast<XSyncValue*>(&a)), *(reinterpret_cast<XSyncValue*>(&b)));
    }

    int XSync::ValueGreaterOrEqual(SyncValue a, SyncValue b)
    {
        return XSyncValueGreaterOrEqual(*(reinterpret_cast<XSyncValue*>(&a)), *(reinterpret_cast<XSyncValue*>(&b)));
    }

    int XSync::ValueLessOrEqual(SyncValue a, SyncValue b)
    {
        return XSyncValueLessOrEqual(*(reinterpret_cast<XSyncValue*>(&a)), *(reinterpret_cast<XSyncValue*>(&b)));
    }

    int XSync::ValueEqual(SyncValue a, SyncValue b)
    {
        return XSyncValueEqual(*(reinterpret_cast<XSyncValue*>(&a)), *(reinterpret_cast<XSyncValue*>(&b)));
    }

    int XSync::ValueIsNegative(SyncValue v)
    {
        return XSyncValueIsNegative(*(reinterpret_cast<XSyncValue*>(&v)));
    }

    int XSync::ValueIsZero(SyncValue a)
    {
        return XSyncValueIsZero(*(reinterpret_cast<XSyncValue*>(&a)));
    }

    int XSync::ValueIsPositive(SyncValue v)
    {
        return XSyncValueIsPositive(*(reinterpret_cast<XSyncValue*>(&v)));
    }

    unsigned int XSync::ValueLow32(SyncValue v)
    {
        return XSyncValueLow32(*(reinterpret_cast<XSyncValue*>(&v)));
    }

    int XSync::ValueHigh32(SyncValue v)
    {
        return XSyncValueHigh32(*(reinterpret_cast<XSyncValue*>(&v)));
    }

    void XSync::ValueAdd(SyncValue* presult, SyncValue a, SyncValue b, int* poverflow)
    {
        XSyncValueAdd(reinterpret_cast<XSyncValue*>(presult), *(reinterpret_cast<XSyncValue*>(&a)), *(reinterpret_cast<XSyncValue*>(&b)), poverflow);
    }

    void XSync::ValueSubtract(SyncValue* presult, SyncValue a, SyncValue b, int* poverflow)
    {
        XSyncValueSubtract(reinterpret_cast<XSyncValue*>(presult), *(reinterpret_cast<XSyncValue*>(&a)), *(reinterpret_cast<XSyncValue*>(&b)), poverflow);
    }

    void XSync::MaxValue(SyncValue* pv)
    {
        XSyncMaxValue(reinterpret_cast<XSyncValue*>(pv));
    }

    void XSync::MinValue(SyncValue* pv)
    {
        XSyncMinValue(reinterpret_cast<XSyncValue*>(pv));
    }

    int XSync::QueryExtension(Display* dpy, int* event_base_return, int* error_base_return)
    {
        return XSyncQueryExtension((::Display*)(dpy->Use()), event_base_return, error_base_return);
    }

    int XSync::Initialize(Display* dpy, int* major_version_return, int* minor_version_return)
    {
        return XSyncInitialize((::Display*)(dpy->Use()), major_version_return, minor_version_return);
    }

    SyncSystemCounter* XSync::ListSystemCounters(Display* dpy, int* n_counters_return)
    {
        return reinterpret_cast<SyncSystemCounter*>(XSyncListSystemCounters((::Display*)(dpy->Use()), n_counters_return));
    }

    void XSync::FreeSystemCounterList(SyncSystemCounter* list)
    {
        XSyncFreeSystemCounterList(reinterpret_cast<XSyncSystemCounter*>(list));
    }

    unsigned long XSync::CreateCounter(Display* dpy, SyncValue initial_value)
    {
        return XSyncCreateCounter((::Display*)(dpy->Use()), *(reinterpret_cast<XSyncValue*>(&initial_value)));
    }

    int XSync::SetCounter(Display* dpy, unsigned long counter, SyncValue value)
    {
        return XSyncSetCounter((::Display*)(dpy->Use()), counter, *(reinterpret_cast<XSyncValue*>(&value)));
    }

    int XSync::ChangeCounter(Display* dpy, unsigned long counter, SyncValue value)
    {
        return XSyncChangeCounter((::Display*)(dpy->Use()), counter, *(reinterpret_cast<XSyncValue*>(&value)));
    }

    int XSync::DestroyCounter(Display* dpy, unsigned long counter)
    {
        return XSyncDestroyCounter((::Display*)(dpy->Use()), counter);
    }

    int XSync::QueryCounter(Display* dpy, unsigned long counter, SyncValue* value_return)
    {
        return XSyncQueryCounter((::Display*)(dpy->Use()), counter, reinterpret_cast<XSyncValue*>(value_return));
    }

    int XSync::Await(Display* dpy, SyncWaitCondition* wait_list, int n_conditions)
    {
        return XSyncAwait((::Display*)(dpy->Use()), reinterpret_cast<XSyncWaitCondition*>(wait_list), n_conditions);
    }

    unsigned long XSync::CreateAlarm(Display* dpy, unsigned long values_mask, SyncAlarmAttributes* values)
    {
        return XSyncCreateAlarm((::Display*)(dpy->Use()), values_mask, reinterpret_cast<XSyncAlarmAttributes*>(values));
    }

    int XSync::DestroyAlarm(Display* dpy, unsigned long alarm)
    {
        return XSyncDestroyAlarm((::Display*)(dpy->Use()), alarm);
    }

    int XSync::QueryAlarm(Display* dpy, unsigned long alarm, SyncAlarmAttributes* values_return)
    {
        return XSyncQueryAlarm((::Display*)(dpy->Use()), alarm, reinterpret_cast<XSyncAlarmAttributes*>(values_return));
    }

    int XSync::ChangeAlarm(Display* dpy, unsigned long alarm, unsigned long values_mask, SyncAlarmAttributes* values)
    {
        return XSyncChangeAlarm((::Display*)(dpy->Use()), alarm, values_mask, reinterpret_cast<XSyncAlarmAttributes*>(values));
    }

    int XSync::SetPriority(Display* dpy, unsigned long client_resource_id, int priority)
    {
        return XSyncSetPriority((::Display*)(dpy->Use()), client_resource_id, priority);
    }

    int XSync::GetPriority(Display* dpy, unsigned long client_resource_id, int* return_priority)
    {
        return XSyncGetPriority((::Display*)(dpy->Use()), client_resource_id, return_priority);
    }

    unsigned long XSync::CreateFence(Display* dpy, unsigned long d, int initially_triggered)
    {
        return XSyncCreateFence((::Display*)(dpy->Use()), d, initially_triggered);
    }

    int XSync::TriggerFence(Display* dpy, unsigned long fence)
    {
        return XSyncTriggerFence((::Display*)(dpy->Use()), fence);
    }

    int XSync::ResetFence(Display* dpy, unsigned long fence)
    {
        return XSyncResetFence((::Display*)(dpy->Use()), fence);
    }

    int XSync::DestroyFence(Display* dpy, unsigned long fence)
    {
        return XSyncDestroyFence((::Display*)(dpy->Use()), fence);
    }

    int XSync::QueryFence(Display* dpy, unsigned long fence, int* triggered)
    {
        return XSyncQueryFence((::Display*)(dpy->Use()), fence, triggered);
    }

    int XSync::AwaitFence(Display* dpy, const unsigned long* fence_list, int n_fences)
    {
        return XSyncAwaitFence((::Display*)(dpy->Use()), fence_list, n_fences);
    }

}}}}//qor::platform::nslinux::x