// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_LINUX_XSYNC
#define QOR_PP_H_LINUX_XSYNC

#include <string>
#include <vector>

#include "src/platform/os/linux/x/xlib/display.h"

//All types on this interface must be portable
namespace qor{ namespace platform { namespace nslinux{ namespace x{
    
    class qor_pp_module_interface(QOR_LINX) Display;
    struct ExtCodes;
    
    struct SyncValue 
    {
        int hi;
        unsigned int lo;
    };

    struct SyncSystemCounter
    {
        char *name;			/* null-terminated name of system counter */
        unsigned long counter;	/* counter id of this system counter */
        SyncValue resolution;	/* resolution of this system counter */
    };

    enum SyncValueType
    {
        XSyncAbsolute,
        XSyncRelative
    };

    enum SyncTestType
    {
        XSyncPositiveTransition,
        XSyncNegativeTransition,
        XSyncPositiveComparison,
        XSyncNegativeComparison
    };

    struct SyncTrigger
    {
        unsigned long counter;	/* counter to trigger on */
        SyncValueType value_type;	/* absolute/relative */
        SyncValue wait_value;	/* value to compare counter to */
        SyncTestType test_type;	/* pos/neg comparison/transtion */
    };

    struct SyncWaitCondition
    {
        SyncTrigger trigger;	/* trigger for await */
        SyncValue event_threshold; /* send event if past threshold */
    };

    enum SyncAlarmState
    {
        XSyncAlarmActive,
        XSyncAlarmInactive,
        XSyncAlarmDestroyed
    };

    struct SyncAlarmAttributes
    {
        SyncTrigger trigger;
        SyncValue  delta;
        int events;
        SyncAlarmState state;
    };

    struct SyncCounterNotifyEvent
    {
        int type;			/* event base + unsigned longNotify */
        unsigned long serial;	/* # of last request processed by server */
        int send_event;		/* true if this came from a SendEvent request */
        void* display;		/* Display the event was read from */
        unsigned long counter;	/* counter involved in await */
        SyncValue wait_value;	/* value being waited for */
        SyncValue counter_value;	/* counter value when this event was sent */
        unsigned long time;			/* milliseconds */
        int count;			/* how many more events to come */
        int destroyed;		/* True if counter was destroyed */
    };

    struct SyncAlarmNotifyEvent
    {
        int type;			/* event base + XSyncAlarmNotify */
        unsigned long serial;	/* # of last request processed by server */
        int send_event;		/* true if this came from a SendEvent request */
        void* display;		/* Display the event was read from */
        unsigned long alarm;		/* alarm that triggered */
        SyncValue counter_value;	/* value that triggered the alarm */
        SyncValue alarm_value;	/* test  value of trigger in alarm */
        unsigned long time;			/* milliseconds */
        SyncAlarmState state;	/* new state of alarm */
    };

    struct SyncAlarmError
    {
        int type;
        void* display;		        // Display the event was read from
        unsigned long alarm;		// resource id 
        unsigned long serial;	    // serial number of failed request 
        unsigned char error_code;	// error base + XSyncBadAlarm 
        unsigned char request_code;	// Major op-code of failed request 
        unsigned char minor_code;	// Minor op-code of failed request 
    } ;

    struct SyncCounterError
    {
        int type;
        void* display;		// Display the event was read from
        unsigned long counter;	// resource id
        unsigned long serial;	// serial number of failed request
        unsigned char error_code;	// error base + XSyncBadCounter
        unsigned char request_code;	// Major op-code of failed request
        unsigned char minor_code;	// Minor op-code of failed request
    };


    class qor_pp_module_interface(QOR_LINXSYNC) XSync
    {
    public:
    
        XSync(Display* dpy);
        virtual ~XSync();

        void IntToValue(SyncValue* pv, int i);
        void IntsToValue(SyncValue* pv, unsigned int l, int h);
        int ValueGreaterThan(SyncValue a, SyncValue b);
        int ValueLessThan(SyncValue a, SyncValue b);
        int ValueGreaterOrEqual(SyncValue a, SyncValue b);
        int ValueLessOrEqual(SyncValue a, SyncValue b);
        int ValueEqual(SyncValue a, SyncValue b);
        int ValueIsNegative(SyncValue v);
        int ValueIsZero(SyncValue a);
        int ValueIsPositive(SyncValue v);
        unsigned int ValueLow32(SyncValue v);
        int ValueHigh32(SyncValue v);
        void ValueAdd(SyncValue* presult, SyncValue a, SyncValue b, int* poverflow);
        void ValueSubtract(SyncValue* presult, SyncValue a, SyncValue b, int* poverflow);
        void MaxValue(SyncValue* pv);
        void MinValue(SyncValue* pv);
        int QueryExtension(Display* dpy, int* event_base_return, int* error_base_return);
        int Initialize(Display* dpy, int* major_version_return, int* minor_version_return);
        SyncSystemCounter* ListSystemCounters(Display* dpy, int* n_counters_return);
        void FreeSystemCounterList(SyncSystemCounter* list);
        unsigned long CreateCounter(Display* dpy, SyncValue initial_value);
        int SetCounter(Display* dpy, unsigned long counter, SyncValue value);
        int ChangeCounter(Display* dpy, unsigned long counter, SyncValue value);
        int DestroyCounter(Display* dpy, unsigned long counter);
        int QueryCounter(Display* dpy, unsigned long counter, SyncValue* value_return);
        int Await(Display* dpy, SyncWaitCondition* wait_list, int n_conditions);
        unsigned long CreateAlarm(Display* dpy, unsigned long values_mask, SyncAlarmAttributes* values);
        int DestroyAlarm(Display* dpy, unsigned long alarm);
        int QueryAlarm(Display* dpy, unsigned long alarm, SyncAlarmAttributes* values_return);
        int ChangeAlarm(Display* dpy, unsigned long alarm, unsigned long values_mask, SyncAlarmAttributes* values);
        int SetPriority(Display* dpy, unsigned long client_resource_id, int priority);
        int GetPriority(Display* dpy, unsigned long client_resource_id, int* return_priority);
        unsigned long CreateFence(Display* dpy, unsigned long d, int initially_triggered);
        int TriggerFence(Display* dpy, unsigned long fence);
        int ResetFence(Display* dpy, unsigned long fence);
        int DestroyFence(Display* dpy, unsigned long fence);
        int QueryFence(Display* dpy, unsigned long fence, int* triggered);
        int AwaitFence(Display* dpy, const unsigned long* fence_list, int n_fences);

    protected:

        Display* m_display;
        ExtCodes m_extCodes;
    };

}}}}//qor::platform::nslinux::x

#endif//QOR_PP_H_LINUX_XSYNC

