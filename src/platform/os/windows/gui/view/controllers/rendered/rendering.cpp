// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include "rendering.h"
#include "../../messages.h"
#include "../../../devicecontext.h"
#include "../../../icon.h"

namespace qor{ namespace platform { namespace nswindows{ namespace gui{ namespace view{

    RenderingController::RenderingController() : BaseWindowPartController()
    {
    }

    bool RenderingController::ProcessMessage(Window& window, long long& lResult, unsigned int msg, unsigned long long wParam, long long lParam)
    {
        bool bProcessed = ProcessHook(window, lResult, msg, wParam, lParam);

        if (bProcessed)
        {
            return true;
        }

        switch (msg)
        {
        case wmPaint:
        {
            OnPaint(window);
            lResult = 0;
            bProcessed = true;
        }
        break;
        case wmSetRedraw:
        {
            bool bRedraw = ((wParam == 1) ? true : false);
            OnSetRedraw(window, bRedraw);
            lResult = 0;
            bProcessed = true;
        }
        break;
        case wmEraseBackground:
        {
            DeviceContext dc(PrimitiveHandle((void*)(wParam)));
            lResult = OnEraseBackground(window, dc);
            bProcessed = true;
        }
        break;
        case wmSysColorChange:
        {
            OnSysColourChange(window);//Forward to all children and regen all SysColour Brushes
            bProcessed = true;
        }
        break;
        case wmShowWindow:
        {
            bool bShow = wParam ? true : false;
            OnShow(window, bShow, lParam);
            lResult = 0;
            bProcessed = true;
        }
        break;
        case wmGetMinMaxInfo:
        {
            MinMaxInfo* minMaxInfo = reinterpret_cast<MinMaxInfo*>(lParam);
            OnGetMinMaxInfo(window, minMaxInfo);
            lResult = 0;
            bProcessed = true;
        }
        break;
        case wmWindowPosChanging:
        {
            WindowPos* pWindowPos = reinterpret_cast<WindowPos*>(lParam);
            OnWindowPosChanging(window, pWindowPos);
            lResult = 0;
            bProcessed = true;
        }
        break;
        case wmWindowPosChanged:
        {
            WindowPos* pWindowPos = reinterpret_cast<WindowPos*>(lParam);
            OnWindowPosChanged(window, pWindowPos);
            lResult = 0;
            bProcessed = true;
        }
        break;
        case wmDisplayChange:
        {
            unsigned short wBitsPP = static_cast<unsigned short>(wParam);
            unsigned short hRes = LoWord(lParam);
            unsigned short vRes = HiWord(lParam);
            OnDisplayChange(window, wBitsPP, hRes, vRes);
            bProcessed = true;
        }
        break;
        case wmGetIcon:
        {
            lResult = OnGetIcon(window, wParam);
            bProcessed = true;
        }
        break;
        case wmSetIcon:
        {
            Icon icon(PrimitiveHandle((void*)(lParam)));
            lResult = OnSetIcon(window, wParam, icon);
            bProcessed = true;
        }
        break;
        case wmSyncPaint:
        {
            OnSyncPaint(window);
            lResult = 0;
            bProcessed = true;
        }
        break;
        case wmSizing:
        {
            Rect* rect = reinterpret_cast<Rect*>(lParam);
            OnSizing(window, wParam, rect);
            lResult = 1;
            bProcessed = true;
        }
        break;
        case wmMoving:
        {
            Rect* rect = reinterpret_cast<Rect*>(lParam);
            OnMoving(window, rect);
            lResult = 1;
            bProcessed = true;
        }
        break;
        case wmQueryNewPalette:
        {
            lResult = OnQueryNewPalette(window);
            bProcessed = true;
        }
        break;
        case wmPaletteIsChanging:
        {
            Window win(PrimitiveHandle((void*)(wParam)));
            OnPaletteChanging(win);
            lResult = 0;
            bProcessed = true;
        }
        break;
        case wmPaletteChanged:
        {
            Window win(PrimitiveHandle((void*)(wParam)));
            OnPaletteChanged(win);
            bProcessed = true;
        }
        break;
        case wmPrint:
        {
            DeviceContext dc(PrimitiveHandle((void*)(wParam)));
            OnPrint(window, dc, lParam);
            bProcessed = true;
        }
        break;
        case wmPrintClient:
        {
            DeviceContext dc(PrimitiveHandle((void*)(wParam)));
            OnPrintClient(window, dc, lParam);
            bProcessed = true;
        }
        break;
        case wmSize:
        {
            OnSize(window, wParam, lParam);
            lResult = 0;
            bProcessed = true;
        }
        break;
        case wmMove:
        {
            OnMove(window, LoWord(lParam), HiWord(lParam));
            lResult = 0;
            bProcessed = true;
        }
        break;
        }

        return bProcessed;
    }

    void RenderingController::OnSize(Window& window, unsigned long long wParam, long long lParam)
    {
        window.DefWindowProcT(wmSize, wParam, lParam);
    }

    void RenderingController::OnMove(Window& window, unsigned short wXPos, unsigned short wYPos)
    {
        window.DefWindowProcT(wmMove, 0, MakeLong(wXPos, wYPos));
    }

    void RenderingController::OnPaint(Window& window)
    {
        window.DefWindowProcT(wmPaint, 0, 0);
    }

    void RenderingController::OnSetRedraw(Window& window, bool bRedraw)
    {
        window.DefWindowProcT(wmSetRedraw, static_cast<unsigned long long>(bRedraw ? 1 : 0), 0);
    }

    long RenderingController::OnEraseBackground(Window& window, DeviceContext& dc)
    {
        long lResult = 0;/*m_pView ? m_pView->OnEraseBackground( Window, refDC ) :
            window.DefWindowProcT( wmEraseBackground, reinterpret_cast< unsigned long long >( refDC->Handle()->Use() ), 0 );*/

        return lResult;
    }

    void RenderingController::OnSysColourChange(Window& window)
    {
    }

    void RenderingController::OnShow(Window& window, bool bShow, long long lParam)
    {
        window.DefWindowProcT(wmShowWindow, static_cast<unsigned long long>(bShow), lParam);
    }

    void RenderingController::OnGetMinMaxInfo(Window& window, MinMaxInfo* pMinMaxInfo)
    {
        window.DefWindowProcT(wmGetMinMaxInfo, 0, (long long)pMinMaxInfo);
    }

    void RenderingController::OnWindowPosChanging(Window& window, WindowPos* pWindowPos)
    {
        WindowPos WP;
        window.DefWindowProcT(wmWindowPosChanging, 0, reinterpret_cast<long long>(&WP));
    }

    void RenderingController::OnWindowPosChanged(Window& window, WindowPos* pWindowPos)
    {
        WindowPos WP;
        window.DefWindowProcT(wmWindowPosChanged, 0, reinterpret_cast<long long>(&WP));
    }

    void RenderingController::OnDisplayChange(Window& window, unsigned short wBitsPP, unsigned short hRes, unsigned short vRes)
    {
    }

    long RenderingController::OnGetIcon(Window& window, unsigned long long wParam)
    {
        long lResult = 0;//IconHandle of relevent icon
        return lResult;
    }

    long RenderingController::OnSetIcon(Window& window, unsigned long long wParam, Icon& Icon)
    {
        long lResult = 0;//Must be previous icon handle
        return lResult;
    }

    void RenderingController::OnSyncPaint(Window& window)
    {
        window.DefWindowProcT(wmSyncPaint, 0, 0);
    }

    void RenderingController::OnSizing(Window& window, unsigned long long wParam, Rect* pRect)
    {
        window.DefWindowProcT(wmSizing, 0, reinterpret_cast<long long>(pRect));
    }

    void RenderingController::OnMoving(Window& window, Rect* pRect)
    {
        window.DefWindowProcT(wmMoving, 0, reinterpret_cast<long long>(pRect));
    }

    long RenderingController::OnQueryNewPalette(Window& window)
    {
        /*The WM_QUERYNEWPALETTE message informs a window that it is about to receive
        the keyboard focus, giving the window the opportunity to realize its logical
        palette when it receives the focus. */

        /*If the window realizes its logical palette, it must return TRUE; otherwise,
        it must return FALSE.*/

        long lResult = 0;
        return lResult;
    }

    void RenderingController::OnPaletteChanging(Window& window)
    {
        /*The WM_PALETTEISCHANGING message informs applications that an application
        is going to realize its logical palette.*/
    }

    void RenderingController::OnPaletteChanged(Window& window)
    {
        /*The WM_PALETTECHANGED message is sent to all top-level and overlapped
        windows after the window with the keyboard focus has realized its logical
        palette, thereby changing the system palette. This message enables a window
        that uses a color palette but does not have the keyboard focus to realize
        its logical palette and update its client area.*/
    }

    void RenderingController::OnPrint(Window& window, DeviceContext& dc, long long lParam)
    {
        window.DefWindowProcT(wmPrint, (unsigned long long)(dc.GetHandle().Use()), lParam);
    }

    void RenderingController::OnPrintClient(Window& window, DeviceContext& dc, long long lParam)
    {
        //The WM_PRINTCLIENT message is sent to a window to request 
        //that it draw its client area in the specified device context, 
        //most commonly in a printer device context.
    }

}}}}}//qor::platform::nswindows::gui::view

