// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include "cursor.h"
#include "src/platform/os/windows/common/stringconv.h"
#include "src/platform/os/windows/api_layer/user/user32.h"
#include "point.h"

using namespace qor::nswindows::api;

namespace qor{ namespace platform { namespace nswindows{

    Cursor::Cursor(const PrimitiveHandle& h) : m_handle(h.Use()), m_bNeedsDestroy(false)
    {
        m_handle.DontClose();
    }

    Cursor::Cursor(const Cursor& src) : m_bNeedsDestroy(src.m_bNeedsDestroy),m_handle(src.m_handle)
    {
    }

    const Handle& Cursor::GetHandle() const
    {
        return m_handle;
    }
    
    Cursor::Cursor(void* hInst, int xHotSpot, int yHotSpot, int nWidth, int nHeight, const void* pvANDPlane, const void* pvXORPlane)
    {
        m_handle = User32::CreateCursor(
            reinterpret_cast<HINSTANCE>(hInst), xHotSpot, yHotSpot, nWidth, nHeight, pvANDPlane, pvXORPlane);
        m_bNeedsDestroy = true;
    }

    Cursor::Cursor(void* hInstance, const std::string& cursorName)
    {
        m_handle = User32::LoadCursorT(
            reinterpret_cast<HINSTANCE>(hInstance),
            to_tstring(cursorName.c_str()).c_str());
        m_bNeedsDestroy = false;
    }
    
    Cursor::Cursor(const std::string& fileName)
    {
        m_handle = User32::LoadCursorFromFileT(to_tstring(fileName.c_str()).c_str());
        m_bNeedsDestroy = true;
    }
    
    Cursor::~Cursor()
    {
        if(m_bNeedsDestroy)
        {
            User32::DestroyCursor(reinterpret_cast<HCURSOR>(m_handle.Use()));
        }
    }

    Cursor Cursor::Clone()
    {
        Cursor c(PrimitiveHandle(User32::CopyCursorT(
            reinterpret_cast<HCURSOR>(m_handle.Use()))));
        return c;
    }

    bool Cursor::Clip(const Rect& rect)
    {
        RECT r = {rect.m_left, rect.m_top, rect.m_right, rect.m_bottom};        
        return User32::ClipCursor(&r) ? true : false;
    }

    bool Cursor::GetClip(Rect& rect)
    {
        RECT r = {0};
        bool result = User32::GetClipCursor(&r) ? true : false;
        if(result)
        {
            rect.m_left = r.left;
            rect.m_top = r.top;
            rect.m_right = r.right;
            rect.m_bottom = r.bottom;
        }
        return result;
    }

    Cursor Cursor::GetCurrent()
    {
        PrimitiveHandle h(User32::GetCursor());
        Cursor c(h);
        return c;
    }

    bool Cursor::GetInfo(CursorInfo& ci)
    {
        ci.cbSize = sizeof(CursorInfo);
        return User32::GetCursorInfo(
            reinterpret_cast<PCURSORINFO>(&ci)) ? true : false;
    }

    bool Cursor::GetPosition(Point& point)
    {
        ::POINT p = {0};        
        bool result = User32::GetCursorPos(&p) ? true : false;
        if(result)
        {
            point.m_x = p.x;
            point.m_y = p.y;
        }
        return result;
    }

    bool Cursor::GetPhysicalPosition(Point& point)
    {
        ::POINT p = {0};        
        bool result = User32::GetPhysicalCursorPos(&p) ? true : false;
        if(result)
        {
            point.m_x = p.x;
            point.m_y = p.y;
        }
        return result;
    }

    bool Cursor::SetPosition(int x, int y)
    {
        return User32::SetCursorPos(x, y) ? true : false;
    }

    bool Cursor::SetPhysicalPosition(int x, int y)
    {
        return User32::SetPhysicalCursorPos(x, y) ? true : false;
    }

    bool Cursor::Show(bool show)
    {
        return User32::ShowCursor(show ? 1 : 0) ? true : false;
    }

    void Cursor::SetAsCurrent()
    {
        User32::SetCursor(
            reinterpret_cast<HCURSOR>(m_handle.Use()));
    }

    bool Cursor::SetAsSystemCursor(unsigned long id)
    {
        return User32::SetSystemCursor(
            reinterpret_cast<HCURSOR>(m_handle.Use()), id) ? true : false;
    }

}}}//qor::platform::nswindows
