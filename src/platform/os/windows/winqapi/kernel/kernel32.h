// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_OS_WINDOWS_API_KERNEL
#define QOR_PP_H_OS_WINDOWS_API_KERNEL

#include <Windows.h>

//Conditionally bring in extra headers on versions where they are supported
#ifndef __MINGW32__
#if( _WIN32_WINNT >= 0x0600 )
#include <WerAPI.h>
#endif
#endif//__MINGW32__



//Definitions to patch up old versions of Windows headers with the types needed so our interface can remain consistent even if not all of it is operational.
#if( _WIN32_WINNT < 0x0600 )
typedef enum _WER_REGISTER_FILE_TYPE
{
	WerRegFileTypeUserDocument = 1,
	WerRegFileTypeOther = 2,
	WerRegFileTypeMax
} WER_REGISTER_FILE_TYPE;
#endif



//Local definitions for dealing with Windows API
#define _ATXT( _X ) ( _X )
#define _AC( X ) ((char8_t)(_X))
#define _WTXT( _X ) ( L##_X )
#define _WC( _X ) ((char16_t)(_X))

#if ( qor_pp_unicode )
typedef wchar_t TCHAR;
#	define _TXT( _X ) ( _WTXT( _X ) )
#	define _C( _X ) _WC( _X )
typedef String16 String;
#else
typedef char TCHAR;
#	define _TXT( _X ) ( _ATXT( _X ) )
#	define _C( _X ) _AC( _X )
#endif

#define qor_pp_useswinapi( _MODULE, _NAME ) static const Library::DefProc pFunc = reinterpret_cast< Library::DefProc>( Kernel32::GetProcAddress( reinterpret_cast< ::HMODULE >( Kernel32::GetModuleHandle(qor_pp_stringize(_MODULE)) ), qor_pp_stringize(_NAME) ) )
#ifdef qor_pp_unicode
#	define qor_pp_useswinapiAW( _MODULE, _NAME ) qor_pp_useswinapi( _MODULE, _NAME##W )
#else
#	define qor_pp_useswinapiAW( _MODULE, _NAME ) qor_pp_useswinapi( _MODULE, _NAME##A )
#endif

namespace qor { namespace winapi {

	class qor_pp_module_interface(QOR_WINAPI) Kernel32
	{

	public:

		//Error handling functions

		static BOOL Beep(DWORD dwFreq, DWORD dwDuration);
		static USHORT RtlCaptureStackBackTrace(ULONG FramesToSkip, ULONG FramesToCapture, void** BackTrace, PULONG BackTraceHash);
		static void FatalAppExit(UINT uAction, LPCTSTR lpMessageText);
		static DWORD FormatMessage(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPTSTR lpBuffer, DWORD nSize, va_list * Arguments);
		static UINT GetErrorMode(void);
		static DWORD GetLastError(void);
		static void* RtlLookupFunctionEntry(ULONGLONG ControlPC, PULONGLONG ImageBase, PUNWIND_HISTORY_TABLE TargetGp);
		static void* RtlPcToFileHeader(void* PcValue, void** BaseOfImage);
		static void RtlUnwind(void* TargetFrame, void* TargetIp, ::PEXCEPTION_RECORD ExceptionRecord, void* ReturnValue);
		static UINT SetErrorMode(UINT uMode);
		static void SetLastError(DWORD dwErrCode);
		static HRESULT WerGetFlags(HANDLE hProcess, PDWORD pdwFlags);
		static HRESULT WerRegisterFile(PCWSTR pwzFile, ::WER_REGISTER_FILE_TYPE regFileType, DWORD dwFlags);
		static HRESULT WerRegisterMemoryBlock(void* pvAddress, DWORD dwSize);
		static HRESULT WerSetFlags(DWORD dwFlags);
		static HRESULT WerUnregisterFile(PCWSTR pwzFilePath);
		static HRESULT WerUnregisterMemoryBlock(void* pvAddress);

		//Dynamic Link Library functions

		static BOOL DisableThreadLibraryCalls(HMODULE hModule);
		static BOOL FreeLibrary(HMODULE hModule);
		static VOID FreeLibraryAndExitThread(HMODULE hModule, DWORD dwExitCode);
		static DWORD GetModuleFileName(HMODULE hModule, LPTSTR lpFilename, DWORD nSize);
		static HMODULE GetModuleHandle(LPCTSTR lpModuleName);
		static FARPROC GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
		static HMODULE LoadLibrary(LPCTSTR lpFileName);
		static HMODULE LoadLibraryEx(LPCTSTR lpFileName, HANDLE hFile, DWORD dwFlags);
		static BOOL GetModuleHandleEx(DWORD dwFlags, LPCTSTR lpModuleName, HMODULE * phModule);
		static DWORD GetDllDirectory(DWORD nBufferLength, LPTSTR lpBuffer);
		static BOOL SetDllDirectory(LPCTSTR lpPathName);

		//Handle Functions
		static BOOL CloseHandle(HANDLE hObject);
		static BOOL DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions);
		static BOOL GetHandleInformation(HANDLE hObject, LPDWORD lpdwFlags);
		static BOOL SetHandleInformation(HANDLE hObject, DWORD dwMask, DWORD dwFlags);

		//Console functions

		static BOOL AddConsoleAlias(LPTSTR Source, LPTSTR Target, LPTSTR ExeName);
		static BOOL AllocConsole(void);
		static BOOL AttachConsole(DWORD dwProcessId);
		static HANDLE CreateConsoleScreenBuffer(DWORD dwDesiredAccess, DWORD dwShareMode, const ::SECURITY_ATTRIBUTES * lpSecurityAttributes, DWORD dwFlags, void* lpScreenBufferData);
		static BOOL FillConsoleOutputAttribute(HANDLE hConsoleOutput, WORD wAttribute, DWORD nLength, ::COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten);
		static BOOL FillConsoleOutputCharacter(HANDLE hConsoleOutput, TCHAR cCharacter, DWORD nLength, ::COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten);
		static BOOL FlushConsoleInputBuffer(HANDLE hConsoleInput);
		static BOOL FreeConsole(void);
		static BOOL GenerateConsoleCtrlEvent(DWORD dwCtrlEvent, DWORD dwProcessGroupId);
		static DWORD GetConsoleAlias(LPTSTR lpSource, LPTSTR lpTargetBuffer, DWORD TargetBufferLength, LPTSTR lpExeName);
		static DWORD GetConsoleAliases(LPTSTR lpAliasBuffer, DWORD AliasBufferLength, LPTSTR lpExeName);
		static DWORD GetConsoleAliasesLength(LPTSTR lpExeName);
		static DWORD GetConsoleAliasExes(LPTSTR lpExeNameBuffer, DWORD ExeNameBufferLength);
		static DWORD GetConsoleAliasExesLength(VOID);
		static UINT GetConsoleCP(void);
		static BOOL GetConsoleCursorInfo(HANDLE hConsoleOutput, ::PCONSOLE_CURSOR_INFO lpConsoleCursorInfo);
		static BOOL GetConsoleDisplayMode(LPDWORD lpModeFlags);
		static ::COORD GetConsoleFontSize(HANDLE hConsoleOutput, DWORD nFont);
		static BOOL GetConsoleHistoryInfo(::PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo);
		static BOOL GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
		static DWORD GetConsoleOriginalTitle(LPTSTR lpConsoleTitle, DWORD nSize);
		static UINT GetConsoleOutputCP(void);
		static DWORD GetConsoleProcessList(LPDWORD lpdwProcessList, DWORD dwProcessCount);
		static BOOL GetConsoleScreenBufferInfo(HANDLE hConsoleOutput, ::PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);
		static BOOL GetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, ::PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx);
		static BOOL GetConsoleSelectionInfo(::PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo);
		static DWORD GetConsoleTitle(LPTSTR lpConsoleTitle, DWORD nSize);
		static HWND GetConsoleWindow(void);
		static BOOL GetCurrentConsoleFont(HANDLE hConsoleOutput, BOOL bMaximumWindow, ::PCONSOLE_FONT_INFO lpConsoleCurrentFont);
		static BOOL GetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, ::PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);
		static ::COORD GetLargestConsoleWindowSize(HANDLE hConsoleOutput);
		static BOOL GetNumberOfConsoleInputEvents(HANDLE hConsoleInput, LPDWORD lpcNumberOfEvents);
		static BOOL GetNumberOfConsoleMouseButtons(LPDWORD lpNumberOfMouseButtons);
		static HANDLE GetStdHandle(DWORD nStdHandle);
		static BOOL PeekConsoleInput(HANDLE hConsoleInput, ::PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);
		static BOOL ReadConsole(HANDLE hConsoleInput, void* lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, ::PCONSOLE_READCONSOLE_CONTROL pReadcontrol);
		static BOOL ReadConsoleInput(HANDLE hConsoleInput, ::PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);
		static BOOL ReadConsoleOutput(HANDLE hConsoleOutput, ::PCHAR_INFO lpBuffer, ::COORD dwBufferSize, ::COORD dwBufferCoord, ::PSMALL_RECT lpReadRegion);
		static BOOL ReadConsoleOutputAttribute(HANDLE hConsoleOutput, LPWORD lpAttribute, DWORD nLength, ::COORD dwReadCoord, LPDWORD lpNumberOfAttrsRead);
		static BOOL ReadConsoleOutputCharacter(HANDLE hConsoleOutput, LPTSTR lpCharacter, DWORD nLength, ::COORD dwReadCoord, LPDWORD lpNumberOfCharsRead);
		static BOOL ScrollConsoleScreenBuffer(HANDLE hConsoleOutput, const ::SMALL_RECT * lpScrollRectangle, const ::SMALL_RECT * lpClipRectangle, ::COORD dwDestinationOrigin, const ::CHAR_INFO * lpFill);
		static BOOL SetConsoleActiveScreenBuffer(HANDLE hConsoleOutput);
		static BOOL SetConsoleCP(UINT wCodePageID);
		static BOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE HandlerRoutine, BOOL Add);
		static BOOL SetConsoleCursorInfo(HANDLE hConsoleOutput, const ::CONSOLE_CURSOR_INFO * lpConsoleCursorInfo);
		static BOOL SetConsoleCursorPosition(HANDLE hConsoleOutput, ::COORD dwCursorPosition);
		static BOOL SetConsoleMode(HANDLE hConsoleHandle, DWORD dwMode);
		static BOOL SetConsoleDisplayMode(HANDLE hConsoleOutput, DWORD dwFlags, ::PCOORD lpNewScreenBufferDimensions);
		static BOOL SetConsoleHistoryInfo(::PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo);
		static BOOL SetConsoleOutputCP(UINT wCodePageID);
		static BOOL SetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, ::PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx);
		static BOOL SetConsoleScreenBufferSize(HANDLE hConsoleOutput, ::COORD dwSize);
		static BOOL SetConsoleTextAttribute(HANDLE hConsoleOutput, WORD wAttributes);
		static BOOL SetConsoleTitle(LPCTSTR lpConsoleTitle);
		static BOOL SetConsoleWindowInfo(HANDLE hConsoleOutput, BOOL bAbsolute, const ::SMALL_RECT * lpConsoleWindow);
		static BOOL SetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, ::PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);
		static BOOL SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
		static BOOL WriteConsoleA(HANDLE hConsoleOutput, const VOID * lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, void* lpReserved);
		static BOOL WriteConsoleW(HANDLE hConsoleOutput, const VOID * lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, void* lpReserved);
		static BOOL WriteConsoleInput(HANDLE hConsoleInput, const ::INPUT_RECORD * lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten);
		static BOOL WriteConsoleOutput(HANDLE hConsoleOutput, const ::CHAR_INFO * lpBuffer, ::COORD dwBufferSize, ::COORD dwBufferCoord, ::PSMALL_RECT lpWriteRegion);
		static BOOL WriteConsoleOutputAttribute(HANDLE hConsoleOutput, const WORD * lpAttribute, DWORD nLength, ::COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten);
		static BOOL WriteConsoleOutputCharacter(HANDLE hConsoleOutput, LPCTSTR lpCharacter, DWORD nLength, ::COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten);
		static DWORD CtrlRoutine(LPVOID lpParameter);
	};
}}//qor::winapi

#endif//QOR_PP_H_OS_WINDOWS_API_KERNEL
