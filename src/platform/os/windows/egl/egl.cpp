// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include "egl.h"
#include "display.h"
#include "window.h"
#include "src/platform/os/windows/common/stringconv.h"
#include "src/platform/os/windows/api_layer/kernel/kernel32.h"

using namespace qor::nswindows::api;

namespace qor{ bool qor_pp_module_interface(QOR_WINEGL) ImplementsEGLFeature() { return true; } }//qor

namespace qor{ namespace platform { namespace nswindows{

    /*
    Loader::Loader() : m_h(Kernel32::LoadLibrary(TEXT("libEGL.dll")))
    {
        if(!m_h.IsNull())
        {

        }
    }

    Loader::~Loader()
    {
        m_h.Close();
    }

    const Handle& Loader::GetHandle() const
    {
        return m_h;
    }
    */
    EGLDisplay EGL::StaticGetDisplay (EGLNativeDisplayType display_id)
    {
        return ::eglGetDisplay(display_id);
    }

    bool EGL::StaticChooseConfig(EGLDisplay dpy, const int32_t* attrib_list, EGLConfig* configs, int32_t config_size, int32_t* num_config)
    {
        bool result = ::eglChooseConfig(dpy, attrib_list, configs, config_size, num_config) ? true : false;
        if(!result)
        {
            auto err = ::eglGetError();
            /*EGL_BAD_DISPLAY is generated if display is not an EGL display connection.

EGL_BAD_ATTRIBUTE is generated if attribute_list contains an invalid frame buffer configuration attribute or an attribute value that is unrecognized or out of range.

EGL_NOT_INITIALIZED is generated if display has not been initialized.

EGL_BAD_PARAMETER is generated if num_config is NULL.*/
        }
        return result;
    }

    bool EGL::StaticCopyBuffers(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target)
    {
        return ::eglCopyBuffers(dpy, surface, target);
    }

    EGLContext EGL::StaticCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *attrib_list)
    {
        return ::eglCreateContext(dpy, config, share_context, attrib_list);
    }

    EGLSurface EGL::StaticCreatePbufferSurface(EGLDisplay dpy, EGLConfig config, const EGLint *attrib_list)
    {
        return ::eglCreatePbufferSurface(dpy, config, attrib_list);
    }

    EGLSurface EGL::StaticCreatePixmapSurface(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint *attrib_list)
    {
        return ::eglCreatePixmapSurface(dpy, config, pixmap, attrib_list);
    }

    EGLSurface EGL::StaticCreateWindowSurface(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint *attrib_list)
    {
        EGLSurface result = ::eglCreateWindowSurface(dpy, config, win, attrib_list);

        if(result == EGL_NO_SURFACE)
        {
            auto err = ::eglGetError();

            switch(err)
            {
                case EGL_BAD_PARAMETER:
                //Bad parameter
                case EGL_BAD_DISPLAY:
                //display is not an EGL display connection.
                break;
                case EGL_NOT_INITIALIZED:
                //display has not been initialized.
                break;
                case EGL_BAD_CONFIG:
                //config is not a valid EGL frame buffer configuration.
                break;
                case EGL_BAD_NATIVE_WINDOW:
                //native_window is not a valid native window for the same platform as display.
                break;
                case EGL_BAD_ATTRIBUTE:
                //attrib_list contains an invalid window attribute or if an attribute value is not recognized or is out of range.
                break;
                case EGL_BAD_ALLOC:
                //there is already an EGLSurface associated with native_window (as a result of a previous eglCreatePlatformWindowSurface call).
                //the implementation cannot allocate resources for the new EGL window.
                break;
                case EGL_BAD_MATCH:
                //the pixel format of native_window does not correspond to the format, type, and size of the color buffers required by config.
                //config does not support rendering to windows (the EGL_SURFACE_TYPE attribute does not contain EGL_WINDOW_BIT).
                //config does not support the specified OpenVG alpha format attribute (the value of EGL_VG_ALPHA_FORMAT is EGL_VG_ALPHA_FORMAT_PRE and the EGL_VG_ALPHA_FORMAT_PRE_BIT is not set in the EGL_SURFACE_TYPE attribute of config) or colorspace attribute (the value of EGL_VG_COLORSPACE is EGL_VG_COLORSPACE_LINEAR and the EGL_VG_COLORSPACE_LINEAR_IT is not set in the EGL_SURFACE_TYPE attribute of config).*/
                break;
                default:
                //What is it then?
                break;
            }
        }
        return result;
    }

    bool EGL::StaticDestroyContext(EGLDisplay dpy, EGLContext ctx)
    {
        return ::eglDestroyContext(dpy, ctx) ? true : false;
    }

    bool EGL::StaticDestroySurface(EGLDisplay dpy, EGLSurface surface)
    {
        return ::eglDestroySurface(dpy, surface) ? true : false;
    }

    bool EGL::StaticGetConfigAttrib(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *value)
    {
        return ::eglGetConfigAttrib(dpy, config, attribute, value) ? true : false;
    }

    bool EGL::StaticGetConfigs(EGLDisplay dpy, EGLConfig *configs, EGLint config_size, EGLint *num_config)
    {
        return ::eglGetConfigs(dpy, configs, config_size, num_config) ? true : false;
    }

    EGLDisplay EGL::StaticGetCurrentDisplay(void)
    {
        return ::eglGetCurrentDisplay();
    }

    EGLSurface EGL::StaticGetCurrentSurface(EGLint readdraw)
    {
        return ::eglGetCurrentSurface(readdraw);
    }

    EGLint EGL::StaticGetError(void)
    {
        return ::eglGetError();
    }

    __eglMustCastToProperFunctionPointerType EGL::StaticGetProcAddress(const char *procname)
    {
        return ::eglGetProcAddress(procname);
    }

    bool EGL::StaticInitialize(EGLDisplay dpy, EGLint *major, EGLint *minor)
    {
        return ::eglInitialize(dpy, major, minor) ? true : false;
    }

    bool EGL::StaticMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx)
    {
        return ::eglMakeCurrent(dpy, draw, read, ctx) ? true : false;
    }

    bool EGL::StaticQueryContext(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint *value)
    {
        return ::eglQueryContext(dpy, ctx, attribute, value) ? true : false;
    }

    const char* EGL::StaticQueryString(EGLDisplay dpy, EGLint name)
    {
        return ::eglQueryString(dpy, name);
    }

    bool EGL::StaticQuerySurface(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint *value)
    {
        return ::eglQuerySurface(dpy, surface, attribute, value) ? true : false;
    }

    bool EGL::StaticSwapBuffers(EGLDisplay dpy, EGLSurface surface)
    {
        return ::eglSwapBuffers(dpy, surface);
    }

    bool EGL::StaticTerminate(EGLDisplay dpy)
    {
        return ::eglTerminate(dpy) ? true : false;
    }
    
    bool EGL::StaticWaitGL(void)
    {
        return ::eglWaitGL() ? true : false;
    }

    bool EGL::StaticWaitNative(EGLint engine)
    {
        return ::eglWaitNative(engine) ? true : false;
    }

    bool EGL::StaticBindTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer)
    {
        return ::eglBindTexImage(dpy, surface, buffer) ? true : false;
    }

    bool EGL::StaticReleaseTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer)
    {
        return ::eglReleaseTexImage(dpy, surface, buffer) ? true : false;
    }

    bool EGL::StaticSurfaceAttrib(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value)
    {
        return ::eglSurfaceAttrib(dpy, surface, attribute, value) ? true : false;
    }

    bool EGL::StaticSwapInterval(EGLDisplay dpy, EGLint interval)
    {
        return ::eglSwapInterval(dpy, interval) ? true : false;
    }

    bool EGL::StaticBindAPI(EGLenum api)
    {
        return ::eglBindAPI(api) ? true : false;
    }

    EGLenum EGL::StaticQueryAPI(void)
    {
        return ::eglQueryAPI();
    }

    EGLSurface EGL::StaticCreatePbufferFromClientBuffer(EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint *attrib_list)
    {
        return ::eglCreatePbufferFromClientBuffer(dpy, buftype, buffer, config, attrib_list);
    }

    bool EGL::StaticReleaseThread(void)
    {
        return ::eglReleaseThread() ? true : false;
    }

    bool EGL::StaticWaitClient(void)
    {
        return ::eglWaitClient() ? true : false;
    }

    EGLContext EGL::StaticGetCurrentContext(void)
    {
        return ::eglGetCurrentContext();
    }

    EGLSync EGL::StaticCreateSync(EGLDisplay dpy, EGLenum type, const EGLAttrib *attrib_list)
    {
        return ::eglCreateSync(dpy, type, attrib_list);
    }

    bool EGL::StaticDestroySync(EGLDisplay dpy, EGLSync sync)
    {
        return ::eglDestroySync(dpy, sync) ? true : false;
    }

    EGLint EGL::StaticClientWaitSync(EGLDisplay dpy, EGLSync sync, EGLint flags, EGLTime timeout)
    {
        return ::eglClientWaitSync(dpy, sync, flags, timeout);
    }

    bool EGL::StaticGetSyncAttrib(EGLDisplay dpy, EGLSync sync, EGLint attribute, EGLAttrib *value)
    {
        return ::eglGetSyncAttrib(dpy, sync, attribute, value) ? true : false;
    }

    EGLImage EGL::StaticCreateImage(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLAttrib *attrib_list)
    {
        return ::eglCreateImage(dpy, ctx, target, buffer, attrib_list);
    }

    bool EGL::StaticDestroyImage(EGLDisplay dpy, EGLImage image)
    {
        return ::eglDestroyImage(dpy, image);
    }

    EGLDisplay EGL::StaticGetPlatformDisplay(EGLenum platform, void *native_display, const EGLAttrib *attrib_list)
    {
        return ::eglGetPlatformDisplay(platform, native_display, attrib_list);
    }

    EGLSurface EGL::StaticCreatePlatformWindowSurface(EGLDisplay dpy, EGLConfig config, void *native_window, const EGLAttrib *attrib_list)
    {
        return ::eglCreatePlatformWindowSurface(dpy, config, native_window, attrib_list);
    }

    EGLSurface EGL::StaticCreatePlatformPixmapSurface(EGLDisplay dpy, EGLConfig config, void *native_pixmap, const EGLAttrib *attrib_list)
    {
        return ::eglCreatePlatformPixmapSurface(dpy, config, native_pixmap, attrib_list);
    }

    bool EGL::StaticWaitSync(EGLDisplay dpy, EGLSync sync, EGLint flags)
    {
        return ::eglWaitSync(dpy, sync, flags);
    }
    
    bool EGL::ReleaseThread(void)
    {
        return EGL::StaticReleaseThread();
    }

    bool EGL::WaitClient(void)
    {
        return EGL::StaticWaitClient();
    }

    void* EGL::GetCurrentContext(void)
    {
        return EGL::StaticGetCurrentContext();
    }

    bool EGL::BindAPI(unsigned int api)
    {
        return EGL::StaticBindAPI(api);
    }

    unsigned int EGL::QueryAPI(void)
    {
        return EGL::StaticQueryAPI();
    }

    bool EGL::WaitGL(void)
    {
        return EGL::StaticWaitGL();
    }

    bool EGL::WaitNative(int32_t engine)
    {
        return EGL::StaticWaitNative(engine);
    }

    void* EGL::GetCurrentDisplay(void)
    {
        return EGL::StaticGetCurrentDisplay();
    }

    void* EGL::GetCurrentSurface(int32_t readdraw)
    {
        return EGL::StaticGetCurrentSurface(readdraw);
    }

    int32_t EGL::GetError(void)
    {
        return EGL::StaticGetError();
    }

    ref_of<qor::components::EGLDisplay>::type EGL::CreateDisplay()
    {
        return new_ref<EglDisplay>();
    }

    ref_of<qor::components::EGLDisplay>::type EGL::CreateDisplay(void* nativeDisplay)
    {
        return new_ref<EglDisplay>(nativeDisplay);
    }

    ref_of<qor::components::EGLDisplay>::type EGL::CreateDisplay(unsigned int platform, void* nativeDisplay, const intptr_t* attrib_list)
    {
        return new_ref<EglDisplay>(platform, nativeDisplay, attrib_list);
    }

    ref_of<qor::components::EGLWindow>::type EGL::CreateNativeWindow(ref_of<qor::components::EGLDisplay>::type display, ref_of<qor::components::EGLContext>::type context, const std::string& title, int width, int height)
    {
        return new_ref<EglWindow>(display, context, title, width, height);
    }

}}}//qor::platform::nswindows
