// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include <optional>

#include "src/qor/injection/typeidentity.h"
#include "src/qor/objectcontext/anyobject.h"
#include "src/framework/thread/currentthread.h"
#include "src/qor/reference/newref.h"
#include "currentthread.h"
#include <bit>
#include <windows.h>
#include <processthreadsapi.h>
#include <stringapiset.h>

//Implement this trivial function so the linker will pull in this library to fulfil the ImplementsICurrentThread requirement. 
namespace qor{ bool qor_pp_module_interface(QOR_WINDOWSTHREAD) ImplementsICurrentThread() {return true;} }

namespace qor{ namespace nsWindows{ namespace framework{

    bool CurrentThread::SetPriority(ICurrentThread::Priority priority)
    {
        int OSPriority = THREAD_PRIORITY_NORMAL;
        switch(priority)
        {
            case ICurrentThread::Priority::above_normal:
            OSPriority = THREAD_PRIORITY_ABOVE_NORMAL;
            break;
            case ICurrentThread::Priority::below_normal:
            OSPriority = THREAD_PRIORITY_BELOW_NORMAL;
            break;
            case ICurrentThread::Priority::highest:
            OSPriority = THREAD_PRIORITY_HIGHEST;
            break;
            case ICurrentThread::Priority::idle:
            OSPriority = THREAD_PRIORITY_IDLE;
            break;
            case ICurrentThread::Priority::lowest:
            OSPriority = THREAD_PRIORITY_LOWEST;
            break;
            case ICurrentThread::Priority::normal:
            OSPriority = THREAD_PRIORITY_NORMAL;
            break;
            case ICurrentThread::Priority::realtime:
            OSPriority = THREAD_PRIORITY_TIME_CRITICAL;
            break;
        }
        return SetThreadPriority(GetCurrentThread(), static_cast<int>(OSPriority)) != 0;
    }

    std::optional< qor::framework::ICurrentThread::Priority > CurrentThread::GetPriority() const
    {
        const int priority = GetThreadPriority(GetCurrentThread());

        switch(priority)
        {
            case THREAD_PRIORITY_ABOVE_NORMAL:
                return ICurrentThread::Priority::above_normal;
            case THREAD_PRIORITY_BELOW_NORMAL:
                return ICurrentThread::Priority::below_normal;
            case THREAD_PRIORITY_HIGHEST:
                return ICurrentThread::Priority::highest;
            case THREAD_PRIORITY_IDLE:
            return ICurrentThread::Priority::idle;
            case THREAD_PRIORITY_LOWEST:
                return ICurrentThread::Priority::lowest;
            case THREAD_PRIORITY_NORMAL:
                return ICurrentThread::Priority::normal;
            case THREAD_PRIORITY_TIME_CRITICAL:
                return ICurrentThread::Priority::realtime;
            default:
               return std::nullopt;
        }        
    }

    bool CurrentThread::SetName(const std::string& name)
    {
        // On Windows thread names are wide strings, so we need to convert them from normal strings.
        const int size = MultiByteToWideChar(CP_UTF8, 0, name.data(), -1, nullptr, 0);
        if (size == 0)
        {
            return false;
        }
        std::wstring wide(static_cast<std::size_t>(size), 0);
        if (MultiByteToWideChar(CP_UTF8, 0, name.data(), -1, wide.data(), size) == 0)
        {
            return false;
        }
        const HRESULT hr = SetThreadDescription(GetCurrentThread(), wide.data());
        return SUCCEEDED(hr);
    }

    std::optional<std::string> CurrentThread::GetName()
    {
        // On Windows thread names are wide strings, so we need to convert them to normal strings.
        PWSTR data = nullptr;
        const HRESULT hr = GetThreadDescription(GetCurrentThread(), &data);
        if (FAILED(hr))
        {
            return std::nullopt;
        }
        if (data == nullptr)
        {
            return std::nullopt;
        }
        const int size = WideCharToMultiByte(CP_UTF8, 0, data, -1, nullptr, 0, nullptr, nullptr);
        if (size == 0)
        {
            LocalFree(data);
            return std::nullopt;
        }
        std::string name(static_cast<std::size_t>(size) - 1, 0);
        const int result = WideCharToMultiByte(CP_UTF8, 0, data, -1, name.data(), size, nullptr, nullptr);
        LocalFree(data);
        if (result == 0)
        {
            return std::nullopt;
        }
        return name;
    }

    bool CurrentThread::SetAffinity(const std::vector<bool>& affinity)
    {
        DWORD_PTR thread_mask = 0;
        for (std::size_t i = 0; i < std::min<std::size_t>(affinity.size(), sizeof(DWORD_PTR) * 8); ++i)
        {
            thread_mask |= (affinity[i] ? (1ULL << i) : 0ULL);
        }
        return SetThreadAffinityMask(GetCurrentThread(), thread_mask) != 0;
    }

    std::optional<std::vector<bool>> CurrentThread::GetAffinity()
    {
        // Windows does not have a `GetThreadAffinityMask()` function, but `SetThreadAffinityMask()` returns the previous affinity mask, so we can use that to get the current affinity and then restore it. It's a bit of a hack, but it works. Since the thread affinity must be a subset of the process affinity, we use the process affinity as the temporary value.
        DWORD_PTR process_mask = 0;
        DWORD_PTR system_mask = 0;
        if (GetProcessAffinityMask(GetCurrentProcess(), &process_mask, &system_mask) == 0)
        {
            return std::nullopt;
        }
        const DWORD_PTR previous_mask = SetThreadAffinityMask(GetCurrentThread(), process_mask);
        if (previous_mask == 0)
        {
            return std::nullopt;
        }
        SetThreadAffinityMask(GetCurrentThread(), previous_mask);
#ifdef __cpp_lib_int_pow2
        const std::size_t num_cpus = static_cast<std::size_t>(std::bit_width(system_mask));
#else
        std::size_t num_cpus = 0;
        if (system_mask != 0)
        {
            num_cpus = 1;
            while ((system_mask >>= 1U) != 0U)
                ++num_cpus;
        }
#endif
        std::vector<bool> affinity(num_cpus);
        for (std::size_t i = 0; i < num_cpus; ++i)
        {
            affinity[i] = ((previous_mask & (1ULL << i)) != 0ULL);
        }
        return affinity;
    }

}}}//qor::nsWindows::framework
