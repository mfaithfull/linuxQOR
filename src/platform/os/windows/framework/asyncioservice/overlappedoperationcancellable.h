// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_OS_WINDOWS_FRAMEWORK_ASYNCIOSERVICE_IOCP_OVERLAPPEDOPERATIONCANCELLABLE
#define QOR_PP_H_OS_WINDOWS_FRAMEWORK_ASYNCIOSERVICE_IOCP_OVERLAPPEDOPERATIONCANCELLABLE

#include <system_error>
#include <coroutine>
#include <optional>
#include <atomic>
#include "overlappedoperationbase.h"
#include "src/framework/task/cancellation/cancellationtoken.h"
#include "src/framework/task/cancellation/cancellationregistration.h"
#include "src/framework/task/cancellation/operationcancelled.h"

namespace qor { namespace framework { namespace nswindows {

	template<typename OPERATION>
	class win32_overlapped_operation_cancellable : protected win32_overlapped_operation_base
	{
		// ERROR_OPERATION_ABORTED value from <Windows.h>
		static constexpr dword_t error_operation_aborted = 995L;

	protected:

		win32_overlapped_operation_cancellable(CancellationToken&& ct) noexcept
			: win32_overlapped_operation_base(&win32_overlapped_operation_cancellable::on_operation_completed)
			, m_state(ct.is_cancellation_requested() ? state::completed : state::not_started)
			, m_cancellationToken(std::move(ct))
		{
			m_errorCode = error_operation_aborted;
		}

		win32_overlapped_operation_cancellable(
			void* pointer,
			CancellationToken&& ct) noexcept
			: win32_overlapped_operation_base(pointer, &win32_overlapped_operation_cancellable::on_operation_completed)
			, m_state(ct.is_cancellation_requested() ? state::completed : state::not_started)
			, m_cancellationToken(std::move(ct))
		{
			m_errorCode = error_operation_aborted;
		}

		win32_overlapped_operation_cancellable(
			std::uint64_t offset,
			CancellationToken&& ct) noexcept
			: win32_overlapped_operation_base(offset, &win32_overlapped_operation_cancellable::on_operation_completed)
			, m_state(ct.is_cancellation_requested() ? state::completed : state::not_started)
			, m_cancellationToken(std::move(ct))
		{
			m_errorCode = error_operation_aborted;
		}

		win32_overlapped_operation_cancellable(
			win32_overlapped_operation_cancellable&& other) noexcept
			: win32_overlapped_operation_base(std::move(other))
			, m_state(other.m_state.load(std::memory_order_relaxed))
			, m_cancellationToken(std::move(other.m_cancellationToken))
		{
			assert(m_errorCode == other.m_errorCode);
			assert(m_numberOfBytesTransferred == other.m_numberOfBytesTransferred);
		}

	public:

		bool await_ready() const noexcept
		{
			return m_state.load(std::memory_order_relaxed) == state::completed;
		}

		qor_pp_noinline bool await_suspend(std::coroutine_handle<> awaitingCoroutine)
		{
			static_assert(std::is_base_of_v<win32_overlapped_operation_cancellable, OPERATION>);

			m_awaitingCoroutine = awaitingCoroutine;

			// TRICKY: Register cancellation callback before starting the operation
			// in case the callback registration throws due to insufficient
			// memory. We need to make sure that the logic that occurs after
			// starting the operation is noexcept, otherwise we run into the
			// problem of not being able to cancel the started operation and
			// the dilemma of what to do with the exception.
			//
			// However, doing this means that the cancellation callback may run
			// prior to returning below so in the case that cancellation may
			// occur we defer setting the state to 'started' until after
			// the operation has finished starting. The cancellation callback
			// will only attempt to request cancellation of the operation with
			// CancelIoEx() once the state has been set to 'started'.
			const bool canBeCancelled = m_cancellationToken.can_be_cancelled();
			if (canBeCancelled)
			{
				m_cancellationCallback.emplace(
					std::move(m_cancellationToken),
					[this] { this->on_cancellation_requested(); });
			}
			else
			{
				m_state.store(state::started, std::memory_order_relaxed);
			}

			// Now start the operation.
			const bool willCompleteAsynchronously = static_cast<OPERATION*>(this)->try_start();
			if (!willCompleteAsynchronously)
			{
				// Operation completed synchronously, resume awaiting coroutine immediately.
				return false;
			}

			if (canBeCancelled)
			{
				// Need to flag that the operation has finished starting now.

				// However, the operation may have completed concurrently on
				// another thread, transitioning directly from not_started -> complete.
				// Or it may have had the cancellation callback execute and transition
				// from not_started -> cancellation_requested. We use a compare-exchange
				// to determine a winner between these potential racing cases.
				state oldState = state::not_started;
				if (!m_state.compare_exchange_strong(
					oldState,
					state::started,
					std::memory_order_release,
					std::memory_order_acquire))
				{
					if (oldState == state::cancellation_requested)
					{
						// Request the operation be cancelled.
						// Note that it may have already completed on a background
						// thread by now so this request for cancellation may end up
						// being ignored.
						static_cast<OPERATION*>(this)->cancel();

						if (!m_state.compare_exchange_strong(
							oldState,
							state::started,
							std::memory_order_release,
							std::memory_order_acquire))
						{
							assert(oldState == state::completed);
							return false;
						}
					}
					else
					{
						assert(oldState == state::completed);
						return false;
					}
				}
			}

			return true;
		}

		decltype(auto) await_resume()
		{
			// Free memory used by the cancellation callback now that the operation
			// has completed rather than waiting until the operation object destructs.
			// eg. If the operation is passed to when_all() then the operation object
			// may not be destructed until all of the operations complete.
			m_cancellationCallback.reset();

			if (m_errorCode == error_operation_aborted)
			{
				throw operation_cancelled{};
			}

			return static_cast<OPERATION*>(this)->get_result();
		}

	private:

		enum class state
		{
			not_started,
			started,
			cancellation_requested,
			completed
		};

		void on_cancellation_requested() noexcept
		{
			auto oldState = m_state.load(std::memory_order_acquire);
			if (oldState == state::not_started)
			{
				// This callback is running concurrently with await_suspend().
				// The call to start the operation may not have returned yet so
				// we can't safely request cancellation of it. Instead we try to
				// notify the await_suspend() thread by transitioning the state
				// to state::cancellation_requested so that the await_suspend()
				// thread can request cancellation after it has finished starting
				// the operation.
				const bool transferredCancelResponsibility =
					m_state.compare_exchange_strong(
						oldState,
						state::cancellation_requested,
						std::memory_order_release,
						std::memory_order_acquire);
				if (transferredCancelResponsibility)
				{
					return;
				}
			}

			// No point requesting cancellation if the operation has already completed.
			if (oldState != state::completed)
			{
				static_cast<OPERATION*>(this)->cancel();
			}
		}

		static void on_operation_completed(
			io_state* ioState,
			dword_t errorCode,
			dword_t numberOfBytesTransferred,
			[[maybe_unused]] ulongptr_t completionKey) noexcept
		{
			auto* operation = static_cast<win32_overlapped_operation_cancellable*>(ioState);

			operation->m_errorCode = errorCode;
			operation->m_numberOfBytesTransferred = numberOfBytesTransferred;

			auto state = operation->m_state.load(std::memory_order_acquire);
			if (state == state::started)
			{
				operation->m_state.store(state::completed, std::memory_order_relaxed);
				operation->m_awaitingCoroutine.resume();
			}
			else
			{
				// We are racing with await_suspend() call suspending.
				// Try to mark it as completed using an atomic exchange and look
				// at the previous value to determine whether the coroutine suspended
				// first (in which case we resume it now) or we marked it as completed
				// first (in which case await_suspend() will return false and immediately
				// resume the coroutine).
				state = operation->m_state.exchange(
					state::completed,
					std::memory_order_acq_rel);
				if (state == state::started)
				{
					// The await_suspend() method returned (or will return) 'true' and so
					// we need to resume the coroutine.
					operation->m_awaitingCoroutine.resume();
				}
			}
		}

		std::atomic<state> m_state;
		CancellationToken m_cancellationToken;
		std::optional<CancellationRegistration> m_cancellationCallback;
		std::coroutine_handle<> m_awaitingCoroutine;

	};
}}}//qor::framework::windows

#endif//QOR_PP_H_OS_WINDOWS_FRAMEWORK_ASYNCIOSERVICE_IOCP_OVERLAPPEDOPERATIONCANCELLABLE
