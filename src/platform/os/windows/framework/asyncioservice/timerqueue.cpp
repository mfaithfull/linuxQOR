// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include <algorithm>
#include <cassert>
#include <chrono>
#include "timerqueue.h"
#include "timedscheduleoperation.h"

namespace qor { namespace framework { namespace nswindows {

    TimerQueue::TimerEntry::TimerEntry(TimedScheduleOperation* timer) : 
                m_dueTime(timer->m_resumeTime), m_timer(timer)
    {}

    TimerQueue::TimerQueue() noexcept
        : m_timerEntries(), m_overflowTimers(nullptr)
    {}        

    TimerQueue::~TimerQueue()
    {
        assert(IsEmpty());
    }

    bool TimerQueue::IsEmpty() const noexcept
    {
        return m_timerEntries.empty() && m_overflowTimers == nullptr;
    }

    std::chrono::high_resolution_clock::time_point TimerQueue::EarliestDueTime() const noexcept
    {
        if(!m_timerEntries.empty())
        {
            if(m_overflowTimers != nullptr)
            {
                return std::min(
                    m_timerEntries.front().m_dueTime,
                    m_overflowTimers->m_resumeTime
                );
            }

            return m_timerEntries.front().m_dueTime;
        }
        else if(m_overflowTimers != nullptr)
        {
            return m_overflowTimers->m_resumeTime;
        }

        return TimePoint::max();
    }

    void TimerQueue::EnqueueTimer(TimedScheduleOperation* timer) noexcept
    {
        try
        {
            m_timerEntries.emplace_back(timer);
            std::push_heap(m_timerEntries.begin(), m_timerEntries.end(), CompareEntries);
        }
        catch(...)
        {
            const auto& newDueTime = timer->m_resumeTime;
            auto** current = &m_overflowTimers;
            while((*current) != nullptr && (*current)->m_resumeTime <= newDueTime)
            {
                current = &(*current)->m_next;
            }
            timer->m_next = *current;
            *current = timer;
        }
        
    }

    void TimerQueue::DequeueDueTimers(TimePoint currentTime, TimedScheduleOperation*& timerList) noexcept
    {
        while(!m_timerEntries.empty() && m_timerEntries.front().m_dueTime <= currentTime)
        {
            auto* timer = m_timerEntries.front().m_timer;
            std::pop_heap(m_timerEntries.begin(), m_timerEntries.end(), CompareEntries);
            m_timerEntries.pop_back();
            timer->m_next = timerList;
            timerList = timer;
        }

        while(m_overflowTimers != nullptr && m_overflowTimers->m_resumeTime <= currentTime)        
        {
            auto* timer = m_overflowTimers;
            m_overflowTimers = timer->m_next;
            timer->m_next = timerList;
            timerList = timer;
        }
    }

    void TimerQueue::RemoveCancelledTimers(TimedScheduleOperation*& timerList) noexcept
    {
        //linear scan checking for cancellation requests

        const auto AddTimerToList = [&](TimedScheduleOperation* timer)
            {
                timer->m_next = timerList;
                timerList = timer;
            };

        const auto IsTimerCancelled = [](const TimerEntry& entry)
            {
                return entry.m_timer->m_cancellationToken.is_cancellation_requested();
            };

        auto firstCancelledEntry = std::find_if(
            m_timerEntries.begin(),
            m_timerEntries.end(),
            IsTimerCancelled);
        
        if(firstCancelledEntry != m_timerEntries.end())
        {
            auto nonCancelledEnd = firstCancelledEntry;
            AddTimerToList(nonCancelledEnd->m_timer);

            for(auto iter = firstCancelledEntry + 1;
                iter != m_timerEntries.end();
                ++iter)
            {
                if(IsTimerCancelled(*iter))
                {
                    AddTimerToList(iter->m_timer);
                }
                else
                {
                    *nonCancelledEnd++ = std::move(*iter);
                }
            }

            m_timerEntries.erase(nonCancelledEnd, m_timerEntries.end());

            std::make_heap( m_timerEntries.begin(), m_timerEntries.end(), CompareEntries);
        }

        {
            TimedScheduleOperation** current = &m_overflowTimers;
            while((*current) != nullptr)
            {
                auto* timer = (*current);
                if(timer->m_cancellationToken.is_cancellation_requested())
                {
                    *current = timer->m_next;
                    AddTimerToList(timer);
                }
                else
                {
                    current = &timer->m_next;
                }
            }
        }
    }

}}}//qor::framework//nswindows