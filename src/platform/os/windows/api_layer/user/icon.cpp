// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"
#include "src/qor/module/module.h"
#include "src/qor/interception/functioncontext.h"
#include "src/qor/error/error.h"

//Windows specific headers must be last to prevent contaminating generic headers with Windows specific types and definitions
#include "user32.h"
#include "../returncheck.h"
#include "../library.h"

namespace qor { namespace nswindows { namespace api {

    HICON User32::CopyIcon(HICON hIcon)
    {
        qor_pp_fcontext;
        qor_pp_useswinapi(user32, CopyIcon);
        return Library::Call<HICON, HICON>(pFunc, hIcon);
    }

    HICON User32::CreateIcon(HINSTANCE hInstance, int nWidth, int nHeight, BYTE cPlanes, BYTE cBitsPixel, const BYTE* lpbANDbits, const BYTE* lpbXORbits)
    {
        qor_pp_fcontext;
        qor_pp_useswinapi(user32, CreateIcon);
        return Library::Call<HICON, HINSTANCE, int, int, BYTE, BYTE, const BYTE*, const BYTE*>(pFunc, hInstance, nWidth, nHeight, cPlanes, cBitsPixel, lpbANDbits, lpbXORbits);
    }

    HICON User32::CreateIconFromResource(PBYTE presbits, DWORD dwResSize, BOOL fIcon, DWORD dwVer)
    {
        qor_pp_fcontext;
        qor_pp_useswinapi(user32, CreateIconFromResource);
        return Library::Call<HICON, PBYTE, DWORD, BOOL, DWORD>(pFunc, presbits, dwResSize, fIcon, dwVer);        
    }

    HICON User32::CreateIconFromResourceEx(PBYTE pbIconBits, DWORD cbIconBits, BOOL fIcon, DWORD dwVersion, int cxDesired, int cyDesired, UINT uFlags)
    {
        qor_pp_fcontext;
        qor_pp_useswinapi(user32, CreateIconFromResourceEx);
        return Library::Call<HICON, PBYTE, DWORD, BOOL, DWORD, int, int, UINT>(pFunc, pbIconBits, cbIconBits, fIcon, dwVersion, cxDesired, cyDesired, uFlags);        
    }

    HICON User32::CreateIconIndirect(const ::ICONINFO* piconinfo)
    {
        qor_pp_fcontext;
        qor_pp_useswinapi(user32, CreateIconIndirect);
        return Library::Call<HICON, const ICONINFO*>(pFunc, piconinfo);
    }

    BOOL User32::DestroyIcon(HICON hIcon)
    {
        qor_pp_fcontext;
        qor_pp_useswinapi(user32, DestroyIcon);
        return Library::Call<BOOL, HICON>(pFunc, hIcon);
    }

    BOOL User32::DrawIcon(HDC hDC, int X, int Y, HICON hIcon)
    {
        qor_pp_fcontext;
        qor_pp_useswinapi(user32, DrawIcon);
        return Library::Call<BOOL, HDC, int, int, HICON>(pFunc, hDC, X, Y, hIcon);
    }

    BOOL User32::DrawIconEx(HDC hdc, int xLeft, int yTop, HICON hIcon, int cxWidth, int cyWidth, UINT istepIfAniCur, HBRUSH hbrFlickerFreeDraw, UINT diFlags)
    {
        qor_pp_fcontext;
        qor_pp_useswinapi(user32, DrawIconEx);
        return Library::Call<BOOL, HDC, int, int, HICON, int, int, UINT, HBRUSH, UINT>(pFunc, hdc, xLeft, yTop, hIcon, cxWidth, cyWidth, istepIfAniCur, hbrFlickerFreeDraw, diFlags);
    }

    BOOL User32::GetIconInfo(HICON hIcon, ::PICONINFO piconinfo)
    {
        qor_pp_fcontext;
        qor_pp_useswinapi(user32, GetIconInfo);
        return Library::Call<BOOL, HICON, ::PICONINFO>(pFunc, hIcon, piconinfo);
    }

    BOOL User32::GetIconInfoExT(HICON hIcon, ::PICONINFOEX piconinfoex)
    {
        qor_pp_fcontext;
        qor_pp_useswinapiAW(user32, GetIconInfoEx);
        return Library::Call<BOOL, HICON, ::PICONINFOEX>(pFunc, hIcon, piconinfoex);        
    }

    HICON User32::LoadIconT(HINSTANCE hInstance, LPCTSTR lpIconName)
    {
        qor_pp_fcontext;
        qor_pp_useswinapiAW(user32, LoadIcon);
        return Library::Call<HICON, HINSTANCE, LPCTSTR>(pFunc, hInstance, lpIconName);
    }

    int User32::LookupIconIdFromDirectory(PBYTE presbits, BOOL fIcon)
    {
        qor_pp_fcontext;
        qor_pp_useswinapi(user32, LookupIconIdFromDirectory);
        return Library::Call<int, PBYTE, BOOL>(pFunc, presbits, fIcon);
    }

    int User32::LookupIconIdFromDirectoryEx(PBYTE presbits, BOOL fIcon, int cxDesired, int cyDesired, UINT Flags)
    {
        qor_pp_fcontext;
        qor_pp_useswinapi(user32, LookupIconIdFromDirectoryEx);
        return Library::Call<int, PBYTE, BOOL, int, int, UINT>(pFunc, presbits, fIcon, cxDesired, cyDesired, Flags);
    }

    UINT User32::PrivateExtractIconsT(LPCTSTR lpszFile, int nIconIndex, int cxIcon, int cyIcon, HICON* phicon, UINT* piconid, UINT nIcons, UINT flags)
    {
        qor_pp_fcontext;
        qor_pp_useswinapiAW(user32, PrivateExtractIcons);
        return Library::Call<UINT, LPCTSTR, int, int, int, HICON*, UINT*, UINT, UINT>(pFunc, lpszFile, nIconIndex, cxIcon, cyIcon, phicon, piconid, nIcons, flags);
    }

}}}//qor::nswindows::api