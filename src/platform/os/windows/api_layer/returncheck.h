// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/qor/error/error.h"

namespace qor { namespace nswindows { namespace api {

	//Generic validated return value class
	//TReturn is the type of the return value
	//TCheck is the type of validation check to be performed
	template<class TReturn, class TCheck >
	class CheckReturn
	{
	public:

#if		( qor_pp_parameter_checking == qor_pp_yes )
		typedef CheckReturn< TReturn, TCheck > TType;
#else
		typedef TReturn TType;
#endif

		CheckReturn() : m_bInitialised(false)
		{
			TCheck AutoCheck;
			TCheck::Init(m_Param, &AutoCheck);
		}

		CheckReturn(TReturn param) : m_Param(param), m_bInitialised(true)
		{
			TCheck AutoCheck;
			TCheck::Check(m_Param, &AutoCheck);
		}

		CheckReturn& operator = (TReturn& value)
		{
			m_Param = value;
			m_bInitialised = true;
			TCheck AutoCheck;
			TCheck::Check(m_Param, &AutoCheck);
			return *this;
		}

		operator TReturn()
		{
			if (!m_bInitialised)
			{
				continuable("Uninitialised parameter error");
			}
			return m_Param;
		}

	protected:

		TReturn m_Param;			//Instance of parameter type

	private:

		bool m_bInitialised;
	};
	
	template< typename TValue >
	class AutoErrorCheck
	{
	public:

		AutoErrorCheck() = default;
		virtual ~AutoErrorCheck()= default;

		virtual bool Test(TValue& value)
		{
			return false;
		}

		virtual void DefaultInit(TValue& value)
		{
		}

		static void Check(TValue& value, AutoErrorCheck* pInstance)
		{
			if (!pInstance->Test(value))
			{
				continuable("A checked parameter failed a test");
			}
		}

		static void Init(TValue& value, AutoErrorCheck* pInstance)
		{
			pInstance->DefaultInit(value);
		}
	};

	
	class BoolCheck : public AutoErrorCheck< BOOL >
	{
	public:

	
		virtual bool Test(BOOL& value)
		{
			return value ? true : false;
		}

	
		virtual void DefaultInit(BOOL& value)
		{
			value = 0;
		}
	};

	
	class HandleCheck : public AutoErrorCheck< HANDLE >
	{
	public:

	
		virtual bool Test(HANDLE& value)
		{
			return (value == (HANDLE)((size_t)(-1))) ? false : true;
		}
	};

	
	class HandleNullCheck : public AutoErrorCheck< HANDLE >
	{
	public:

	
		virtual bool Test(HANDLE& value)
		{
			return (value == (HANDLE)((size_t)(-1)) || value == (HANDLE)(size_t)(0)) ? false : true;
		}
	};

	
	template< typename THandle >
	class CheckNonZeroHandle : public AutoErrorCheck< THandle >
	{
	public:

	
		virtual bool Test(THandle& value)
		{
			return (value == 0x00000000) ? false : true;
		}
	};

	
	class SuccessCheck : public AutoErrorCheck< intptr_t >
	{
	public:

	
		virtual bool Test(intptr_t& value)
		{
			return (value == 0) ? true : false;
		}
	};

	
	class LongSuccessCheck : public AutoErrorCheck< long >
	{
	public:

	
		virtual bool Test(intptr_t& value)
		{
			return (value == 0) ? true : false;
		}
	};

	
	template< typename TNumeric >
	class TSuccessCheck : public AutoErrorCheck< TNumeric >
	{
	public:

	
		virtual bool Test(TNumeric& value)
		{
			return (value == 0) ? true : false;
		}
	};

	
	template< typename TNumeric >
	class CheckNonZero : public AutoErrorCheck< TNumeric >
	{
	public:

	
		virtual bool Test(TNumeric& value)
		{
			return (value == 0) ? false : true;
		}
	};

	
	template< int iFailure >
	class CheckFailureInt : public AutoErrorCheck< int >
	{
	public:

	
		virtual bool Test(int& value)
		{
			return (value == iFailure) ? false : true;
		}
	};

	
	template< typename TFailure, TFailure iFailure >
	class TCheckFailureValue : public AutoErrorCheck< TFailure >
	{
	public:

	
		virtual void DefaultInit(TFailure& value)
		{
			value = iFailure;
		}

	
		virtual bool Test(TFailure& value)
		{
			return (value == iFailure) ? false : true;
		}
	};

	
	template< typename TReturn, TReturn Min, TReturn Max >
	class TRangeCheck : public AutoErrorCheck< TReturn >
	{
	public:

	
		virtual void DefaultInit(TReturn& value)
		{
			value = Min - 1;
		}

	
		virtual bool Test(TReturn& value)
		{
			return (value >= Min && value <= Max) ? true : false;
		}
	};

	
	template< typename TReturn, TReturn Min >
	class TCheckNotLess : public AutoErrorCheck< TReturn >
	{
	public:

		
		virtual void DefaultInit(TReturn& value)
		{
			value = Min - 1;
		}

		
		virtual bool Test(TReturn& value)
		{
			return (value < Min) ? false : true;
		}
	};

}}}//qor:nswindows::api
