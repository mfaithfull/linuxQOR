// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_PP_H_OS_WINDOWS_API_KERNEL
#define QOR_PP_H_OS_WINDOWS_API_KERNEL

#if qor_pp_unicode
#	define UNICODE 1
#	define _UNICODE 1
#endif

#include <Windows.h>

//Conditionally bring in extra headers on versions where they are supported
#ifndef __MINGW32__
#if( _WIN32_WINNT >= 0x0600 )
#include <WerAPI.h>
#endif
#endif//__MINGW32__


//Definitions to patch up old versions of Windows headers with the types needed so our interface can remain consistent even if not all of it is operational.
#if( _WIN32_WINNT < 0x0600 )
typedef enum _WER_REGISTER_FILE_TYPE
{
	WerRegFileTypeUserDocument = 1,
	WerRegFileTypeOther = 2,
	WerRegFileTypeMax
} WER_REGISTER_FILE_TYPE;
#endif


//Local definitions for dealing with Windows API
#define _ATXT( _X ) ( #_X )
#define _AC( X ) ((char8_t)(_X))
#define _WTXT( _X ) ( L#_X )
#define _WC( _X ) ((char16_t)(_X))

#if ( qor_pp_unicode )
#	define _TXT( _X ) ( _WTXT( _X ) )
#	define _C( _X ) _WC( _X )
typedef std::wstring stdstring;
#else
#	define _TXT( _X ) ( _ATXT( _X ) )
#	define _C( _X ) _AC( _X )
typedef std::string stdstring;
#endif

#define qor_pp_useswinapi( _MODULE, _NAME ) static const Library::DefProc pFunc = reinterpret_cast< Library::DefProc>( Kernel32::GetProcAddress( reinterpret_cast< ::HMODULE >( Kernel32::GetModuleHandle(_TXT(_MODULE)) ), _ATXT(_NAME) ) )
#if ( qor_pp_unicode )
#	define qor_pp_useswinapiAW( _MODULE, _NAME ) qor_pp_useswinapi( _MODULE, _NAME##W )
#else
#	define qor_pp_useswinapiAW( _MODULE, _NAME ) qor_pp_useswinapi( _MODULE, _NAME##A )
#endif

namespace qor { namespace nswindows { namespace api {

	class qor_pp_module_interface(QOR_WINAPI) Kernel32
	{

	public:

		//Error handling functions

		static BOOL Beep(DWORD dwFreq, DWORD dwDuration);
		static USHORT RtlCaptureStackBackTrace(ULONG FramesToSkip, ULONG FramesToCapture, void** BackTrace, PULONG BackTraceHash);
		static void FatalAppExit(UINT uAction, LPCTSTR lpMessageText);
		static DWORD FormatMessage(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPTSTR lpBuffer, DWORD nSize, va_list * Arguments);
		static UINT GetErrorMode(void);
		static DWORD GetLastError(void);
		static void* RtlLookupFunctionEntry(ULONGLONG ControlPC, PULONGLONG ImageBase, PUNWIND_HISTORY_TABLE TargetGp);
		static void* RtlPcToFileHeader(void* PcValue, void** BaseOfImage);
		static void RtlUnwind(void* TargetFrame, void* TargetIp, ::PEXCEPTION_RECORD ExceptionRecord, void* ReturnValue);
		static UINT SetErrorMode(UINT uMode);
		static void SetLastError(DWORD dwErrCode);
		static HRESULT WerGetFlags(HANDLE hProcess, PDWORD pdwFlags);
		static HRESULT WerRegisterFile(PCWSTR pwzFile, ::WER_REGISTER_FILE_TYPE regFileType, DWORD dwFlags);
		static HRESULT WerRegisterMemoryBlock(void* pvAddress, DWORD dwSize);
		static HRESULT WerSetFlags(DWORD dwFlags);
		static HRESULT WerUnregisterFile(PCWSTR pwzFilePath);
		static HRESULT WerUnregisterMemoryBlock(void* pvAddress);

		//Dynamic Link Library functions

		static BOOL DisableThreadLibraryCalls(HMODULE hModule);
		static BOOL FreeLibrary(HMODULE hModule);
		static VOID FreeLibraryAndExitThread(HMODULE hModule, DWORD dwExitCode);
		static DWORD GetModuleFileName(HMODULE hModule, LPTSTR lpFilename, DWORD nSize);
		static HMODULE GetModuleHandle(LPCTSTR lpModuleName);
		static FARPROC GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
		static HMODULE LoadLibrary(LPCTSTR lpFileName);
		static HMODULE LoadLibraryEx(LPCTSTR lpFileName, HANDLE hFile, DWORD dwFlags);
		static BOOL GetModuleHandleEx(DWORD dwFlags, LPCTSTR lpModuleName, HMODULE * phModule);
		static DWORD GetDllDirectory(DWORD nBufferLength, LPTSTR lpBuffer);
		static BOOL SetDllDirectory(LPCTSTR lpPathName);

		//Handle Functions
		static BOOL CloseHandle(HANDLE hObject);
		static BOOL DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions);
		static BOOL GetHandleInformation(HANDLE hObject, LPDWORD lpdwFlags);
		static BOOL SetHandleInformation(HANDLE hObject, DWORD dwMask, DWORD dwFlags);

		//Console functions

		static BOOL AddConsoleAlias(LPTSTR Source, LPTSTR Target, LPTSTR ExeName);
		static BOOL AllocConsole(void);
		static BOOL AttachConsole(DWORD dwProcessId);
		static HANDLE CreateConsoleScreenBuffer(DWORD dwDesiredAccess, DWORD dwShareMode, const ::SECURITY_ATTRIBUTES * lpSecurityAttributes, DWORD dwFlags, void* lpScreenBufferData);
		static BOOL FillConsoleOutputAttribute(HANDLE hConsoleOutput, WORD wAttribute, DWORD nLength, ::COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten);
		static BOOL FillConsoleOutputCharacter(HANDLE hConsoleOutput, TCHAR cCharacter, DWORD nLength, ::COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten);
		static BOOL FlushConsoleInputBuffer(HANDLE hConsoleInput);
		static BOOL FreeConsole(void);
		static BOOL GenerateConsoleCtrlEvent(DWORD dwCtrlEvent, DWORD dwProcessGroupId);
		static DWORD GetConsoleAlias(LPTSTR lpSource, LPTSTR lpTargetBuffer, DWORD TargetBufferLength, LPTSTR lpExeName);
		static DWORD GetConsoleAliases(LPTSTR lpAliasBuffer, DWORD AliasBufferLength, LPTSTR lpExeName);
		static DWORD GetConsoleAliasesLength(LPTSTR lpExeName);
		static DWORD GetConsoleAliasExes(LPTSTR lpExeNameBuffer, DWORD ExeNameBufferLength);
		static DWORD GetConsoleAliasExesLength(VOID);
		static UINT GetConsoleCP(void);
		static BOOL GetConsoleCursorInfo(HANDLE hConsoleOutput, ::PCONSOLE_CURSOR_INFO lpConsoleCursorInfo);
		static BOOL GetConsoleDisplayMode(LPDWORD lpModeFlags);
		static ::COORD GetConsoleFontSize(HANDLE hConsoleOutput, DWORD nFont);
		static BOOL GetConsoleHistoryInfo(::PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo);
		static BOOL GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
		static DWORD GetConsoleOriginalTitle(LPTSTR lpConsoleTitle, DWORD nSize);
		static UINT GetConsoleOutputCP(void);
		static DWORD GetConsoleProcessList(LPDWORD lpdwProcessList, DWORD dwProcessCount);
		static BOOL GetConsoleScreenBufferInfo(HANDLE hConsoleOutput, ::PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);
		static BOOL GetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, ::PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx);
		static BOOL GetConsoleSelectionInfo(::PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo);
		static DWORD GetConsoleTitle(LPTSTR lpConsoleTitle, DWORD nSize);
		static HWND GetConsoleWindow(void);
		static BOOL GetCurrentConsoleFont(HANDLE hConsoleOutput, BOOL bMaximumWindow, ::PCONSOLE_FONT_INFO lpConsoleCurrentFont);
		static BOOL GetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, ::PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);
		static ::COORD GetLargestConsoleWindowSize(HANDLE hConsoleOutput);
		static BOOL GetNumberOfConsoleInputEvents(HANDLE hConsoleInput, LPDWORD lpcNumberOfEvents);
		static BOOL GetNumberOfConsoleMouseButtons(LPDWORD lpNumberOfMouseButtons);
		static HANDLE GetStdHandle(DWORD nStdHandle);
		static BOOL PeekConsoleInput(HANDLE hConsoleInput, ::PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);
		static BOOL ReadConsole(HANDLE hConsoleInput, void* lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, ::PCONSOLE_READCONSOLE_CONTROL pReadcontrol);
		static BOOL ReadConsoleInput(HANDLE hConsoleInput, ::PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);
		static BOOL ReadConsoleOutput(HANDLE hConsoleOutput, ::PCHAR_INFO lpBuffer, ::COORD dwBufferSize, ::COORD dwBufferCoord, ::PSMALL_RECT lpReadRegion);
		static BOOL ReadConsoleOutputAttribute(HANDLE hConsoleOutput, LPWORD lpAttribute, DWORD nLength, ::COORD dwReadCoord, LPDWORD lpNumberOfAttrsRead);
		static BOOL ReadConsoleOutputCharacter(HANDLE hConsoleOutput, LPTSTR lpCharacter, DWORD nLength, ::COORD dwReadCoord, LPDWORD lpNumberOfCharsRead);
		static BOOL ScrollConsoleScreenBuffer(HANDLE hConsoleOutput, const ::SMALL_RECT * lpScrollRectangle, const ::SMALL_RECT * lpClipRectangle, ::COORD dwDestinationOrigin, const ::CHAR_INFO * lpFill);
		static BOOL SetConsoleActiveScreenBuffer(HANDLE hConsoleOutput);
		static BOOL SetConsoleCP(UINT wCodePageID);
		static BOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE HandlerRoutine, BOOL Add);
		static BOOL SetConsoleCursorInfo(HANDLE hConsoleOutput, const ::CONSOLE_CURSOR_INFO * lpConsoleCursorInfo);
		static BOOL SetConsoleCursorPosition(HANDLE hConsoleOutput, ::COORD dwCursorPosition);
		static BOOL SetConsoleMode(HANDLE hConsoleHandle, DWORD dwMode);
		static BOOL SetConsoleDisplayMode(HANDLE hConsoleOutput, DWORD dwFlags, ::PCOORD lpNewScreenBufferDimensions);
		static BOOL SetConsoleHistoryInfo(::PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo);
		static BOOL SetConsoleOutputCP(UINT wCodePageID);
		static BOOL SetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, ::PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx);
		static BOOL SetConsoleScreenBufferSize(HANDLE hConsoleOutput, ::COORD dwSize);
		static BOOL SetConsoleTextAttribute(HANDLE hConsoleOutput, WORD wAttributes);
		static BOOL SetConsoleTitle(LPCTSTR lpConsoleTitle);
		static BOOL SetConsoleWindowInfo(HANDLE hConsoleOutput, BOOL bAbsolute, const ::SMALL_RECT * lpConsoleWindow);
		static BOOL SetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, ::PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);
		static BOOL SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
		static BOOL WriteConsoleA(HANDLE hConsoleOutput, const VOID * lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, void* lpReserved);
		static BOOL WriteConsoleW(HANDLE hConsoleOutput, const VOID * lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, void* lpReserved);
		static BOOL WriteConsoleInput(HANDLE hConsoleInput, const ::INPUT_RECORD * lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten);
		static BOOL WriteConsoleOutput(HANDLE hConsoleOutput, const ::CHAR_INFO * lpBuffer, ::COORD dwBufferSize, ::COORD dwBufferCoord, ::PSMALL_RECT lpWriteRegion);
		static BOOL WriteConsoleOutputAttribute(HANDLE hConsoleOutput, const WORD * lpAttribute, DWORD nLength, ::COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten);
		static BOOL WriteConsoleOutputCharacter(HANDLE hConsoleOutput, LPCTSTR lpCharacter, DWORD nLength, ::COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten);
		static DWORD CtrlRoutine(LPVOID lpParameter);

		//IO
		static BOOL AreFileApisANSI(void);
		static BOOL CheckNameLegalDOS8Dot3A( LPCTSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal );
		static BOOL CheckNameLegalDOS8Dot3W( LPCTSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal );
		static BOOL CopyFile( LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, BOOL bFailIfExists );
		static BOOL CopyFileEx( LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, ::LPPROGRESS_ROUTINE lpProgressRoutine, void* lpData, LPBOOL pbCancel, DWORD dwCopyFlags );
		static BOOL CopyFileTransacted( LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, ::LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction );
		static BOOL CreateHardLink( LPCTSTR lpFileName, LPCTSTR lpExistingFileName, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes );
		static BOOL CreateHardLinkTransacted( LPCTSTR lpFileName, LPCTSTR lpExistingFileName, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction );
		static BOOL CreateSymbolicLink( LPCTSTR lpSymlinkFileName, LPCTSTR lpTargetFileName, DWORD dwFlags );
		static BOOL CreateSymbolicLinkTransacted( LPCTSTR lpSymlinkFileName, LPCTSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction );
		static BOOL DeleteFile( LPCTSTR lpFileName );
		static BOOL DeleteFileTransacted( LPCTSTR lpFileName, HANDLE hTransaction );
		static BOOL GetBinaryType( LPCTSTR lpApplicationName, LPDWORD lpBinaryType );
		static DWORD GetCompressedFileSize( LPCTSTR lpFileName, LPDWORD lpFileSizeHigh );
		static DWORD GetCompressedFileSizeTransacted( LPCTSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction );
		static DWORD GetFileAttributes( LPCTSTR lpFileName );
		static BOOL GetFileAttributesEx( LPCTSTR lpFileName, ::GET_FILEEX_INFO_LEVELS fInfoLevelId, void* lpFileInformation );
		static BOOL GetFileAttributesTransacted( LPCTSTR lpFileName, ::GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction );
		static DWORD GetFullPathName( LPCTSTR lpFileName, DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR* lpFilePart );
		static DWORD GetFullPathNameTransacted( LPCTSTR lpFileName, DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR *lpFilePart, HANDLE hTransaction );
		static DWORD GetLongPathName( LPCTSTR lpszShortPath, LPTSTR lpszLongPath, DWORD cchBuffer );
		static DWORD GetLongPathNameTransacted( LPCTSTR lpszShortPath, LPTSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction );
		static DWORD GetShortPathName( LPCTSTR lpszLongPath, LPTSTR lpszShortPath, DWORD cchBuffer );
		static UINT GetTempFileName( LPCTSTR lpPathName, LPCTSTR lpPrefixString, UINT uUnique, LPTSTR lpTempFileName );
		static DWORD GetTempPath( DWORD nBufferLength, LPTSTR lpBuffer );
		static BOOL MoveFile( LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName );
		static BOOL MoveFileEx( LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, DWORD dwFlags );
		static BOOL MoveFileTransacted( LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, ::LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction );
		static BOOL MoveFileWithProgress( LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, ::LPPROGRESS_ROUTINE lpProgressRoutine, void* lpData, DWORD dwFlags );
		static BOOL ReplaceFile( LPCTSTR lpReplacedFileName, LPCTSTR lpReplacementFileName, LPCTSTR lpBackupFileName, DWORD dwReplaceFlags, void* lpExclude, LPVOID lpReserved );
		static DWORD SearchPath( LPCTSTR lpPath, LPCTSTR lpFileName, LPCTSTR lpExtension, DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR* lpFilePart );
		static void SetFileApisToANSI(void);
		static void SetFileApisToOEM(void);
		static BOOL SetFileAttributes( LPCTSTR lpFileName, DWORD dwFileAttributes );
		static BOOL SetFileAttributesTransacted( LPCTSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction );
		static BOOL Wow64DisableWow64FsRedirection( void** OldValue );
		static BOOLEAN Wow64EnableWow64FsRedirection( BOOLEAN Wow64FsEnableRedirection );
		static BOOL Wow64RevertWow64FsRedirection( void* OldValue );
		static UINT SetHandleCount( UINT uNumber );

		//IO Completion Ports
		static HANDLE CreateIoCompletionPort( HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads );
		static BOOL GetQueuedCompletionStatus( HANDLE CompletionPort, LPDWORD lpNumberOfBytes, PULONG_PTR lpCompletionKey, ::LPOVERLAPPED* lpOverlapped, DWORD dwMilliseconds );
		static BOOL GetQueuedCompletionStatusEx( HANDLE CompletionPort, ::LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable );
		static BOOL PostQueuedCompletionStatus( HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, ::LPOVERLAPPED lpOverlapped );

		static BOOL FindClose( HANDLE hFindFile );
		static HANDLE FindFirstFile( LPCTSTR lpFileName, ::LPWIN32_FIND_DATA lpFindFileData );
		static HANDLE FindFirstFileEx( LPCTSTR lpFileName, ::FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, ::FINDEX_SEARCH_OPS fSearchOp, void* lpSearchFilter, DWORD dwAdditionalFlags );
		static HANDLE FindFirstFileNameTransactedW( LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWCHAR LinkName, HANDLE hTransaction );
		static HANDLE FindFirstFileNameW( LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWCHAR LinkName );
		static HANDLE FindFirstFileTransacted( LPCTSTR lpFileName, ::FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, ::FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction );
		static HANDLE FindFirstStreamTransactedW( LPCWSTR lpFileName, ::STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags, HANDLE hTransaction );
		static HANDLE FindFirstStreamW( LPCWSTR lpFileName, ::STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags );
		static BOOL FindNextFile( HANDLE hFindFile, ::LPWIN32_FIND_DATA lpFindFileData );
		static BOOL FindNextFileNameW( HANDLE hFindStream, LPDWORD StringLength, PWCHAR LinkName );
		static BOOL FindNextStreamW( HANDLE hFindStream, void* lpFindStreamData );

		//File
		static BOOL CancelIo( HANDLE hFile );
		static BOOL CancelIoEx( HANDLE hFile, ::LPOVERLAPPED lpOverlapped );
		static BOOL CancelSynchronousIo( HANDLE hThread );
		static HANDLE CreateFileA( LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile );
		static HANDLE CreateFileW( LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile );
		static HANDLE CreateFileTransacted( LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, void* pExtendedParameter );				
		static BOOL FlushFileBuffers( HANDLE hFile );
		static BOOL GetFileBandwidthReservation( HANDLE hFile, LPDWORD lpPeriodMilliseconds, LPDWORD lpBytesPerPeriod, LPBOOL pDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests );
		static BOOL GetFileInformationByHandle( HANDLE hFile, ::LPBY_HANDLE_FILE_INFORMATION lpFileInformation );
		static BOOL GetFileInformationByHandleEx( HANDLE hFile, ::FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize );
		static DWORD GetFileSize( HANDLE hFile, LPDWORD lpFileSizeHigh );
		static BOOL GetFileSizeEx( HANDLE hFile, PLARGE_INTEGER lpFileSize );
		static DWORD GetFileType( HANDLE hFile );
		static DWORD GetFinalPathNameByHandleT( HANDLE hFile, LPTSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags );
		static BOOL LockFile( HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh );
		static BOOL LockFileEx( HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, ::LPOVERLAPPED lpOverlapped );
		static HFILE OpenFile( LPCSTR lpFileName, ::LPOFSTRUCT lpReOpenBuff, UINT uStyle );
		static HANDLE OpenFileById( HANDLE hFile, ::LPFILE_ID_DESCRIPTOR lpFileID, DWORD dwDesiredAccess, DWORD dwShareMode, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwFlags );
		static BOOL ReadFile( HANDLE hFile, void* lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, ::LPOVERLAPPED lpOverlapped );
		static BOOL ReadFileEx( HANDLE hFile, void* lpBuffer, DWORD nNumberOfBytesToRead, ::LPOVERLAPPED lpOverlapped, ::LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine );
		static BOOL ReadFileScatter( HANDLE hFile, ::FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToRead, LPDWORD lpReserved, ::LPOVERLAPPED lpOverlapped );
		static HANDLE ReOpenFile( HANDLE hOriginalFile, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwFlags );
		static BOOL SetEndOfFile( HANDLE hFile );
		static BOOL SetFileBandwidthReservation( HANDLE hFile, DWORD nPeriodMilliseconds, DWORD nBytesPerPeriod, BOOL bDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests );
		static BOOL SetFileCompletionNotificationModes( HANDLE FileHandle, UCHAR Flags );
		static BOOL SetFileInformationByHandle( HANDLE hFile, ::FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize );
		static BOOL SetFileIoOverlappedRange( HANDLE FileHandle, PUCHAR OverlappedRangeStart, ULONG Length );
		static DWORD SetFilePointer( HANDLE hFile, long lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod );
		static BOOL SetFilePointerEx( HANDLE hFile, ::LARGE_INTEGER liDistanceToMove, ::PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod );
		static BOOL SetFileShortNameT( HANDLE hFile, LPCTSTR lpShortName );
		static BOOL SetFileValidData( HANDLE hFile, LONGLONG ValidDataLength );
		static BOOL UnlockFile( HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh );
		static BOOL UnlockFileEx( HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, ::LPOVERLAPPED lpOverlapped );
		static BOOL WriteFile( HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, ::LPOVERLAPPED lpOverlapped );
		static BOOL WriteFileEx( HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, ::LPOVERLAPPED lpOverlapped, ::LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine );
		static BOOL WriteFileGather( HANDLE hFile, ::FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToWrite, LPDWORD lpReserved, ::LPOVERLAPPED lpOverlapped );
		
		//ProcessAndThread
		static BOOL AssignProcessToJobObject( HANDLE hJob, HANDLE hProcess );
		static BOOL BindIoCompletionCallback( HANDLE FileHandle, ::LPOVERLAPPED_COMPLETION_ROUTINE Function, ULONG Flags );
		static BOOL CallbackMayRunLong( ::PTP_CALLBACK_INSTANCE pci );
		static VOID CancelThreadpoolIo( ::PTP_IO pio );
		static VOID CloseThreadpool( ::PTP_POOL ptpp );
		static VOID CloseThreadpoolCleanupGroup( ::PTP_CLEANUP_GROUP ptpcg );
		static VOID CloseThreadpoolCleanupGroupMembers( ::PTP_CLEANUP_GROUP ptpcg, BOOL fCancelPendingCallbacks, void* pvCleanupContext );
		static VOID CloseThreadpoolIo( ::PTP_IO pio );
		static VOID CloseThreadpoolTimer( ::PTP_TIMER pti );
		static VOID CloseThreadpoolWait( ::PTP_WAIT pwa );
		static VOID CloseThreadpoolWork( ::PTP_WORK pwk );
		static BOOL ConvertFiberToThread(void);
		static void* ConvertThreadToFiber( void* lpParameter );
		static LPVOID ConvertThreadToFiberEx( void* lpParameter, DWORD dwFlags );
		static void* CreateFiber( SIZE_T dwStackSize, ::LPFIBER_START_ROUTINE lpStartAddress, void* lpParameter );
		static void* CreateFiberEx( SIZE_T dwStackCommitSize, SIZE_T dwStackReserveSize, DWORD dwFlags, ::LPFIBER_START_ROUTINE lpStartAddress, void* lpParameter );
		static HANDLE CreateJobObjectT( ::LPSECURITY_ATTRIBUTES lpJobAttributes, LPCTSTR lpName );
		static BOOL CreateProcessT( LPCTSTR lpApplicationName, LPTSTR lpCommandLine, ::LPSECURITY_ATTRIBUTES lpProcessAttributes, ::LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, void* lpEnvironment, LPCTSTR lpCurrentDirectory, ::LPSTARTUPINFO lpStartupInfo, ::LPPROCESS_INFORMATION lpProcessInformation );
		static HANDLE CreateRemoteThread( HANDLE hProcess, ::LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, void* lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId );
		static HANDLE CreateThread( ::LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, ::LPTHREAD_START_ROUTINE lpStartAddress, void* lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId );
		static ::PTP_POOL CreateThreadpool( void* reserved );
		static ::PTP_CLEANUP_GROUP CreateThreadpoolCleanupGroup(void);
		static ::PTP_IO CreateThreadpoolIo( HANDLE fl, ::PTP_WIN32_IO_CALLBACK pfnio, void* pv, ::PTP_CALLBACK_ENVIRON pcbe );
		static ::PTP_TIMER CreateThreadpoolTimer( ::PTP_TIMER_CALLBACK pfnti, void* pv, ::PTP_CALLBACK_ENVIRON pcbe );
		static ::PTP_WAIT CreateThreadpoolWait( ::PTP_WAIT_CALLBACK pfnwa, void* pv, ::PTP_CALLBACK_ENVIRON pcbe );
		static ::PTP_WORK CreateThreadpoolWork( ::PTP_WORK_CALLBACK pfnwk, void* pv, ::PTP_CALLBACK_ENVIRON pcbe );
		static VOID DeleteFiber( void* lpFiber );
		static VOID DeleteProcThreadAttributeList( ::LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList );
		static VOID DisassociateCurrentThreadFromCallback( ::PTP_CALLBACK_INSTANCE pci );
		static VOID ExitProcess( UINT uExitCode );
		static VOID ExitThread( DWORD dwExitCode );
		static DWORD FlsAlloc( ::PFLS_CALLBACK_FUNCTION lpCallback );
		static BOOL FlsFree( DWORD dwFlsIndex );
		static void* FlsGetValue( DWORD dwFlsIndex );
		static BOOL FlsSetValue( DWORD dwFlsIndex, void* lpFlsData );
		static VOID FlushProcessWriteBuffers(void);
		static BOOL FreeEnvironmentStringsA( LPSTR lpszEnvironmentBlock );
		static BOOL FreeEnvironmentStringsW( LPWSTR lpszEnvironmentBlock );
		static VOID FreeLibraryWhenCallbackReturns( ::PTP_CALLBACK_INSTANCE pci, HMODULE mod );
		static LPTSTR GetCommandLineT(void);
		static HANDLE GetCurrentProcess(void);
		static DWORD GetCurrentProcessId(void);
		static DWORD GetCurrentProcessorNumber(void);
		static HANDLE GetCurrentThread(void);
		static DWORD GetCurrentThreadId(void);
		static LPVOID GetEnvironmentStringsA(void);
		static LPVOID GetEnvironmentStringsW(void);
		static DWORD GetEnvironmentVariableT(LPCTSTR lpName, LPTSTR lpBuffer, DWORD nSize );
		static BOOL GetExitCodeProcess( HANDLE hProcess, LPDWORD lpExitCode );
		static BOOL GetExitCodeThread( HANDLE hThread, LPDWORD lpExitCode );
		static BOOL GetLogicalProcessorInformation( ::PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, PDWORD ReturnLength );
		static BOOL GetNumaAvailableMemoryNode( UCHAR Node, PULONGLONG AvailableBytes );
		static BOOL GetNumaHighestNodeNumber( PULONG HighestNodeNumber );
		static BOOL GetNumaNodeProcessorMask( UCHAR Node, PULONGLONG ProcessorMask );
		static BOOL GetNumaProcessorNode( UCHAR Processor, PUCHAR NodeNumber );
		static BOOL GetNumaProximityNode( ULONG ProximityId, PUCHAR NodeNumber );
		static DWORD GetPriorityClass( HANDLE hProcess );
		static BOOL GetProcessAffinityMask( HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask );
		static BOOL GetProcessHandleCount( HANDLE hProcess, PDWORD pdwHandleCount );
		static DWORD GetProcessId( HANDLE Process );
		static DWORD GetProcessIdOfThread( HANDLE Thread );
		static BOOL GetProcessIoCounters( HANDLE hProcess, ::PIO_COUNTERS lpIoCounters );
		static BOOL GetProcessPriorityBoost( HANDLE hProcess, PBOOL pDisablePriorityBoost );
		static BOOL GetProcessShutdownParameters( LPDWORD lpdwLevel, LPDWORD lpdwFlags );
		static BOOL GetProcessTimes( HANDLE hProcess, ::LPFILETIME lpCreationTime, ::LPFILETIME lpExitTime, ::LPFILETIME lpKernelTime, ::LPFILETIME lpUserTime );
		static DWORD GetProcessVersion( DWORD ProcessId );
		static BOOL GetProcessWorkingSetSize( HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize );
		static BOOL GetProcessWorkingSetSizeEx( HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize, PDWORD Flags );
		static VOID GetStartupInfoT( LPSTARTUPINFO pStartupInfo );
		static DWORD GetThreadId( HANDLE Thread );
		static BOOL GetThreadIOPendingFlag( HANDLE hThread, PBOOL lpIOIsPending );
		static int GetThreadPriority( HANDLE hThread );
		static BOOL GetThreadPriorityBoost( HANDLE hThread, PBOOL pDisablePriorityBoost );
		static BOOL GetThreadTimes( HANDLE hThread, ::LPFILETIME lpCreationTime, ::LPFILETIME lpExitTime, ::LPFILETIME lpKernelTime, ::LPFILETIME lpUserTime );
		static BOOL InitializeProcThreadAttributeList( ::LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwAttributeCount, DWORD dwFlags, PSIZE_T lpSize );
		static VOID InitializeThreadpoolEnvironment( ::PTP_CALLBACK_ENVIRON pcbe );
		static VOID DestroyThreadpoolEnvironment( ::PTP_CALLBACK_ENVIRON pcbe );
		static BOOL IsProcessInJob( HANDLE ProcessHandle, HANDLE JobHandle, PBOOL Result );
		static BOOL IsThreadAFiber(void);
		static BOOL IsThreadpoolTimerSet( ::PTP_TIMER pti );
		static BOOL IsWow64Process( HANDLE hProcess, PBOOL Wow64Process );
		static VOID LeaveCriticalSectionWhenCallbackReturns( ::PTP_CALLBACK_INSTANCE pci, ::PCRITICAL_SECTION pcs );
		static BOOL NeedCurrentDirectoryForExePathT( LPCTSTR ExeName );
		static HANDLE OpenJobObjectT( DWORD dwDesiredAccess, BOOL bInheritHandles, LPCTSTR lpName );
		static HANDLE OpenProcess( DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId );
		static HANDLE OpenThread( DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId );
		static BOOL QueryFullProcessImageNameT( HANDLE hProcess, DWORD dwFlags, LPTSTR lpExeName, PDWORD lpdwSize );
		static BOOL QueryIdleProcessorCycleTime( PULONG BufferLength, PULONG64 ProcessorIdleCycleTime );
		static BOOL QueryInformationJobObject( HANDLE hJob, ::JOBOBJECTINFOCLASS JobObjectInfoClass, void* lpJobObjectInfo, DWORD cbJobObjectInfoLength, LPDWORD lpReturnLength );
		static BOOL QueryProcessAffinityUpdateMode( HANDLE ProcessHandle, LPDWORD lpdwFlags );
		static BOOL QueryProcessCycleTime( HANDLE ProcessHandle, PULONG64 CycleTime );
		static BOOL QueryThreadCycleTime( HANDLE ThreadHandle, PULONG64 CycleTime );
		static BOOL QueueUserWorkItem( LPTHREAD_START_ROUTINE Function, void* Context, ULONG Flags );
		static VOID ReleaseMutexWhenCallbackReturns( ::PTP_CALLBACK_INSTANCE pci, HANDLE mut );
		static VOID ReleaseSemaphoreWhenCallbackReturns( ::PTP_CALLBACK_INSTANCE pci, HANDLE sem, DWORD crel );
		static DWORD ResumeThread( HANDLE hThread );
		static BOOL SetEnvironmentVariableT( LPCTSTR lpName, LPCTSTR lpValue );
		static VOID SetEventWhenCallbackReturns( ::PTP_CALLBACK_INSTANCE pci, HANDLE evt );
		static BOOL SetInformationJobObject( HANDLE hJob, ::JOBOBJECTINFOCLASS JobObjectInfoClass, void* lpJobObjectInfo, DWORD cbJobObjectInfoLength );
		static BOOL SetPriorityClass( HANDLE hProcess, DWORD dwPriorityClass );
		static BOOL SetProcessAffinityMask( HANDLE hProcess, DWORD_PTR dwProcessAffinityMask );
		static BOOL SetProcessAffinityUpdateMode( HANDLE ProcessHandle, DWORD dwFlags );
		static BOOL SetProcessPriorityBoost( HANDLE hProcess, BOOL DisablePriorityBoost );
		static BOOL SetProcessShutdownParameters( DWORD dwLevel, DWORD dwFlags );
		static BOOL SetProcessWorkingSetSize( HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize );
		static BOOL SetProcessWorkingSetSizeEx( HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize, DWORD Flags );
		static DWORD_PTR SetThreadAffinityMask( HANDLE hThread, DWORD_PTR dwThreadAffinityMask );
		static DWORD SetThreadIdealProcessor( HANDLE hThread, DWORD dwIdealProcessor );
		static VOID SetThreadpoolCallbackCleanupGroup( ::PTP_CALLBACK_ENVIRON pcbe, ::PTP_CLEANUP_GROUP ptpcg, ::PTP_CLEANUP_GROUP_CANCEL_CALLBACK pfng );
		static VOID SetThreadpoolCallbackLibrary( ::PTP_CALLBACK_ENVIRON pcbe, void* mod );
		static VOID SetThreadpoolCallbackPool( ::PTP_CALLBACK_ENVIRON pcbe, ::PTP_POOL ptpp );
		static VOID SetThreadpoolCallbackRunsLong( ::PTP_CALLBACK_ENVIRON pcbe );
		static VOID SetThreadpoolThreadMaximum( ::PTP_POOL ptpp, DWORD cthrdMost );
		static BOOL SetThreadpoolThreadMinimum( ::PTP_POOL ptpp, DWORD cthrdMic );
		static VOID SetThreadpoolTimer( ::PTP_TIMER pti, ::PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength );
		static VOID SetThreadpoolWait( ::PTP_WAIT pwa, HANDLE h, ::PFILETIME pftTimeout );
		static BOOL SetThreadPriority( HANDLE hThread, int nPriority );
		static BOOL SetThreadPriorityBoost( HANDLE hThread, BOOL bDisablePriorityBoost );
		static BOOL SetThreadStackGuarantee( PULONG StackSizeInBytes );
		static VOID Sleep( DWORD dwMilliseconds );
		static DWORD SleepEx( DWORD dwMilliseconds, BOOL bAlertable );
		static VOID StartThreadpoolIo( ::PTP_IO pio );
		static VOID SubmitThreadpoolWork( ::PTP_WORK pwk );
		static DWORD SuspendThread( HANDLE hThread );
		static VOID SwitchToFiber( void* lpFiber );
		static BOOL SwitchToThread(void);
		static BOOL TerminateJobObject( HANDLE hJob, UINT uExitCode );
		static BOOL TerminateProcess( HANDLE hProcess, UINT uExitCode );
		static BOOL TerminateThread( HANDLE hThread,  DWORD dwExitCode );
		static DWORD TlsAlloc(void);
		static BOOL TlsFree( DWORD dwTlsIndex );
		static void* TlsGetValue( DWORD dwTlsIndex );
		static BOOL TlsSetValue( DWORD dwTlsIndex, void* lpTlsValue );
		static BOOL TrySubmitThreadpoolCallback( ::PTP_SIMPLE_CALLBACK pfns, void* pv, ::PTP_CALLBACK_ENVIRON pcbe );
		static BOOL UpdateProcThreadAttribute( ::LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwFlags, DWORD_PTR Attribute, void* lpValue, SIZE_T cbSize, void* lpPreviousValue, PSIZE_T lpReturnSize );
		static void WaitForThreadpoolIoCallbacks( ::PTP_IO pio, BOOL fCancelPendingCallbacks );
		static void WaitForThreadpoolTimerCallbacks( ::PTP_TIMER pti, BOOL fCancelPendingCallbacks );
		static void WaitForThreadpoolWaitCallbacks( ::PTP_WAIT pwa, BOOL fCancelPendingCallbacks );
		static void WaitForThreadpoolWorkCallbacks( ::PTP_WORK pwk, BOOL fCancelPendingCallbacks );
		static UINT WinExec( LPCSTR lpCmdLine, UINT uCmdShow );
		static DWORD Wow64SuspendThread( HANDLE hThread );
		static DWORD LoadModule( LPCSTR lpModuleName, void* lpParameterBlock );

		//Sync API
		static DWORD WaitForMultipleObjectsEx(DWORD nCount, const void** lpHandles, BOOL bWaitAll, DWORD dwMilliseconds, BOOL bAlertable);
	};

}}}//qor::nswindows::api

#endif//QOR_PP_H_OS_WINDOWS_API_KERNEL
