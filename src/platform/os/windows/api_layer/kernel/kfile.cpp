// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"
#include "src/qor/module/module.h"
#include "src/qor/interception/functioncontext.h"
#include "src/qor/error/error.h"
#include "errorhandler.h"

//Windows specific headers must be last to prevent contaminating generic headers with Windows specific types and definitions
#include "kernel32.h" //kernel32.h must be the first windows header as it's the primary inclusion point for windows.h
#include "../returncheck.h"
#include "../library.h"

namespace qor { namespace nswindows { namespace api {

    BOOL Kernel32::CancelIo( HANDLE hFile)
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, CancelIo );
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call< BOOL, HANDLE >( pFunc, hFile );
        return bResult;
    }

    BOOL Kernel32::CancelIoEx( HANDLE hFile, LPOVERLAPPED lpOverlapped )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, CancelIoEx );
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call< BOOL, HANDLE, LPOVERLAPPED >( pFunc, hFile, lpOverlapped );
        return bResult;
    }

    BOOL Kernel32::CancelSynchronousIo( HANDLE hThread )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, CancelSynchronousIo);
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call< BOOL, HANDLE>(pFunc, hThread);
        return bResult;
    }

    HANDLE Kernel32::CreateFileA( LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, CreateFileA);
        CheckReturn< HANDLE, HandleCheck >::TType h = Library::Call<HANDLE, LPCSTR, DWORD, DWORD, ::LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE>(
            pFunc, lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
        return h;
    }

    HANDLE Kernel32::CreateFileW( LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, CreateFileW);
        CheckReturn< HANDLE, HandleCheck >::TType h = Library::Call<HANDLE, LPCWSTR, DWORD, DWORD, ::LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE>(
            pFunc, lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
        return h;
    }
    
    HANDLE Kernel32::CreateFileTransacted( LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, void* pExtendedParameter )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapiAW(kernel32, CreateFileTransacted);
        CheckReturn< HANDLE, HandleCheck >::TType h = Library::Call<HANDLE, LPCTSTR, DWORD, DWORD, ::LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE, HANDLE, PUSHORT, void*>(
            pFunc, lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile, hTransaction, pusMiniVersion, pExtendedParameter);
        return h;
    }
    
    BOOL Kernel32::FlushFileBuffers( HANDLE hFile )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, FlushFileBuffers);
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call< BOOL, HANDLE >(pFunc, hFile);
        return bResult;
    }
    
    BOOL Kernel32::GetFileBandwidthReservation( HANDLE hFile, LPDWORD lpPeriodMilliseconds, LPDWORD lpBytesPerPeriod, LPBOOL pDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, GetFileBandwidthReservation);
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call< BOOL, HANDLE, LPDWORD, LPDWORD, LPBOOL, LPDWORD, LPDWORD>(
            pFunc, hFile, lpPeriodMilliseconds, lpBytesPerPeriod, pDiscardable, lpTransferSize, lpNumOutstandingRequests);
        return bResult;
    }
        
    BOOL Kernel32::GetFileInformationByHandle( HANDLE hFile, ::LPBY_HANDLE_FILE_INFORMATION lpFileInformation )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, GetFileInformationByHandle);
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call< BOOL, HANDLE, ::LPBY_HANDLE_FILE_INFORMATION>(
            pFunc, hFile, lpFileInformation);
        return bResult;
    }
    
    BOOL Kernel32::GetFileInformationByHandleEx( HANDLE hFile, ::FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, GetFileInformationByHandleEx);
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call< BOOL, HANDLE, ::FILE_INFO_BY_HANDLE_CLASS, LPVOID, DWORD>(
            pFunc, hFile, FileInformationClass, lpFileInformation, dwBufferSize);
        return bResult;
    }

    DWORD Kernel32::GetFileSize( HANDLE hFile, LPDWORD lpFileSizeHigh )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, GetFileSize);
        CheckReturn< DWORD, TCheckFailureValue<DWORD, INVALID_FILE_SIZE> >::TType result = Library::Call<DWORD, HANDLE, LPDWORD>(
            pFunc, hFile, lpFileSizeHigh);
        return result;
    }

    BOOL Kernel32::GetFileSizeEx( HANDLE hFile, PLARGE_INTEGER lpFileSize )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, GetFileSizeEx);
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call< BOOL, HANDLE, PLARGE_INTEGER>(
            pFunc, hFile, lpFileSize);
        return bResult;
    }

    DWORD Kernel32::GetFileType( HANDLE hFile )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, GetFileType);     
        CheckReturn< DWORD, TCheckFailureValue<DWORD, FILE_TYPE_UNKNOWN> >::TType result = Library::Call<DWORD, HANDLE>(pFunc, hFile);
        return result;
    }

    DWORD Kernel32::GetFinalPathNameByHandleT( HANDLE hFile, LPTSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapiAW(kernel32, GetFinalPathNameByHandle);
        CheckReturn< DWORD, TCheckFailureValue<DWORD, 0> >::TType result = Library::Call<DWORD, HANDLE, LPTSTR, DWORD, DWORD>(
            pFunc, hFile, lpszFilePath, cchFilePath, dwFlags);
        return result;
    }

    BOOL Kernel32::LockFile( HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, LockFile);
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call<BOOL, HANDLE, DWORD, DWORD, DWORD, DWORD>(
            pFunc, hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh);
        return bResult;
    }

    BOOL Kernel32::LockFileEx( HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, ::LPOVERLAPPED lpOverlapped )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, LockFileEx);
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call< BOOL, HANDLE, DWORD, DWORD, DWORD, DWORD, ::LPOVERLAPPED>(
            pFunc, hFile, dwFlags, dwReserved, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh, lpOverlapped);
        return bResult;
    }

    HFILE Kernel32::OpenFile( LPCSTR lpFileName, ::LPOFSTRUCT lpReOpenBuff, UINT uStyle )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, OpenFile);
        CheckReturn< HFILE, TCheckFailureValue< HFILE, HFILE_ERROR> >::TType h = Library::Call<HFILE, LPCSTR, ::LPOFSTRUCT, UINT>(
            pFunc, lpFileName, lpReOpenBuff, uStyle);
        return h;
    }

    HANDLE Kernel32::OpenFileById( HANDLE hFile, ::LPFILE_ID_DESCRIPTOR lpFileID, DWORD dwDesiredAccess, DWORD dwShareMode, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwFlags )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, OpenFileById);
        CheckReturn< HANDLE, HandleCheck >::TType h = Library::Call<HANDLE, HANDLE, ::LPFILE_ID_DESCRIPTOR, DWORD, DWORD, ::LPSECURITY_ATTRIBUTES, DWORD>(
            pFunc, hFile, lpFileID, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwFlags);
        return h;
    }

    BOOL Kernel32::ReadFile( HANDLE hFile, void* lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, ::LPOVERLAPPED lpOverlapped )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, ReadFile);
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call< BOOL, HANDLE, void*, DWORD, LPDWORD, ::LPOVERLAPPED>(
            pFunc, hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
        return bResult;
    }

    BOOL Kernel32::ReadFileEx( HANDLE hFile, void* lpBuffer, DWORD nNumberOfBytesToRead, ::LPOVERLAPPED lpOverlapped, ::LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, ReadFileEx);
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call< BOOL, HANDLE, void*, DWORD, ::LPOVERLAPPED, ::LPOVERLAPPED_COMPLETION_ROUTINE>(
            pFunc, hFile, lpBuffer, nNumberOfBytesToRead, lpOverlapped, lpCompletionRoutine);
        return bResult;
    }

    BOOL Kernel32::ReadFileScatter( HANDLE hFile, ::FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToRead, LPDWORD lpReserved, ::LPOVERLAPPED lpOverlapped )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, ReadFileScatter);
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call< BOOL, HANDLE, ::FILE_SEGMENT_ELEMENT*, DWORD, LPDWORD, ::LPOVERLAPPED>(
            pFunc, hFile, aSegmentArray, nNumberOfBytesToRead, lpReserved, lpOverlapped);
        return bResult;
    }

    HANDLE Kernel32::ReOpenFile( HANDLE hOriginalFile, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwFlags )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, ReOpenFile);
        CheckReturn< HANDLE, HandleCheck >::TType h = Library::Call<HANDLE, HANDLE, DWORD, DWORD, DWORD>(
            pFunc, hOriginalFile, dwDesiredAccess, dwShareMode, dwFlags);
        return h;
    }

    BOOL Kernel32::SetEndOfFile( HANDLE hFile )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, SetEndOfFile);
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call< BOOL, HANDLE>(pFunc, hFile);
        return bResult;
    }

    BOOL Kernel32::SetFileBandwidthReservation( HANDLE hFile, DWORD nPeriodMilliseconds, DWORD nBytesPerPeriod, BOOL bDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, SetFileBandwidthReservation);
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call< BOOL, HANDLE, DWORD, DWORD, BOOL, LPDWORD, LPDWORD >(
            pFunc, hFile, nPeriodMilliseconds, nBytesPerPeriod, bDiscardable, lpTransferSize, lpNumOutstandingRequests);
        return bResult;
    }

    BOOL Kernel32::SetFileCompletionNotificationModes( HANDLE FileHandle, UCHAR Flags )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, SetFileCompletionNotificationModes);
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call< BOOL, HANDLE, UCHAR >(
            pFunc, FileHandle, Flags);
        return bResult;
    }

    BOOL Kernel32::SetFileInformationByHandle( HANDLE hFile, ::FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, SetFileInformationByHandle);
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call< BOOL, HANDLE, ::FILE_INFO_BY_HANDLE_CLASS, LPVOID, DWORD>(
            pFunc, hFile, FileInformationClass, lpFileInformation, dwBufferSize);
        return bResult;
    }

    BOOL Kernel32::SetFileIoOverlappedRange( HANDLE FileHandle, PUCHAR OverlappedRangeStart, ULONG Length )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, SetFileIoOverlappedRange);
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call< BOOL, HANDLE, PUCHAR, ULONG>(
            pFunc, FileHandle, OverlappedRangeStart, Length);
        return bResult;
    }

    DWORD Kernel32::SetFilePointer( HANDLE hFile, long lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, SetFilePointer);
        CheckReturn< DWORD, TCheckFailureValue<DWORD, INVALID_SET_FILE_POINTER> > result = Library::Call<DWORD, HANDLE, long, PLONG, DWORD>(
            pFunc, hFile, lDistanceToMove, lpDistanceToMoveHigh, dwMoveMethod);
    	return result;
    }

    BOOL Kernel32::SetFilePointerEx( HANDLE hFile, ::LARGE_INTEGER liDistanceToMove, ::PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, SetFilePointerEx );
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call< BOOL, HANDLE, ::LARGE_INTEGER, ::PLARGE_INTEGER, DWORD >(
            pFunc, hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod);
        return bResult;
    }

    BOOL Kernel32::SetFileShortNameT( HANDLE hFile, LPCTSTR lpShortName )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapiAW(kernel32, SetFileShortName );
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call< BOOL, HANDLE, LPCTSTR>(pFunc, hFile, lpShortName);
        return bResult;
    }

    BOOL Kernel32::SetFileValidData( HANDLE hFile, LONGLONG ValidDataLength )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, SetFileValidData );
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call< BOOL, HANDLE, LONGLONG >(pFunc, hFile, ValidDataLength);
        return bResult;
    }

    BOOL Kernel32::UnlockFile( HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, UnlockFile );
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call< BOOL, HANDLE, DWORD, DWORD, DWORD, DWORD>(
            pFunc, hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh);
        return bResult;
    }

    BOOL Kernel32::UnlockFileEx( HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, ::LPOVERLAPPED lpOverlapped )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, UnlockFileEx );
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call< BOOL, HANDLE, DWORD, DWORD, DWORD, ::LPOVERLAPPED>(
            pFunc, hFile, dwReserved, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh, lpOverlapped);
        return bResult;
    }

    BOOL Kernel32::WriteFile( HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, ::LPOVERLAPPED lpOverlapped )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, WriteFile);
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call<BOOL, HANDLE, LPCVOID, DWORD, LPDWORD, ::LPOVERLAPPED>(
            pFunc, hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
        return bResult;
    }

    BOOL Kernel32::WriteFileEx( HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, ::LPOVERLAPPED lpOverlapped, ::LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, WriteFileEx);
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call<BOOL, HANDLE, LPCVOID, DWORD, ::LPOVERLAPPED, ::LPOVERLAPPED_COMPLETION_ROUTINE>(
            pFunc, hFile, lpBuffer, nNumberOfBytesToWrite, lpOverlapped, lpCompletionRoutine);
        return bResult;
    }

    BOOL Kernel32::WriteFileGather( HANDLE hFile, ::FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToWrite, LPDWORD lpReserved, ::LPOVERLAPPED lpOverlapped )
    {
        qor_pp_fcontext;
        Win32ErrorHandler _;
        qor_pp_useswinapi(kernel32, WriteFileGather );
        CheckReturn< BOOL, BoolCheck >::TType bResult = Library::Call<BOOL, HANDLE, ::FILE_SEGMENT_ELEMENT*, DWORD, LPDWORD, ::LPOVERLAPPED>(pFunc, hFile, aSegmentArray, nNumberOfBytesToWrite, lpReserved, lpOverlapped);
        return bResult;
    }

}}}//qor::nswindows::api