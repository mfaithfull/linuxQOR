// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Windows Sockets

#ifndef QOR_PP_H_WINDOWS_API_WS2
#define QOR_PP_H_WINDOWS_API_WS2

#if qor_pp_unicode
#	define UNICODE 1
#	define _UNICODE 1
#endif

#define WIN32_NO_STATUS 1

typedef struct in_addr 
{
	union 
	{
		struct { unsigned char s_b1, s_b2, s_b3, s_b4; } S_un_b;
		struct { unsigned short s_w1, s_w2; } S_un_w;
		unsigned long S_addr;
	} S_un;
#define s_addr  S_un.S_addr /* can be used for most tcp & ip code */
#define s_host  S_un.S_un_b.s_b2    // host on imp
#define s_net   S_un.S_un_b.s_b1    // network
#define s_imp   S_un.S_un_w.s_w2    // imp
#define s_impno S_un.S_un_b.s_b4    // imp #
#define s_lh    S_un.S_un_b.s_b3    // logical host
} IN_ADDR, *PIN_ADDR, *LPIN_ADDR;

#include <winsock2.h>
#include <Ws2tcpip.h>
#if		( _WIN32_WINNT == 0x0500 )
#	include <WSPiApi.h>
#endif//( _WIN32_WINNT == 0x0500 )
#include <Ws2spi.h>
#undef WIN32_NO_STATUS
#include <MSWSock.h>
#define _WINSOCKAPI_
#include <string.h>

#ifdef	__MINGW32__
typedef addrinfo ADDRINFOA, *PADDRINFOA;

#if(_WIN32_WINNT >= 0x0600)
typedef struct pollfd
{
    SOCKET  fd;
    SHORT   events;
    SHORT   revents;

} WSAPOLLFD, *PWSAPOLLFD, FAR *LPWSAPOLLFD;
#endif

typedef struct _WSAMSG
{
    LPSOCKADDR       name;              /* Remote address */
    INT              namelen;           /* Remote address length */
    LPWSABUF         lpBuffers;         /* Data buffer array */

#if(_WIN32_WINNT >= 0x0600)
    ULONG            dwBufferCount;     /* Number of elements in the array */
#else
    DWORD            dwBufferCount;     /* Number of elements in the array */
#endif //(_WIN32_WINNT>=0x0600)

    WSABUF           Control;           /* Control buffer */

#if(_WIN32_WINNT >= 0x0600)
    ULONG            dwFlags;           /* Flags */
#else
    DWORD            dwFlags;           /* Flags */
#endif //(_WIN32_WINNT>=0x0600)

} WSAMSG, *PWSAMSG, * FAR LPWSAMSG;

#ifdef UNICODE
#if(_WIN32_WINNT >= 0x0600)
	typedef ADDRINFOEXW     ADDRINFOEX, *PADDRINFOEX;
#endif
#	define GetAddrInfoEx	GetAddrInfoExW
#	define GetAddrInfo		GetAddrInfoW
#	define FreeAddrInfo		FreeAddrInfoW
#	define SetAddrInfoEx	SetAddrInfoExW
#	define GetNameInfo		GetNameInfoW
#	define WSAEnumNameSpaceProvidersEx	WSAEnumNameSpaceProvidersExW
#	define InetNtop			InetNtopW
#	define InetPton			InetPtonW
#else
#if(_WIN32_WINNT >= 0x0600)
	typedef ADDRINFOEXA     ADDRINFOEX, *PADDRINFOEX;
#endif
#	define GetAddrInfoEx	GetAddrInfoExA
#	define GetAddrInfo		getaddrinfo
#	define FreeAddrInfo		freeaddrinfo
#	define SetAddrInfoEx	SetAddrInfoExA
#	define GetNameInfo		getnameinfo
#	define WSAEnumNameSpaceProvidersEx	WSAEnumNameSpaceProvidersExA
#	define InetNtop			inet_ntop
#	define InetPton			inet_pton
#endif

#endif//__MINGW32__

#if		( _WIN32_WINNT < 0x0501 )

//WinSock 2 extension -- manifest constants and associated structures for WSANSPIoctl()

#define SIO_NSP_NOTIFY_CHANGE         _WSAIOW(IOC_WS2,25)

typedef enum _WSACOMPLETIONTYPE 
{
    NSP_NOTIFY_IMMEDIATELY = 0,
    NSP_NOTIFY_HWND,
    NSP_NOTIFY_EVENT,
    NSP_NOTIFY_PORT,
    NSP_NOTIFY_APC,
} WSACOMPLETIONTYPE, *PWSACOMPLETIONTYPE, FAR * LPWSACOMPLETIONTYPE;

typedef struct _WSACOMPLETION 
{
    WSACOMPLETIONTYPE Type;
    union 
	{
        struct 
		{
            HWND hWnd;
            UINT uMsg;
            WPARAM context;
        } WindowMessage;
        struct 
		{
            LPWSAOVERLAPPED lpOverlapped;
        } Event;
        struct 
		{
            LPWSAOVERLAPPED lpOverlapped;
            LPWSAOVERLAPPED_COMPLETION_ROUTINE lpfnCompletionProc;
        } Apc;
        struct 
		{
            LPWSAOVERLAPPED lpOverlapped;
            HANDLE hPort;
            ULONG_PTR Key;
        } Port;
    } Parameters;
} WSACOMPLETION, *PWSACOMPLETION, FAR *LPWSACOMPLETION;
#endif

#if		( _WIN32_WINNT < 0x0600 )
typedef struct addrinfoexA
{
    int                 ai_flags;       // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
    int                 ai_family;      // PF_xxx
    int                 ai_socktype;    // SOCK_xxx
    int                 ai_protocol;    // 0 or IPPROTO_xxx for IPv4 and IPv6
    size_t              ai_addrlen;     // Length of ai_addr
    char               *ai_canonname;   // Canonical name for nodename
    struct sockaddr    *ai_addr;        // Binary address
    void               *ai_blob;
    size_t              ai_bloblen;
    LPGUID              ai_provider;
    struct addrinfoexA *ai_next;        // Next structure in linked list
} ADDRINFOEXA, *PADDRINFOEXA, *LPADDRINFOEXA;

typedef struct addrinfoexW
{
    int                 ai_flags;       // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
    int                 ai_family;      // PF_xxx
    int                 ai_socktype;    // SOCK_xxx
    int                 ai_protocol;    // 0 or IPPROTO_xxx for IPv4 and IPv6
    size_t              ai_addrlen;     // Length of ai_addr
    PWSTR               ai_canonname;   // Canonical name for nodename
    struct sockaddr    *ai_addr;        // Binary address
    void               *ai_blob;
    size_t              ai_bloblen;
    LPGUID              ai_provider;
    struct addrinfoexW *ai_next;        // Next structure in linked list
} ADDRINFOEXW, *PADDRINFOEXW, *LPADDRINFOEXW;

#	ifdef UNICODE
		typedef ADDRINFOEXW     ADDRINFOEX, *PADDRINFOEX;
#		define GetAddrInfoEx	GetAddrInfoExW
#		define GetAddrInfo		GetAddrInfoW
#		define FreeAddrInfo		FreeAddrInfoW
#		define SetAddrInfoEx	SetAddrInfoExW
#		define GetNameInfo		GetNameInfoW
#		define WSAEnumNameSpaceProvidersEx	WSAEnumNameSpaceProvidersExW
#		define InetNtop			InetNtopW
#		define InetPton			InetPtonW
#	else
		typedef ADDRINFOEXA     ADDRINFOEX, *PADDRINFOEX;
#		define GetAddrInfoEx	GetAddrInfoExA
#		define GetAddrInfo		getaddrinfo
#		define FreeAddrInfo		freeaddrinfo
#		define SetAddrInfoEx	SetAddrInfoExA
#		define GetNameInfo		getnameinfo
#		define WSAEnumNameSpaceProvidersEx	WSAEnumNameSpaceProvidersExA
#		define InetNtop			inet_ntop
#		define InetPton			inet_pton
#	endif

typedef void ( CALLBACK * LPLOOKUPSERVICE_COMPLETION_ROUTINE)( DWORD dwError, DWORD dwBytes, LPWSAOVERLAPPED lpOverlapped );

typedef struct pollfd 
{
    SOCKET  fd;
    SHORT   events;
    SHORT   revents;

} WSAPOLLFD, *PWSAPOLLFD, FAR *LPWSAPOLLFD;

typedef enum _WSC_PROVIDER_INFO_TYPE 
{
//  InfoType is:                  Info points to:
    ProviderInfoLspCategories, // DWORD (LspCategories)
    ProviderInfoAudit,         // struct WSC_PROVIDER_AUDIT_INFO
} WSC_PROVIDER_INFO_TYPE ;

#endif

namespace qor { namespace nswindows { namespace api {

    class qor_pp_module_interface(QOR_WINAPI_WINSOCK2) WS2 final
    {
    public:

        WS2() = default;
        ~WS2()= default;

        static SOCKET accept(SOCKET s, sockaddr* addr, int* addrlen);
        static BOOL AcceptEx(SOCKET sListenSocket, SOCKET sAcceptSocket, PVOID lpOutputBuffer, DWORD dwReceiveDataLength, DWORD dwLocalAddressLength, DWORD dwRemoteAddressLength, LPDWORD lpdwBytesReceived, LPOVERLAPPED lpOverlapped);
        static VOID GetAcceptExSockaddrs(PVOID lpOutputBuffer, DWORD dwReceiveDataLength, DWORD dwLocalAddressLength, DWORD dwRemoteAddressLength, sockaddr **LocalSockaddr, LPINT LocalSockaddrLength, sockaddr **RemoteSockaddr, LPINT RemoteSockaddrLength);
        static int bind(SOCKET s, const sockaddr* name, int namelen);
        static int closesocket(SOCKET s);
        static int connect(SOCKET s, const sockaddr* name, int namelen);
        static int getpeername(SOCKET s, sockaddr* name, int* namelen);
        static int getsockname(SOCKET s, struct sockaddr* name, int* namelen);
        static int getsockopt(SOCKET s, int level, int optname, char* optval, int* optlen);
        static u_long htonl(u_long hostlong);
        static u_short htons(u_short hostshort);
        static int ioctlsocket(SOCKET s, long cmd, u_long* argp);
        static unsigned long inet_addr(const char* cp);
        static char* inet_ntoa(::in_addr in);
        static int listen(SOCKET s, int backlog);
        static u_long ntohl(u_long netlong);
        static u_short ntohs(u_short netshort);
        static int recv(SOCKET s, char* buf, int len, int flags);
        static int recvfrom(SOCKET s, char* buf, int len, int flags, sockaddr* from, int* fromlen);
        static int select(int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, const ::timeval* timeout);
        static int send(SOCKET s, const char* buf, int len, int flags);
        static int sendto(SOCKET s, const char* buf, int len, int flags, const sockaddr* to, int tolen);
        static int setsockopt(SOCKET s, int level, int optname, const char* optval, int optlen);
        static int shutdown(SOCKET s, int how);
        static SOCKET socket(int af, int type, int protocol);
        static void FreeAddrInfoEx(PADDRINFOEX pAddrInfo);
        static void FreeAddrInfoW(PADDRINFOW pAddrInfo);
        static int GetAddrInfoExA(PCSTR pName, PCSTR pServiceName, DWORD dwNameSpace, LPGUID lpNspId, const ADDRINFOEX* pHints, PADDRINFOEX* ppResult, ::timeval* timeout, LPOVERLAPPED lpOverlapped, LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine, LPHANDLE lpNameHandle);
        static int GetAddrInfoExW(PCWSTR pName, PCWSTR pServiceName, DWORD dwNameSpace, LPGUID lpNspId, const ADDRINFOEX* pHints, PADDRINFOEX* ppResult, ::timeval* timeout, LPOVERLAPPED lpOverlapped, LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine, LPHANDLE lpNameHandle);
        static int GetAddrInfoW(PCWSTR pNodeName, PCWSTR pServiceName, const ADDRINFOW* pHints, PADDRINFOW* ppResult);
        static int GetNameInfoW(const SOCKADDR* pSockaddr, socklen_t SockaddrLength, PWCHAR pNodeBuffer, DWORD NodeBufferSize, PWCHAR pServiceBuffer, DWORD ServiceBufferSize, INT Flags);
        static PCWSTR InetNtopW(INT Family, PVOID pAddr, PWSTR pStringBuf, size_t StringBufSize);
        static INT InetPtonW(INT Family, PCWSTR pszAddrString, PVOID pAddrBuf);
        static int SetAddrInfoExA(PCSTR pName, PCSTR pServiceName, SOCKET_ADDRESS* pAddresses, DWORD dwAddressCount, LPBLOB lpBlob, DWORD dwFlags, DWORD dwNameSpace, LPGUID lpNspId, ::timeval* timeout, LPOVERLAPPED lpOverlapped, LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine, LPHANDLE lpNameHandle);
        static int SetAddrInfoExW(PCWSTR pName, PCWSTR pServiceName, SOCKET_ADDRESS* pAddresses, DWORD dwAddressCount, LPBLOB lpBlob, DWORD dwFlags, DWORD dwNameSpace, LPGUID lpNspId, ::timeval* timeout, LPOVERLAPPED lpOverlapped, LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine, LPHANDLE lpNameHandle);
        static SOCKET WSAAccept(SOCKET s, sockaddr* addr, LPINT addrlen, LPCONDITIONPROC lpfnCondition, DWORD_PTR dwCallbackData);
        static INT WSAAddressToStringA(LPSOCKADDR lpsaAddress, DWORD dwAddressLength, LPWSAPROTOCOL_INFO lpProtocolInfo, LPSTR lpszAddressString, LPDWORD lpdwAddressStringLength);
        static INT WSAAddressToStringW(LPSOCKADDR lpsaAddress, DWORD dwAddressLength, LPWSAPROTOCOL_INFO lpProtocolInfo, LPWSTR lpszAddressString, LPDWORD lpdwAddressStringLength);
        static INT WSAAdvertiseProvider(const ::GUID* puuidProviderId, const LPCNSPV2_ROUTINE* pNSPv2Routine);
        static BOOL WSACloseEvent(WSAEVENT hEvent);
        static int WSAConnect(SOCKET s, const sockaddr* name, int namelen, LPWSABUF lpCallerData, LPWSABUF lpCalleeData, LPQOS lpSQOS, LPQOS lpGQOS);
        static BOOL WSAConnectByList(SOCKET s, PSOCKET_ADDRESS_LIST SocketAddressList, LPDWORD LocalAddressLength, LPSOCKADDR LocalAddress, LPDWORD RemoteAddressLength, LPSOCKADDR RemoteAddress, const ::timeval* timeout, LPWSAOVERLAPPED Reserved);
        static BOOL WSAConnectByNameA(SOCKET s, LPSTR nodename, LPSTR servicename, LPDWORD LocalAddressLength, LPSOCKADDR LocalAddress, LPDWORD RemoteAddressLength, LPSOCKADDR RemoteAddress, const ::timeval* timeout, LPWSAOVERLAPPED Reserved);
        static BOOL WSAConnectByNameW(SOCKET s, LPWSTR nodename, LPWSTR servicename, LPDWORD LocalAddressLength, LPSOCKADDR LocalAddress, LPDWORD RemoteAddressLength, LPSOCKADDR RemoteAddress, const ::timeval* timeout, LPWSAOVERLAPPED Reserved);
        static WSAEVENT WSACreateEvent(void);
        static int WSADuplicateSocketA(SOCKET s, DWORD dwProcessId, LPWSAPROTOCOL_INFO lpProtocolInfo);
        static int WSADuplicateSocketW(SOCKET s, DWORD dwProcessId, LPWSAPROTOCOL_INFO lpProtocolInfo);
        static INT WSAEnumNameSpaceProvidersA(LPDWORD lpdwBufferLength, LPWSANAMESPACE_INFO lpnspBuffer);
        static INT WSAEnumNameSpaceProvidersExA(LPDWORD lpdwBufferLength, LPWSANAMESPACE_INFOEX lpnspBuffer);
        static hostent* gethostbyaddr(const char* addr, int len, int type);
        static hostent* gethostbyname(const char* name);
        static ::PROTOENT* getprotobyname(const char* name);
        static ::PROTOENT* getprotobynumber(int number);
        static servent* getservbyname(const char* name, const char* proto);
        static servent* getservbyport(int port, const char* proto);
        static int gethostname(char* name, int namelen);
        static INT WSAEnumNameSpaceProvidersExW(LPDWORD lpdwBufferLength, LPWSANAMESPACE_INFOEX lpnspBuffer);
        static INT WSAEnumNameSpaceProvidersW(LPDWORD lpdwBufferLength, LPWSANAMESPACE_INFO lpnspBuffer);
        static int WSAEnumNetworkEvents(SOCKET s, WSAEVENT hEventObject, LPWSANETWORKEVENTS lpNetworkEvents);
        static int WSAEnumProtocolsA(LPINT lpiProtocols, LPWSAPROTOCOL_INFO lpProtocolBuffer, LPDWORD lpdwBufferLength);
        static int WSAEnumProtocolsW(LPINT lpiProtocols, LPWSAPROTOCOL_INFO lpProtocolBuffer, LPDWORD lpdwBufferLength);
        static int WSAEventSelect(SOCKET s, WSAEVENT hEventObject, long lNetworkEvents);
        static BOOL WSAGetOverlappedResult(SOCKET s, LPWSAOVERLAPPED lpOverlapped, LPDWORD lpcbTransfer, BOOL fWait, LPDWORD lpdwFlags);
        static BOOL WSAGetQOSByName(SOCKET s, LPWSABUF lpQOSName, LPQOS lpQOS);
        static INT WSAGetServiceClassInfoA(LPGUID lpProviderId, LPGUID lpServiceClassId, LPDWORD lpdwBufferLength, LPWSASERVICECLASSINFO lpServiceClassInfo);
        static INT WSAGetServiceClassInfoW(LPGUID lpProviderId, LPGUID lpServiceClassId, LPDWORD lpdwBufferLength, LPWSASERVICECLASSINFO lpServiceClassInfo);
        static INT WSAGetServiceClassNameByClassIdA(LPGUID lpServiceClassId, LPSTR lpszServiceClassName, LPDWORD lpdwBufferLength);
        static INT WSAGetServiceClassNameByClassIdW(LPGUID lpServiceClassId, LPWSTR lpszServiceClassName, LPDWORD lpdwBufferLength);
        static int WSAHtonl(SOCKET s, u_long hostlong, u_long* lpnetlong);
        static int WSAHtons(SOCKET s, u_short hostshort, u_short* lpnetshort);
        static INT WSAInstallServiceClassA(LPWSASERVICECLASSINFO lpServiceClassInfo);
        static INT WSAInstallServiceClassW(LPWSASERVICECLASSINFO lpServiceClassInfo);
        static int WSAIoctl(SOCKET s, DWORD dwIoControlCode, LPVOID lpvInBuffer, DWORD cbInBuffer, LPVOID lpvOutBuffer, DWORD cbOutBuffer, LPDWORD lpcbBytesReturned, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
        static SOCKET WSAJoinLeaf(SOCKET s, const sockaddr* name, int namelen, LPWSABUF lpCallerData, LPWSABUF lpCalleeData, LPQOS lpSQOS, LPQOS lpGQOS, DWORD dwFlags);
        static INT WSALookupServiceBeginA(LPWSAQUERYSET lpqsRestrictions, DWORD dwControlFlags, LPHANDLE lphLookup);
        static INT WSALookupServiceBeginW(LPWSAQUERYSET lpqsRestrictions, DWORD dwControlFlags, LPHANDLE lphLookup);
        static INT WSALookupServiceEnd(HANDLE hLookup);
        static INT WSALookupServiceNextA(HANDLE hLookup, DWORD dwControlFlags, LPDWORD lpdwBufferLength, LPWSAQUERYSET lpqsResults);
        static INT WSALookupServiceNextW(HANDLE hLookup, DWORD dwControlFlags, LPDWORD lpdwBufferLength, LPWSAQUERYSET lpqsResults);
        static int WSANSPIoctl(HANDLE hLookup, DWORD dwControlCode, LPVOID lpvInBuffer, DWORD cbInBuffer, LPVOID lpvOutBuffer, DWORD cbOutBuffer, LPDWORD lpcbBytesReturned, LPWSACOMPLETION lpCompletion);
        static int WSANtohl(SOCKET s, u_long netlong, u_long* lphostlong);
        static int WSANtohs(SOCKET s, u_short netshort, u_short* lphostshort);
        static int WSAPoll(WSAPOLLFD fdarray[], ULONG nfds, INT timeout);
        static INT WSAProviderCompleteAsyncCall(HANDLE hAsyncCall, INT iRetCode);
        static int WSAProviderConfigChange(LPHANDLE lpNotificationHandle, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
        static int WSARecv(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesRecvd, LPDWORD lpFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
        static int WSARecvDisconnect(SOCKET s, LPWSABUF lpInboundDisconnectData);
        static int WSARecvFrom(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesRecvd, LPDWORD lpFlags, struct sockaddr* lpFrom, LPINT lpFromLen, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
        static INT WSARemoveServiceClass(LPGUID lpServiceClassId);
        static BOOL WSAResetEvent(WSAEVENT hEvent);
        static int WSASend(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesSent, DWORD dwFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
        static int WSASendDisconnect(SOCKET s, LPWSABUF lpOutboundDisconnectData);
        static int WSASendMsg(SOCKET s, LPWSAMSG lpMsg, DWORD dwFlags, LPDWORD lpNumberOfBytesSent, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
        static int WSASendTo(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesSent, DWORD dwFlags, const sockaddr* lpTo, int iToLen, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
        static BOOL WSASetEvent(WSAEVENT hEvent);
        static INT WSASetServiceA(LPWSAQUERYSET lpqsRegInfo, WSAESETSERVICEOP essOperation, DWORD dwControlFlags);
        static INT WSASetServiceW(LPWSAQUERYSET lpqsRegInfo, WSAESETSERVICEOP essOperation, DWORD dwControlFlags);
        static SOCKET WSASocketA(int af, int type, int protocol, LPWSAPROTOCOL_INFO lpProtocolInfo, GROUP g, DWORD dwFlags);
        static SOCKET WSASocketW(int af, int type, int protocol, LPWSAPROTOCOL_INFO lpProtocolInfo, GROUP g, DWORD dwFlags);
        static int WSAAsyncSelect(SOCKET s, HWND hWnd, unsigned int wMsg, long lEvent);
        static HANDLE WSAAsyncGetHostByAddr(HWND hWnd, unsigned int wMsg, const char* addr, int len, int type, char* buf, int buflen);
        static HANDLE WSAAsyncGetHostByName(HWND hWnd, unsigned int wMsg, const char* name, char* buf, int buflen);
        static HANDLE WSAAsyncGetProtoByNumber(HWND hWnd, unsigned int wMsg, int number, char* buf, int buflen);
        static HANDLE WSAAsyncGetProtoByName(HWND hWnd, unsigned int wMsg, const char* name, char* buf, int buflen);
        static HANDLE WSAAsyncGetServByPort(HWND hWnd, unsigned int wMsg, int port, const char* proto, char* buf, int buflen);
        static HANDLE WSAAsyncGetServByName(HWND hWnd, unsigned int wMsg, const char* name, const char* proto, char* buf, int buflen);
        static int WSACancelAsyncRequest(HANDLE hAsyncTaskHandle);
        static int WSAGetLastError(void);
        static void WSASetLastError(int iError);
        static int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
        static int WSACleanup(void);
        static INT WSAStringToAddressA(LPSTR AddressString, INT AddressFamily, LPWSAPROTOCOL_INFO lpProtocolInfo, LPSOCKADDR lpAddress, LPINT lpAddressLength);
        static INT WSAStringToAddressW(LPWSTR AddressString, INT AddressFamily, LPWSAPROTOCOL_INFO lpProtocolInfo, LPSOCKADDR lpAddress, LPINT lpAddressLength);
        static INT WSAUnadvertiseProvider(const ::GUID* puuidProviderId);
        static DWORD WSAWaitForMultipleEvents(DWORD cEvents, const WSAEVENT* lphEvents, BOOL fWaitAll, DWORD dwTimeout, BOOL fAlertable);
        static int WSCDeinstallProvider(LPGUID lpProviderId, LPINT lpErrno);
        static int WSCEnableNSProvider(LPGUID lpProviderId, BOOL fEnable);
        static int WSCEnumProtocols(LPINT lpiProtocols, LPWSAPROTOCOL_INFOW lpProtocolBuffer, LPDWORD lpdwBufferLength, LPINT lpErrno);
        static int WSCGetApplicationCategory(LPCWSTR Path, DWORD PathLength, LPCWSTR Extra, DWORD ExtraLength, DWORD* pPermittedLspCategories, LPINT lpErrno);
        static int WSCGetProviderInfo(LPGUID lpProviderId, WSC_PROVIDER_INFO_TYPE InfoType, PBYTE Info, size_t* InfoSize, DWORD Flags, LPINT lpErrno);
        static int WSCGetProviderPath(LPGUID lpProviderId, LPWSTR lpszProviderDllPath, LPINT lpProviderDllPathLen, LPINT lpErrno);
        static int WSCInstallNameSpace(LPWSTR lpszIdentifier, LPWSTR lpszPathName, DWORD dwNameSpace, DWORD dwVersion, LPGUID lpProviderId);
        static int WSCInstallNameSpaceEx(LPWSTR lpszIdentifier, LPWSTR lpszPathName, DWORD dwNameSpace, DWORD dwVersion, LPGUID lpProviderId, LPBLOB lpProviderInfo);
        static int WSCInstallProvider(const LPGUID lpProviderId, const LPWSTR lpszProviderDllPath, const LPWSAPROTOCOL_INFO lpProtocolInfoList, DWORD dwNumberOfEntries, LPINT lpErrno);
        static int WSCInstallProviderAndChains(const LPGUID lpProviderId, const LPWSTR lpszProviderDllPath, const LPWSTR lpszLspName, DWORD dwServiceFlags, const LPWSAPROTOCOL_INFO lpProtocolInfoList, DWORD dwNumberOfEntries, LPDWORD lpdwCatalogEntryId, LPINT lpErrno);
        static int WSCSetApplicationCategory(LPCWSTR Path, DWORD PathLength, LPCWSTR Extra, DWORD ExtraLength, DWORD PermittedLspCategories, DWORD* pPrevPermLspCat, LPINT lpErrno);
        static int WSCSetProviderInfo(LPGUID lpProviderId, WSC_PROVIDER_INFO_TYPE InfoType, PBYTE Info, size_t InfoSize, DWORD Flags, LPINT lpErrno);
        static int WSCUnInstallNameSpace(LPGUID lpProviderId);
        static int WSCUpdateProvider(LPGUID lpProviderId, const WCHAR* lpszProviderDllPath, const LPWSAPROTOCOL_INFO lpProtocolInfoList, DWORD dwNumberOfEntries, LPINT lpErrno);
        static int WSCWriteNameSpaceOrder(LPGUID lpProviderId, DWORD dwNumberOfEntries);
        static int WSCWriteProviderOrder(LPDWORD lpwdCatalogEntryId, DWORD dwNumberOfEntries);
        static int __WSAFDIsSet(SOCKET fd, fd_set* set);
        static void freeaddrinfo(addrinfo* ai);
        static int getaddrinfo(PCSTR pNodeName, PCSTR pServiceName, const ADDRINFOA* pHints, PADDRINFOA* ppResult);
        static int getnameinfo(const sockaddr* sa, socklen_t salen, char* host, DWORD hostlen, char* serv, DWORD servlen, int flags);
        static PCSTR inet_ntop(INT Family, PVOID pAddr, PSTR pStringBuf, size_t StringBufSize);
        static INT inet_pton(INT Family, PCSTR pszAddrString, PVOID pAddrBuf);

    };

}}}//qor::nswindows::api

#endif//QOR_PP_H_WINDOWS_API_WS2

