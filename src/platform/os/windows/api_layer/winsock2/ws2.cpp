// Copyright Querysoft Limited 2008 - 2025
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "src/configuration/configuration.h"

#include "src/qor/module/module.h"
#include "src/qor/interception/functioncontext.h"

#include "ws2.h"
#include "../kernel/kernel32.h" //kernel32.h must be the first windows header as it's the primary inclusion point for windows.h
#include "../library.h"
#include "errorcheck.h"

namespace {
	size_t s_winsockInitCount = 0;
}

namespace qor { namespace nswindows { namespace api {

	SOCKET WS2::accept( SOCKET s, sockaddr* addr, int* addrlen )
	{
		qor_pp_fcontext;
		CheckReturn< SOCKET, TCheckWinsockFailureValue< SOCKET, INVALID_SOCKET> >::TType Result;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi(ws2_32, accept );
        Result = Library::Call< SOCKET, SOCKET, sockaddr*, int* >( pFunc, s, addr, addrlen );
#else
		qor_pp_unref3( s, addr, addrlen );		
		continuable("Requires Windows 2000 Professional");
#endif
		return Result;
	}

	BOOL WS2::AcceptEx(SOCKET sListenSocket, SOCKET sAcceptSocket, PVOID lpOutputBuffer, DWORD dwReceiveDataLength, DWORD dwLocalAddressLength, DWORD dwRemoteAddressLength, LPDWORD lpdwBytesReceived, LPOVERLAPPED lpOverlapped)
	{
		qor_pp_fcontext;
		CheckReturn< BOOL, TCheckWinsockFailureValue< BOOL, FALSE> >::TType Result;
		Result = ::AcceptEx(sListenSocket, sAcceptSocket, lpOutputBuffer, dwReceiveDataLength, dwLocalAddressLength, dwRemoteAddressLength, lpdwBytesReceived, lpOverlapped);
		return Result;
	}

	VOID WS2::GetAcceptExSockaddrs(PVOID lpOutputBuffer, DWORD dwReceiveDataLength, DWORD dwLocalAddressLength, DWORD dwRemoteAddressLength, sockaddr **LocalSockaddr, LPINT LocalSockaddrLength, sockaddr **RemoteSockaddr, LPINT RemoteSockaddrLength)
	{
		qor_pp_fcontext;
		::GetAcceptExSockaddrs(lpOutputBuffer, dwReceiveDataLength, dwLocalAddressLength, dwRemoteAddressLength, LocalSockaddr, LocalSockaddrLength, RemoteSockaddr, RemoteSockaddrLength);
	}

	int WS2::bind( SOCKET s, const sockaddr* name, int namelen )
	{
		qor_pp_fcontext;
		CheckReturn< int, TCheckWinsockFailureValue< int, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi(ws2_32, bind );
		iResult = Library::Call< int, SOCKET, const sockaddr*, int >( pFunc, s, name, namelen );
#else
		qor_pp_unref3( s, name, namelen );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}
	
	int WS2::closesocket( SOCKET s )
	{
		qor_pp_fcontext;
		CheckReturn< int, TCheckWinsockFailureValue< int, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi(ws2_32, closesocket);
		iResult = Library::Call< int, SOCKET >( pFunc, s );
#else
		qor_pp_unref( s );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}
	
	int WS2::connect( SOCKET s, const sockaddr* name, int namelen )
	{
		qor_pp_fcontext;
		CheckReturn< int, TCheckWinsockFailureValue< int, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi(ws2_32, connect);
		iResult = Library::Call< int, SOCKET, const sockaddr*, int >( pFunc, s, name, namelen );
#else
		qor_pp_unref3( s, name, namelen );
		continuable(_TXT("Requires Windows 2000 Professional"));
#endif
		return iResult;
	}
	
	int WS2::getpeername( SOCKET s, sockaddr* name, int* namelen )
	{
		qor_pp_fcontext;
		CheckReturn< int, TCheckWinsockFailureValue< int, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, getpeername );
		iResult = Library::Call< int, SOCKET, sockaddr*, int* >( pFunc, s, name, namelen );
#else
		qor_pp_unref3( s, name, namelen );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}
	
	int WS2::getsockname( SOCKET s, struct sockaddr* name, int* namelen )
	{
		qor_pp_fcontext;
		CheckReturn< int, TCheckWinsockFailureValue< int, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi(ws2_32, getsockname);
		iResult = Library::Call< int, SOCKET, sockaddr*, int* >( pFunc, s, name, namelen );
#else
		qor_pp_unref3( s, name, namelen );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}
	
	int WS2::getsockopt( SOCKET s, int level, int optname, char* optval, int* optlen )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, getsockopt );
		iResult = Library::Call< int, SOCKET, int, int, char*, int* >( pFunc, s, level, optname, optval, optlen );
#else
		qor_pp_unref5( s, level, optname, optval, optlen );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}
	
	u_long WS2::htonl( u_long hostlong )
	{
		qor_pp_fcontext;
		u_long ulResult = 0;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, htonl );
		ulResult = Library::Call< u_long, u_long >( pFunc, hostlong );
#else
		qor_pp_unref( hostlong );
		continuable("Requires Windows 2000 Professional");
#endif
		return ulResult;
	}
	
	u_short WS2::htons( u_short hostshort )
	{
		qor_pp_fcontext;
		u_short Result = 0;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, htons );
		Result = Library::Call< u_short, u_short >( pFunc, hostshort );
#else
		qor_pp_unref( hostshort );
		continuable("Requires Windows 2000 Professional");
#endif
		return Result;
	}

	int WS2::ioctlsocket( SOCKET s, long cmd, u_long* argp )
	{
		qor_pp_fcontext;
		CheckReturn< int, TCheckWinsockFailureValue< int, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, ioctlsocket );
		iResult = Library::Call< int, SOCKET, long, u_long* >( pFunc, s, cmd, argp );
#else
		qor_pp_unref3( s, cmd, argp );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}
	
	unsigned long WS2::inet_addr( const char* cp )
	{
		qor_pp_fcontext;
		unsigned long ulResult = 0;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, inet_addr );
		ulResult = Library::Call< unsigned long, const char* >( pFunc, cp );
#else
		qor_pp_unref( cp );
		continuable("Requires Windows 2000 Professional");
#endif
		return ulResult;
	}
	
	char* WS2::inet_ntoa( in_addr in )
	{
		qor_pp_fcontext;
		char* pResult = 0;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, inet_ntoa );
		pResult = Library::Call< char*, in_addr >( pFunc, in );
#else
		qor_pp_unref( in );
		continuable("Requires Windows 2000 Professional");
#endif
		return pResult;
	}

	
	int WS2::listen( SOCKET s, int backlog )
	{
		qor_pp_fcontext;
		CheckReturn< int, TCheckWinsockFailureValue< int, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, listen );
		iResult = Library::Call< int, SOCKET, int >( pFunc, s, backlog );
#else
		qor_pp_unref2( s, backlog );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	u_long WS2::ntohl( u_long netlong )
	{
		qor_pp_fcontext;
		u_long ulResult = 0;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, ntohl );
		ulResult = Library::Call< u_long, u_long >( pFunc, netlong );
#else
		qor_pp_unref( netlong );
		continuable("Requires Windows 2000 Professional");
#endif
		return ulResult;
	}

	
	u_short WS2::ntohs( u_short netshort )
	{
		qor_pp_fcontext;
		u_short usResult = 0;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, ntohs );
		usResult = Library::Call< u_short, u_short >( pFunc, netshort );
#else
		qor_pp_unref( netshort );
		continuable("Requires Windows 2000 Professional");
#endif
		return usResult;
	}

	
	int WS2::recv( SOCKET s, char* buf, int len, int flags )
	{
		qor_pp_fcontext;
		CheckReturn< int, TCheckWinsockFailureValue< int, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, recv );
		iResult = Library::Call< int, SOCKET, char*, int, int >( pFunc, s, buf, len, flags );
#else
		qor_pp_unref4( s, buf, len, flags );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::recvfrom( SOCKET s, char* buf, int len, int flags, sockaddr* from, int* fromlen )
	{
		qor_pp_fcontext;
		CheckReturn< int, TCheckWinsockFailureValue< int, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, recvfrom );
		iResult = Library::Call< int, SOCKET, char*, int, int, sockaddr*, int* >( pFunc, s, buf, len, flags, from, fromlen );
#else
		qor_pp_unref6( s, buf, len, flags, from fromlen );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::select( int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, const timeval* timeout )
	{
		qor_pp_fcontext;
		CheckReturn< int, TCheckWinsockFailureValue< int, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, select );
		iResult = Library::Call< int, int, fd_set*, fd_set*, fd_set*, const timeval* >( pFunc, nfds, readfds, writefds, exceptfds, timeout );
#else
		qor_pp_unref5( nfds, readfds, writefds, exceptfds, timeout );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::send( SOCKET s, const char* buf, int len, int flags )
	{
		qor_pp_fcontext;
		CheckReturn< int, TCheckWinsockFailureValue< int, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, send );
		iResult = Library::Call< int, SOCKET, const char*, int, int >( pFunc, s, buf, len, flags );
#else
		qor_pp_unref4( s, buf, len, flags );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::sendto( SOCKET s, const char* buf, int len, int flags, const sockaddr* to, int tolen )
	{
		qor_pp_fcontext;
		CheckReturn< int, TCheckWinsockFailureValue< int, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, sendto );
		iResult = Library::Call< int, SOCKET, const char*, int, int, const sockaddr*, int >( pFunc, s, buf, len, flags, to, tolen );
#else
		qor_pp_unref6( s, buf, len, flags, to, tolen );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::setsockopt( SOCKET s, int level, int optname, const char* optval, int optlen )
	{
		qor_pp_fcontext;
		CheckReturn< int, TCheckWinsockFailureValue< int, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, setsockopt );
		iResult = Library::Call< int, SOCKET, int, int, const char*, int >( pFunc, s, level, optname, optval, optlen );
#else
		qor_pp_unref4( s, level, optname, optval, optlen );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::shutdown( SOCKET s, int how )
	{
		qor_pp_fcontext;
		if(s_winsockInitCount == 0)
		{
			return -1;//Winsock has already gone away
		}
		CheckReturn< int, TCheckWinsockFailureValue< int, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, shutdown );
		iResult = Library::Call< int, SOCKET, int >( pFunc, s, how );
#else
		qor_pp_unref2( s, how );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	SOCKET WS2::socket( int af, int type, int protocol )
	{
		qor_pp_fcontext;
		CheckReturn< SOCKET, TCheckWinsockFailureValue< SOCKET, SOCKET_ERROR> >::TType Result;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, socket );
		Result = Library::Call< SOCKET, int, int, int >( pFunc, af, type, protocol );
#else
		qor_pp_unref3( af, type, protocol );
		continuable("Requires Windows 2000 Professional");
#endif
		return Result;
	}

	
	void WS2::FreeAddrInfoEx( PADDRINFOEX pAddrInfo )
	{
		qor_pp_fcontext;
#if		( _WIN32_WINNT >= 0x0600 )
		qor_pp_useswinapi( ws2_32, FreeAddrInfoEx );
		Library::voidCall< PADDRINFOEX >( pFunc, pAddrInfo );
#else
		qor_pp_unref( pAddrInfo );
		continuable("Requires Windows Vista");
#endif
	}

	
	void WS2::FreeAddrInfoW( PADDRINFOW pAddrInfo )
	{
		qor_pp_fcontext;
#if		( _WIN32_WINNT >= 0x0502 )
		qor_pp_useswinapi( ws2_32, FreeAddrInfoW );
		Library::voidCall< PADDRINFOW >( pFunc, pAddrInfo );
#else
		qor_pp_unref( pAddrInfo );
		continuable("Requires Windows XP Service Pack2");
#endif
	}

	
	int WS2::GetAddrInfoExA( PCSTR pName, PCSTR pServiceName, DWORD dwNameSpace, LPGUID lpNspId, const ADDRINFOEX* pHints, PADDRINFOEX* ppResult, timeval* timeout, LPOVERLAPPED lpOverlapped, LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine, LPHANDLE lpNameHandle )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0600 )
		qor_pp_useswinapi( ws2_32, GetAddrInfoExA );
		iResult = Library::Call< int, PCSTR, PCSTR, DWORD, LPGUID, const ADDRINFOEX*, PADDRINFOEX*, timeval*, LPOVERLAPPED, LPLOOKUPSERVICE_COMPLETION_ROUTINE, LPHANDLE >( pFunc, pName, pServiceName, dwNameSpace, lpNspId, pHints, ppResult, timeout, lpOverlapped, lpCompletionRoutine, lpNameHandle );
#else
		qor_pp_unref10( pName, pServiceName, dwNameSpace, lpNameHandle, lpNspId, pHints, ppResult, timeout, lpOverlapped, lpCompletionRoutine );
		continuable("Requires Windows Vista");
#endif
		return iResult;
	}

	
	int WS2::GetAddrInfoExW( PCWSTR pName, PCWSTR pServiceName, DWORD dwNameSpace, LPGUID lpNspId, const ADDRINFOEX* pHints, PADDRINFOEX* ppResult, timeval* timeout, LPOVERLAPPED lpOverlapped, LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine, LPHANDLE lpNameHandle )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0600 )
		qor_pp_useswinapi( ws2_32, GetAddrInfoExW );
		iResult = Library::Call< int, PCWSTR, PCWSTR, DWORD, LPGUID, const ADDRINFOEX*, PADDRINFOEX*, timeval*, LPOVERLAPPED, LPLOOKUPSERVICE_COMPLETION_ROUTINE, LPHANDLE >( pFunc, pName, pServiceName, dwNameSpace, lpNspId, pHints, ppResult, timeout, lpOverlapped, lpCompletionRoutine, lpNameHandle );
#else
		qor_pp_unref10( pName, pServiceName, dwNameSpace, lpNameHandle, lpNspId, pHints, ppResult, timeout, lpOverlapped, lpCompletionRoutine );
		continuable("Requires Windows Vista");
#endif
		return iResult;
	}

	
	int WS2::GetAddrInfoW( PCWSTR pNodeName, PCWSTR pServiceName, const ADDRINFOW* pHints, PADDRINFOW* ppResult )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0502 )
		qor_pp_useswinapi( ws2_32, GetAddrInfoW );
		iResult = Library::Call< int, PCWSTR, PCWSTR, const ADDRINFOW*, PADDRINFOW* >( pFunc, pNodeName, pServiceName, pHints, ppResult );
#else
		qor_pp_unref4( pNodeName, pServiceName, pHints, ppResult );
		continuable("Requires Windows XP Service Pack2");
#endif
		return iResult;
	}

	
	int WS2::GetNameInfoW( const SOCKADDR* pSockaddr, socklen_t SockaddrLength, PWCHAR pNodeBuffer, DWORD NodeBufferSize, PWCHAR pServiceBuffer, DWORD ServiceBufferSize, INT Flags )
	{
		qor_pp_fcontext;
		CheckReturn< int, TSuccessCheck< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0502 )
		qor_pp_useswinapi( ws2_32, GetNameInfoW );
		iResult = Library::Call< int, const SOCKADDR*, socklen_t, PWCHAR, DWORD, PWCHAR, DWORD, INT >( pFunc, pSockaddr, SockaddrLength, pNodeBuffer, NodeBufferSize, pServiceBuffer, ServiceBufferSize, Flags );
#else
		qor_pp_unref7( pSockaddr, SockaddrLength, pNodeBuffer, NodeBufferSize, pServiceBuffer, ServiceBufferSize, Flags );
		continuable("Requires Windows XP Service Pack2");
#endif
		return iResult;
	}

	
	PCWSTR WS2::InetNtopW( INT Family, PVOID pAddr, PWSTR pStringBuf, size_t StringBufSize )
	{
		qor_pp_fcontext;
		CheckReturn< PCWSTR, CheckNullPointerIsWinsockFailure< PCWSTR> >::TType pResult;
#if		( _WIN32_WINNT >= 0x0600 )
		qor_pp_useswinapi( ws2_32, InetNtopW );
		pResult = Library::Call< PCWSTR, INT, PVOID, PWSTR, size_t >( pFunc, Family, pAddr, pStringBuf, StringBufSize );
#else
		qor_pp_unref4( Family, pAddr, pStringBuf, StringBufSize );
		continuable("Requires Windows Vista");
#endif
		return pResult;
	}

	
	INT WS2::InetPtonW( INT Family, PCWSTR pszAddrString, PVOID pAddrBuf )
	{
		qor_pp_fcontext;
		CheckReturn< INT, TCheckWinsockFailureValue< INT, -1> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0600 )
		qor_pp_useswinapi( ws2_32, InetPtonW );
		iResult = Library::Call< INT, INT, PCWSTR, PVOID >( pFunc, Family, pszAddrString, pAddrBuf );
#else
		qor_pp_unref3( Family, pszAddrString, pAddrBuf );
		continuable("Requires Windows Vista");
#endif
		return iResult;
	}

	
	int WS2::SetAddrInfoExA( PCSTR pName, PCSTR pServiceName, SOCKET_ADDRESS* pAddresses, DWORD dwAddressCount, LPBLOB lpBlob, DWORD dwFlags, DWORD dwNameSpace, LPGUID lpNspId, timeval* timeout, LPOVERLAPPED lpOverlapped, LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine, LPHANDLE lpNameHandle )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, SetAddrInfoExA );
		iResult = Library::Call< int, PCSTR, PCSTR, SOCKET_ADDRESS*, DWORD, LPBLOB, DWORD, DWORD, LPGUID, timeval*, LPOVERLAPPED, LPLOOKUPSERVICE_COMPLETION_ROUTINE, LPHANDLE >( pFunc, pName, pServiceName, pAddresses, dwAddressCount, lpBlob, dwFlags, dwNameSpace, lpNspId, timeout, lpOverlapped, lpCompletionRoutine, lpNameHandle );
#else
		qor_pp_unref8( pName, pServiceName, pAddresses, dwAddressCount, lpBlob, dwFlags, dwNameSpace, lpNspId );
		qor_pp_unref4( timeout, lpOverlapped, lpCompletionRoutine, lpNameHandle );
		continuable("Requires Windows Vista");
#endif
		return iResult;
	}

	
	int WS2::SetAddrInfoExW( PCWSTR pName, PCWSTR pServiceName, SOCKET_ADDRESS* pAddresses, DWORD dwAddressCount, LPBLOB lpBlob, DWORD dwFlags, DWORD dwNameSpace, LPGUID lpNspId, timeval* timeout, LPOVERLAPPED lpOverlapped, LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine, LPHANDLE lpNameHandle )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0600 )
		qor_pp_useswinapi( ws2_32, SetAddrInfoExW );
		iResult = Library::Call< int, PCWSTR, PCWSTR, SOCKET_ADDRESS*, DWORD, LPBLOB, DWORD, DWORD, LPGUID, timeval*, LPOVERLAPPED, LPLOOKUPSERVICE_COMPLETION_ROUTINE, LPHANDLE >( pFunc, pName, pServiceName, pAddresses, dwAddressCount, lpBlob, dwFlags, dwNameSpace, lpNspId, timeout, lpOverlapped, lpCompletionRoutine, lpNameHandle );
#else
		qor_pp_unref8( pName, pServiceName, pAddresses, dwAddressCount, lpBlob, dwFlags, dwNameSpace, lpNspId );
		qor_pp_unref4( timeout, lpOverlapped, lpCompletionRoutine, lpNameHandle );
		continuable("Requires Windows Vista");
#endif
		return iResult;
	}

	
	SOCKET WS2::WSAAccept( SOCKET s, sockaddr* addr, LPINT addrlen, LPCONDITIONPROC lpfnCondition, DWORD_PTR dwCallbackData )
	{
		qor_pp_fcontext;
		CheckReturn< SOCKET, TCheckWinsockFailureValue< SOCKET, INVALID_SOCKET> >::TType Result;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAAccept );
		Result = Library::Call< SOCKET, SOCKET, sockaddr*, LPINT, LPCONDITIONPROC, DWORD >( pFunc, s, addr, addrlen, lpfnCondition, static_cast<DWORD>(dwCallbackData) );
#else
		qor_pp_unref5( s, addr, addrlen, lpfnCondition, dwCallbackData );
		continuable("Requires Windows 2000 Professional");
#endif
		return Result;
	}

	
	INT WS2::WSAAddressToStringA( LPSOCKADDR lpsaAddress, DWORD dwAddressLength, LPWSAPROTOCOL_INFO lpProtocolInfo, LPSTR lpszAddressString, LPDWORD lpdwAddressStringLength )
	{
		qor_pp_fcontext;
		CheckReturn< INT, CheckNonZeroIsWinsockFailure< INT> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAAddressToStringA );
		iResult = Library::Call< INT, LPSOCKADDR, DWORD, LPWSAPROTOCOL_INFO, LPSTR, LPDWORD >( pFunc, lpsaAddress, dwAddressLength, lpProtocolInfo, lpszAddressString, lpdwAddressStringLength );
#else
		qor_pp_unref5( lpsaAddress, dwAddressLength, lpProtocolInfo, lpszAddressString, lpdwAddressStringLength );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	INT WS2::WSAAddressToStringW( LPSOCKADDR lpsaAddress, DWORD dwAddressLength, LPWSAPROTOCOL_INFO lpProtocolInfo, LPWSTR lpszAddressString, LPDWORD lpdwAddressStringLength )
	{
		qor_pp_fcontext;
		CheckReturn< INT, CheckNonZeroIsWinsockFailure< INT> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAAddressToStringW );
		iResult = Library::Call< INT, LPSOCKADDR, DWORD, LPWSAPROTOCOL_INFO, LPWSTR, LPDWORD >( pFunc, lpsaAddress, dwAddressLength, lpProtocolInfo, lpszAddressString, lpdwAddressStringLength );
#else
		qor_pp_unref5( lpsaAddress, dwAddressLength, lpProtocolInfo, lpszAddressString, lpdwAddressStringLength );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	INT WS2::WSAAdvertiseProvider( const ::GUID* puuidProviderId, const LPCNSPV2_ROUTINE* pNSPv2Routine )
	{
		qor_pp_fcontext;
		CheckReturn< INT, CheckNonZeroIsWinsockFailure< INT> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0600 )
		qor_pp_useswinapi( ws2_32, WSAAdvertiseProvider );
		iResult = Library::Call< INT, const ::GUID*, const LPCNSPV2_ROUTINE* >( pFunc, puuidProviderId, pNSPv2Routine );
#else
		qor_pp_unref2( puuidProviderId, pNSPv2Routine );
		continuable("Requires Windows Vista");
#endif
		return iResult;	
	}

	
	BOOL WS2::WSACloseEvent( WSAEVENT hEvent )
	{
		qor_pp_fcontext;
		CheckReturn< BOOL, TCheckWinsockFailureValue<BOOL, FALSE> >::TType bResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSACloseEvent );
		bResult = Library::Call< BOOL, WSAEVENT >( pFunc, hEvent );
#else
		qor_pp_unref( hEvent );
		continuable("Requires Windows 2000 Professional");
#endif
		return bResult;
	}

	
	int WS2::WSAConnect( SOCKET s, const sockaddr* name, int namelen, LPWSABUF lpCallerData, LPWSABUF lpCalleeData, LPQOS lpSQOS, LPQOS lpGQOS )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAConnect );
		iResult = Library::Call< int, SOCKET, const sockaddr*, int, LPWSABUF, LPWSABUF, LPQOS, LPQOS >( pFunc, s, name, namelen, lpCallerData, lpCalleeData, lpSQOS, lpGQOS );
#else
		qor_pp_unref7( s, name, namelen, lpCallerData, lpCalleeData, lpSQOS, lpGQOS );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	BOOL WS2::WSAConnectByList( SOCKET s, PSOCKET_ADDRESS_LIST SocketAddressList, LPDWORD LocalAddressLength, LPSOCKADDR LocalAddress, LPDWORD RemoteAddressLength, LPSOCKADDR RemoteAddress, const timeval* timeout, LPWSAOVERLAPPED Reserved )
	{
		qor_pp_fcontext;
		CheckReturn< BOOL, CheckNonZeroIsWinsockFailure< INT> >::TType bResult;
#if		( _WIN32_WINNT >= 0x0600 )
		qor_pp_useswinapi( ws2_32, WSAConnectByList );
		bResult = Library::Call< BOOL, SOCKET, PSOCKET_ADDRESS_LIST, LPDWORD, LPSOCKADDR, LPDWORD, LPSOCKADDR, const timeval*, LPWSAOVERLAPPED >( pFunc, s, SocketAddressList, LocalAddressLength, LocalAddress, RemoteAddressLength, RemoteAddress, timeout, Reserved );
#else
		qor_pp_unref8( s, SocketAddressList, LocalAddressLength, LocalAddress, RemoteAddressLength, RemoteAddress, timeout, Reserved );
		continuable("Requires Windows Vista");
#endif
		return bResult;
	}

	
	BOOL WS2::WSAConnectByNameA( SOCKET s, LPSTR nodename, LPSTR servicename, LPDWORD LocalAddressLength, LPSOCKADDR LocalAddress, LPDWORD RemoteAddressLength, LPSOCKADDR RemoteAddress, const timeval* timeout, LPWSAOVERLAPPED Reserved )
	{
		qor_pp_fcontext;
		CheckReturn< BOOL, CheckNonZeroIsWinsockFailure< INT> >::TType bResult;
#if		( _WIN32_WINNT >= 0x0600 )
		qor_pp_useswinapi( ws2_32, WSAConnectByNameA );
		bResult = Library::Call< BOOL, SOCKET, LPSTR, LPSTR, LPDWORD, LPSOCKADDR, LPDWORD, LPSOCKADDR, const timeval*, LPWSAOVERLAPPED >( pFunc, s, nodename, servicename, LocalAddressLength, LocalAddress, RemoteAddressLength, RemoteAddress, timeout, Reserved );
#else
		qor_pp_unref9( s, nodename, servicename, LocalAddressLength, LocalAddress, RemoteAddressLength, RemoteAddress, timeout, Reserved );
		continuable("Requires Windows Vista");
#endif
		return bResult;
	}

	
	BOOL WS2::WSAConnectByNameW( SOCKET s, LPWSTR nodename, LPWSTR servicename, LPDWORD LocalAddressLength, LPSOCKADDR LocalAddress, LPDWORD RemoteAddressLength, LPSOCKADDR RemoteAddress, const timeval* timeout, LPWSAOVERLAPPED Reserved )
	{
		qor_pp_fcontext;
		CheckReturn< BOOL, CheckNonZeroIsWinsockFailure< INT> >::TType bResult;
#if		( _WIN32_WINNT >= 0x0600 )
		qor_pp_useswinapi( ws2_32, WSAConnectByNameW );
		bResult = Library::Call< BOOL, SOCKET, LPWSTR, LPWSTR, LPDWORD, LPSOCKADDR, LPDWORD, LPSOCKADDR, const timeval*, LPWSAOVERLAPPED >( pFunc, s, nodename, servicename, LocalAddressLength, LocalAddress, RemoteAddressLength, RemoteAddress, timeout, Reserved );
#else
		qor_pp_unref9( s, nodename, servicename, LocalAddressLength, LocalAddress, RemoteAddressLength, RemoteAddress, timeout, Reserved );
		continuable("Requires Windows Vista");
#endif
		return bResult;
	}

	
	WSAEVENT WS2::WSACreateEvent(void)
	{
		qor_pp_fcontext;
		WSAEVENT Result = 0;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSACreateEvent );
		Result = Library::Call< WSAEVENT >( pFunc );
#else
		continuable("Requires Windows Vista");
#endif
		return Result;
	}

	
	int WS2::WSADuplicateSocketA( SOCKET s, DWORD dwProcessId, LPWSAPROTOCOL_INFO lpProtocolInfo )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSADuplicateSocketA );
		iResult = Library::Call< int, SOCKET, DWORD, LPWSAPROTOCOL_INFO >( pFunc, s, dwProcessId, lpProtocolInfo );
#else
		qor_pp_unref3( s, dwProcessId, lpProtocolInfo );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSADuplicateSocketW( SOCKET s, DWORD dwProcessId, LPWSAPROTOCOL_INFO lpProtocolInfo )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSADuplicateSocketW );
		iResult = Library::Call< int, SOCKET, DWORD, LPWSAPROTOCOL_INFO >( pFunc, s, dwProcessId, lpProtocolInfo );
#else
		qor_pp_unref3(s, dwProcessId, lpProtocolInfo );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	INT WS2::WSAEnumNameSpaceProvidersA( LPDWORD lpdwBufferLength, LPWSANAMESPACE_INFO lpnspBuffer )
	{
		qor_pp_fcontext;
		CheckReturn< int, TCheckWinsockFailureValue< int, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAEnumNameSpaceProvidersA );
		iResult = Library::Call< INT, LPDWORD, LPWSANAMESPACE_INFO >( pFunc, lpdwBufferLength, lpnspBuffer );
#else
		qor_pp_unref2( lpdwBufferLength, lpnspBuffer );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	INT WS2::WSAEnumNameSpaceProvidersExA( LPDWORD lpdwBufferLength, LPWSANAMESPACE_INFOEX lpnspBuffer )
	{
		qor_pp_fcontext;
		CheckReturn< INT, TCheckWinsockFailureValue< INT, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0600 )
			qor_pp_useswinapi( ws2_32, WSAEnumNameSpaceProvidersExA );
		iResult = Library::Call< INT, LPDWORD, LPWSANAMESPACE_INFOEX >( pFunc, lpdwBufferLength, lpnspBuffer );
#else
		qor_pp_unref2( lpdwBufferLength, lpnspBuffer );
		continuable("Requires Windows Vista");
#endif
		return iResult;
	}

	
	hostent* WS2::gethostbyaddr( const char* addr, int len, int type )
	{
		qor_pp_fcontext;
		CheckReturn< hostent*, CheckNullPointerIsWinsockFailure< hostent*> >::TType pResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, gethostbyaddr );
		pResult = Library::Call< hostent*, const char*, int, int >( pFunc, addr, len, type  );
#else
		qor_pp_unref3( addr, len, type );
		continuable("Requires Windows 2000 Professional");
#endif
		return pResult;
	}

	
	hostent* WS2::gethostbyname( const char* name )
	{
		qor_pp_fcontext;
		CheckReturn< hostent*, CheckNullPointerIsWinsockFailure< hostent*> >::TType pResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, gethostbyname );
		pResult = Library::Call< hostent*, const char* >( pFunc, name );
#else
		qor_pp_unref( name );
		continuable("Requires Windows 2000 Professional");
#endif
		return pResult;
	}

	
	::PROTOENT* WS2::getprotobyname( const char* name )
	{
		qor_pp_fcontext;
		CheckReturn< ::PROTOENT*, CheckNullPointerIsWinsockFailure< ::PROTOENT*> >::TType pResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, getprotobyname );
		pResult = Library::Call< ::PROTOENT*, const char* >( pFunc, name );
#else
		qor_pp_unref( name );
		continuable("Requires Windows 2000 Professional");
#endif
		return pResult;
	}

	
	::PROTOENT* WS2::getprotobynumber( int number )
	{
		qor_pp_fcontext;
		CheckReturn< ::PROTOENT*, CheckNullPointerIsWinsockFailure< ::PROTOENT*> >::TType pResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, getprotobynumber );
		pResult = Library::Call< ::PROTOENT*, int >( pFunc, number );
#else
		qor_pp_unref( number );
		continuable("Requires Windows 2000 Professional");
#endif
		return pResult;
	}

	
	servent* WS2::getservbyname( const char* name, const char* proto )
	{
		qor_pp_fcontext;
		CheckReturn< servent*, CheckNullPointerIsWinsockFailure< servent*> >::TType pResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, getservbyname );
		pResult = Library::Call< servent*, const char*, const char* >( pFunc, name, proto );
#else
		qor_pp_unref2( name, proto );
		continuable("Requires Windows 2000 Professional");
#endif
		return pResult;
	}

	
	servent* WS2::getservbyport( int port, const char* proto )
	{
		qor_pp_fcontext;
		CheckReturn< servent*, CheckNullPointerIsWinsockFailure< servent*> >::TType pResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, getservbyport );
		pResult = Library::Call< servent*, int, const char* >( pFunc, port, proto );
#else
		qor_pp_unref2( port, proto );
		continuable("Requires Windows Vista");
#endif
		return pResult;
	}

	
	int WS2::gethostname( char* name, int namelen )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, gethostname );
		iResult = Library::Call< int, char*, int >( pFunc, name, namelen );
#else
		qor_pp_unref2( name, namelen );
		continuable("Requires Windows Vista");
#endif
		return iResult;
	}

	
	INT WS2::WSAEnumNameSpaceProvidersExW( LPDWORD lpdwBufferLength, LPWSANAMESPACE_INFOEX lpnspBuffer )
	{
		qor_pp_fcontext;
		CheckReturn< INT, TCheckWinsockFailureValue< INT, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0600 )
		qor_pp_useswinapi( ws2_32, WSAEnumNameSpaceProvidersExW );
		iResult = Library::Call< INT, LPDWORD, LPWSANAMESPACE_INFOEX >( pFunc, lpdwBufferLength, lpnspBuffer );
#else
		qor_pp_unref2( lpdwBufferLength, lpnspBuffer );
		continuable("Requires Windows Vista");
#endif
		return iResult;
	}

	
	INT WS2::WSAEnumNameSpaceProvidersW( LPDWORD lpdwBufferLength, LPWSANAMESPACE_INFO lpnspBuffer )
	{
		qor_pp_fcontext;
		CheckReturn< INT, TCheckWinsockFailureValue< INT, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAEnumNameSpaceProvidersW );
		iResult = Library::Call< INT, LPDWORD, LPWSANAMESPACE_INFO >( pFunc, lpdwBufferLength, lpnspBuffer );
#else
		qor_pp_unref2( lpdwBufferLength, lpnspBuffer );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSAEnumNetworkEvents( SOCKET s, WSAEVENT hEventObject, LPWSANETWORKEVENTS lpNetworkEvents )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAEnumNetworkEvents );
		iResult = Library::Call< int, SOCKET, WSAEVENT, LPWSANETWORKEVENTS >( pFunc, s, hEventObject, lpNetworkEvents );
#else
		qor_pp_unref3( s, hEventObject, lpNetworkEvents );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSAEnumProtocolsA( LPINT lpiProtocols, LPWSAPROTOCOL_INFO lpProtocolBuffer, LPDWORD lpdwBufferLength )
	{
		qor_pp_fcontext;
		CheckReturn< int, TCheckWinsockFailureValue< int, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAEnumProtocolsA );
		iResult = Library::Call< int, LPINT, LPWSAPROTOCOL_INFO, LPDWORD >( pFunc, lpiProtocols, lpProtocolBuffer, lpdwBufferLength );
#else
		qor_pp_unref3( lpiProtocols, lpProtocolBuffer, lpdwBufferLength );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSAEnumProtocolsW( LPINT lpiProtocols, LPWSAPROTOCOL_INFO lpProtocolBuffer, LPDWORD lpdwBufferLength )
	{
		qor_pp_fcontext;
		CheckReturn< INT, TCheckWinsockFailureValue< INT, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAEnumProtocolsW );
		iResult = Library::Call< int, LPINT, LPWSAPROTOCOL_INFO, LPDWORD >( pFunc, lpiProtocols, lpProtocolBuffer, lpdwBufferLength );
#else
		qor_pp_unref3( lpiProtocols, lpProtocolBuffer, lpdwBufferLength );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSAEventSelect( SOCKET s, WSAEVENT hEventObject, long lNetworkEvents )
	{
		qor_pp_fcontext;
		CheckReturn< INT, TCheckWinsockFailureValue< INT, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAEventSelect );
		iResult = Library::Call< int, SOCKET, WSAEVENT, long >( pFunc, s, hEventObject, lNetworkEvents );
#else
		qor_pp_unref3( s, hEventObject, lNetworkEvents );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	BOOL WS2::WSAGetOverlappedResult( SOCKET s, LPWSAOVERLAPPED lpOverlapped, LPDWORD lpcbTransfer, BOOL fWait, LPDWORD lpdwFlags )
	{
		qor_pp_fcontext;
		CheckReturn< BOOL, CheckNonZeroIsWinsockFailure< INT> >::TType bResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAGetOverlappedResult );
		bResult = Library::Call< BOOL, SOCKET, LPWSAOVERLAPPED, LPDWORD, BOOL, LPDWORD >( pFunc, s, lpOverlapped, lpcbTransfer, fWait, lpdwFlags );
#else
		qor_pp_unref5( s, lpOverlapped, lpcbTransfer, fWait, lpdwFlags );
		continuable("Requires Windows 2000 Professional");
#endif
		return bResult;
	}

	
	BOOL WS2::WSAGetQOSByName( SOCKET s, LPWSABUF lpQOSName, LPQOS lpQOS )
	{
		qor_pp_fcontext;
		CheckReturn< BOOL, CheckNonZeroIsWinsockFailure< INT> >::TType bResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAGetQOSByName );
		bResult = Library::Call< BOOL, SOCKET, LPWSABUF, LPQOS >( pFunc, s, lpQOSName, lpQOS );
#else
		qor_pp_unref( s, lpQOSName, lpQOS );
		continuable("Requires Windows 2000 Professional");
#endif
		return bResult;
	}

	
	INT WS2::WSAGetServiceClassInfoA( LPGUID lpProviderId, LPGUID lpServiceClassId, LPDWORD lpdwBufferLength, LPWSASERVICECLASSINFO lpServiceClassInfo )
	{
		qor_pp_fcontext;
		CheckReturn< INT, CheckNonZeroIsWinsockFailure< INT> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAGetServiceClassInfoA );
		iResult = Library::Call< INT, LPGUID, LPGUID, LPDWORD, LPWSASERVICECLASSINFO >( pFunc, lpProviderId, lpServiceClassId, lpdwBufferLength, lpServiceClassInfo );
#else
		qor_pp_unref4( lpProviderId, lpServiceClassId, lpdwBufferLength, lpServiceClassInfo );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	INT WS2::WSAGetServiceClassInfoW( LPGUID lpProviderId, LPGUID lpServiceClassId, LPDWORD lpdwBufferLength, LPWSASERVICECLASSINFO lpServiceClassInfo )
	{
		qor_pp_fcontext;
		CheckReturn< INT, CheckNonZeroIsWinsockFailure< INT> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAGetServiceClassInfoW );
		iResult = Library::Call< INT, LPGUID, LPGUID, LPDWORD, LPWSASERVICECLASSINFO >( pFunc, lpProviderId, lpServiceClassId, lpdwBufferLength, lpServiceClassInfo );
#else
		qor_pp_unref4( lpProviderId, lpServiceClassId, lpdwBufferLength, lpServiceClassInfo );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	INT WS2::WSAGetServiceClassNameByClassIdA( LPGUID lpServiceClassId, LPSTR lpszServiceClassName, LPDWORD lpdwBufferLength )
	{
		qor_pp_fcontext;
		CheckReturn< INT, CheckNonZeroIsWinsockFailure< INT> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAGetServiceClassNameByClassIdA );
		iResult = Library::Call< INT, LPGUID, LPSTR, LPDWORD >( pFunc, lpServiceClassId, lpszServiceClassName, lpdwBufferLength );
#else
		qor_pp_unref3( lpServiceClassId, lpszServiceClassName, lpdwBufferLength );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	INT WS2::WSAGetServiceClassNameByClassIdW( LPGUID lpServiceClassId, LPWSTR lpszServiceClassName, LPDWORD lpdwBufferLength )
	{
		qor_pp_fcontext;
		CheckReturn< INT, CheckNonZeroIsWinsockFailure< INT> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAGetServiceClassNameByClassIdW );
		iResult = Library::Call< INT, LPGUID, LPWSTR, LPDWORD >( pFunc, lpServiceClassId, lpszServiceClassName, lpdwBufferLength );
#else
		qor_pp_unref3( lpServiceClassId, lpszServiceClassName, lpdwBufferLength );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSAHtonl( SOCKET s, u_long hostlong, u_long* lpnetlong )
	{
		qor_pp_fcontext;
		CheckReturn< INT, CheckNonZeroIsWinsockFailure< INT> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAHtonl );
		iResult = Library::Call< int, SOCKET, u_long, u_long* >( pFunc, s, hostlong, lpnetlong );
#else
		qor_pp_unref3( s, hostlong, lpnetlong );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSAHtons( SOCKET s, u_short hostshort, u_short* lpnetshort )
	{
		qor_pp_fcontext;
		CheckReturn< INT, CheckNonZeroIsWinsockFailure< INT> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAHtons );
		iResult = Library::Call< int, SOCKET, u_short, u_short* >( pFunc, s, hostshort, lpnetshort );
#else
		qor_pp_unref3( s, hostshort, lpnetshort );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	INT WS2::WSAInstallServiceClassA( LPWSASERVICECLASSINFO lpServiceClassInfo )
	{
		qor_pp_fcontext;
		CheckReturn< INT, CheckNonZeroIsWinsockFailure< INT> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAInstallServiceClassA );
		iResult = Library::Call< INT, LPWSASERVICECLASSINFO >( pFunc, lpServiceClassInfo );
#else
		qor_pp_unref( lpServiceClassInfo );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	INT WS2::WSAInstallServiceClassW( LPWSASERVICECLASSINFO lpServiceClassInfo )
	{
		qor_pp_fcontext;
		CheckReturn< INT, CheckNonZeroIsWinsockFailure< INT> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAInstallServiceClassW );
		iResult = Library::Call< INT, LPWSASERVICECLASSINFO >( pFunc, lpServiceClassInfo );
#else
		qor_pp_unref( lpServiceClassInfo );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSAIoctl( SOCKET s, DWORD dwIoControlCode, LPVOID lpvInBuffer, DWORD cbInBuffer, LPVOID lpvOutBuffer, DWORD cbOutBuffer, LPDWORD lpcbBytesReturned, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAIoctl );
		iResult = Library::Call< int, SOCKET, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE >( pFunc, s, dwIoControlCode, lpvInBuffer, cbInBuffer, lpvOutBuffer, cbOutBuffer, lpcbBytesReturned, lpOverlapped, lpCompletionRoutine );
#else
		qor_pp_unref9( s, dwIoControlCode, lpvInBuffer, cbInBuffer, lpvOutBuffer, cbOutBuffer, lpcbBytesReturned, lpOverlapped, lpCompletionRoutine );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	SOCKET WS2::WSAJoinLeaf( SOCKET s, const sockaddr* name, int namelen, LPWSABUF lpCallerData, LPWSABUF lpCalleeData, LPQOS lpSQOS, LPQOS lpGQOS, DWORD dwFlags )
	{
		qor_pp_fcontext;
		CheckReturn< SOCKET, TCheckWinsockFailureValue< SOCKET, INVALID_SOCKET> >::TType Result;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAJoinLeaf );
		Result = Library::Call< SOCKET, SOCKET, const sockaddr*, int, LPWSABUF, LPWSABUF, LPQOS, LPQOS, DWORD >( pFunc, s, name, namelen, lpCallerData, lpCalleeData, lpSQOS, lpGQOS, dwFlags );
#else
		qor_pp_unref8(  s, name, namelen, lpCallerData, lpCalleeData, lpSQOS, lpGQOS, dwFlags );
		continuable("Requires Windows 2000 Professional");
#endif
		return Result;
	}

	
	INT WS2::WSALookupServiceBeginA( LPWSAQUERYSET lpqsRestrictions, DWORD dwControlFlags, LPHANDLE lphLookup )
	{
		qor_pp_fcontext;
		CheckReturn< INT, CheckNonZeroIsWinsockFailure< INT> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSALookupServiceBeginA );
		iResult = Library::Call< INT, LPWSAQUERYSET, DWORD, LPHANDLE >( pFunc, lpqsRestrictions, dwControlFlags, lphLookup );
#else
		qor_pp_unref3( lpqsRestrictions, dwControlFlags, lphLookup );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	INT WS2::WSALookupServiceBeginW( LPWSAQUERYSET lpqsRestrictions, DWORD dwControlFlags, LPHANDLE lphLookup )
	{
		qor_pp_fcontext;
		CheckReturn< INT, CheckNonZeroIsWinsockFailure< INT> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSALookupServiceBeginW );
		iResult = Library::Call< INT, LPWSAQUERYSET, DWORD, LPHANDLE >( pFunc, lpqsRestrictions, dwControlFlags, lphLookup );
#else
		qor_pp_unref3( lpqsRestrictions, dwControlFlags, lphLookup );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	INT WS2::WSALookupServiceEnd( HANDLE hLookup )
	{
		qor_pp_fcontext;
		CheckReturn< INT, CheckNonZeroIsWinsockFailure< INT> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSALookupServiceEnd );
		iResult = Library::Call< INT, HANDLE >( pFunc, hLookup );
#else
		qor_pp_unref( hLookup );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	INT WS2::WSALookupServiceNextA( HANDLE hLookup, DWORD dwControlFlags, LPDWORD lpdwBufferLength, LPWSAQUERYSET lpqsResults )
	{
		qor_pp_fcontext;
		CheckReturn< INT, CheckNonZeroIsWinsockFailure< INT> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSALookupServiceNextA );
		iResult = Library::Call< INT, HANDLE, DWORD, LPDWORD, LPWSAQUERYSET >( pFunc, hLookup, dwControlFlags, lpdwBufferLength, lpqsResults );
#else
		qor_pp_unref4( hLookup, dwControlFlags, lpdwBufferLength, lpqsResults );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	INT WS2::WSALookupServiceNextW( HANDLE hLookup, DWORD dwControlFlags, LPDWORD lpdwBufferLength, LPWSAQUERYSET lpqsResults )
	{
		qor_pp_fcontext;
		CheckReturn< INT, CheckNonZeroIsWinsockFailure< INT> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSALookupServiceNextW );
		iResult = Library::Call< INT, HANDLE, DWORD, LPDWORD, LPWSAQUERYSET >( pFunc, hLookup, dwControlFlags, lpdwBufferLength, lpqsResults );
#else
		qor_pp_unref4( hLookup, dwControlFlags, lpdwBufferLength, lpqsResults );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSANSPIoctl( HANDLE hLookup, DWORD dwControlCode, LPVOID lpvInBuffer, DWORD cbInBuffer, LPVOID lpvOutBuffer, DWORD cbOutBuffer, LPDWORD lpcbBytesReturned, LPWSACOMPLETION lpCompletion )
	{
		qor_pp_fcontext;
		CheckReturn< INT, CheckNonZeroIsWinsockFailure< INT> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0501 )
		qor_pp_useswinapi( ws2_32, WSANSPIoctl );
		iResult = Library::Call< int, HANDLE, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPWSACOMPLETION >( pFunc, hLookup, dwControlCode, lpvInBuffer, cbInBuffer, lpvOutBuffer, cbOutBuffer, lpcbBytesReturned, lpCompletion );
#else
		qor_pp_unref8( hLookup, dwControlCode, lpvInBuffer, cbInBuffer, lpvOutBuffer, cbOutBuffer, lpcbBytesReturned, lpCompletion );
		continuable("Requires Windows XP");
#endif
		return iResult;
	}

    
	int WS2::WSANtohl( SOCKET s, u_long netlong, u_long* lphostlong )
	{
		qor_pp_fcontext;
		CheckReturn< INT, CheckNonZeroIsWinsockFailure< INT> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSANtohl );
		iResult = Library::Call< int, SOCKET, u_long, u_long* >( pFunc, s, netlong, lphostlong );
#else
		qor_pp_unref3( s, netlong, lphostlong );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSANtohs( SOCKET s, u_short netshort, u_short* lphostshort )
	{
		qor_pp_fcontext;
		CheckReturn< INT, CheckNonZeroIsWinsockFailure< INT> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSANtohs );
		iResult = Library::Call< int, SOCKET, u_short, u_short* >( pFunc, s, netshort, lphostshort );
#else
		qor_pp_unref( s, netshort, lphostshort );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSAPoll( WSAPOLLFD fdarray[], ULONG nfds, INT timeout )
	{
		qor_pp_fcontext;
		CheckReturn< int, TCheckWinsockFailureValue< int, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0600 )
		qor_pp_useswinapi( ws2_32, WSAPoll );
		iResult = Library::Call< int, WSAPOLLFD*, ULONG, INT >( pFunc, fdarray, nfds, timeout  );
#else
		qor_pp_unref3( fdarray, nfds, timeout );
		continuable("Requires Windows Vista");
#endif
		return iResult;
	}

	
	INT WS2::WSAProviderCompleteAsyncCall( HANDLE hAsyncCall, INT iRetCode )
	{
		qor_pp_fcontext;
		CheckReturn< INT, TCheckWinsockFailureValue< int, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAProviderCompleteAsyncCall );
		iResult = Library::Call< INT, HANDLE, INT >( pFunc, hAsyncCall, iRetCode );
#else
		qor_pp_unref2( hAsyncCall, iRetCode );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSAProviderConfigChange( LPHANDLE lpNotificationHandle, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAProviderConfigChange );
		iResult = Library::Call< int, LPHANDLE, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE >( pFunc, lpNotificationHandle, lpOverlapped, lpCompletionRoutine );
#else
		qor_pp_unref3( lpNotificationHandle, lpOverlapped, lpCompletionRoutine );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSARecv( SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesRecvd, LPDWORD lpFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine )
	{
		qor_pp_fcontext;
		CheckReturn< INT, TCheckWinsockFailureValue< int, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSARecv );
		iResult = Library::Call< int, SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE >( pFunc, s, lpBuffers, dwBufferCount, lpNumberOfBytesRecvd, lpFlags, lpOverlapped, lpCompletionRoutine );
#else
		qor_pp_unref7( s, lpBuffers, dwBufferCount, lpNumberOfBytesRecvd, lpFlags, lpOverlapped, lpCompletionRoutine );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSARecvDisconnect( SOCKET s, LPWSABUF lpInboundDisconnectData )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSARecvDisconnect );
		iResult = Library::Call< int, SOCKET, LPWSABUF >( pFunc, s, lpInboundDisconnectData );
#else
		qor_pp_unref2( s, lpInboundDisconnectData );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSARecvFrom( SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesRecvd, LPDWORD lpFlags, struct sockaddr* lpFrom, LPINT lpFromLen, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSARecvFrom );
		iResult = Library::Call< int, SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, sockaddr*, LPINT, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE >( pFunc, s, lpBuffers, dwBufferCount, lpNumberOfBytesRecvd, lpFlags, lpFrom, lpFromLen, lpOverlapped, lpCompletionRoutine );
#else
		qor_pp_unref9( s, lpBuffers, dwBufferCount, lpNumberOfBytesRecvd, lpFlags, lpFrom, lpFromLen, lpOverlapped, lpCompletionRoutine );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	INT WS2::WSARemoveServiceClass( LPGUID lpServiceClassId )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSARemoveServiceClass );
		iResult = Library::Call< INT, LPGUID >( pFunc, lpServiceClassId );
#else
		qor_pp_unref( lpServiceClassId );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	BOOL WS2::WSAResetEvent( WSAEVENT hEvent )
	{
		qor_pp_fcontext;
		CheckReturn< BOOL, CheckNonZeroIsWinsockFailure< INT> >::TType bResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAResetEvent );
		bResult = Library::Call< BOOL, WSAEVENT >( pFunc, hEvent );
#else
		qor_pp_unref( hEvent );
		continuable("Requires Windows 2000 Professional");
#endif
		return bResult;
	}

	
	int WS2::WSASend( SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesSent, DWORD dwFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine )
	{
		qor_pp_fcontext;
		CheckReturn< int, TCheckWinsockFailureValue< int, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSASend );
		iResult = Library::Call< int, SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE >( pFunc, s, lpBuffers, dwBufferCount, lpNumberOfBytesSent, dwFlags, lpOverlapped, lpCompletionRoutine );
#else
		qor_pp_unref7( s, lpBuffers, dwBufferCount, lpNumberOfBytesSent, dwFlags, lpOverlapped, lpCompletionRoutine );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSASendDisconnect( SOCKET s, LPWSABUF lpOutboundDisconnectData )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSASendDisconnect );
		iResult = Library::Call< int, SOCKET, LPWSABUF >( pFunc, s, lpOutboundDisconnectData );
#else
		qor_pp_unref2( s, lpOutboundDisconnectData );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSASendMsg( SOCKET s, LPWSAMSG lpMsg, DWORD dwFlags, LPDWORD lpNumberOfBytesSent, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine )
	{
		qor_pp_fcontext;
		CheckReturn< int, TCheckWinsockFailureValue< int, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0600 )
		qor_pp_useswinapi( ws2_32, WSASendMsg );
		iResult = Library::Call< int, SOCKET, LPWSAMSG, DWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE >( pFunc, s, lpMsg, dwFlags, lpNumberOfBytesSent, lpOverlapped, lpCompletionRoutine );
#else
		qor_pp_unref6( s, lpMsg, dwFlags, lpNumberOfBytesSent, lpOverlapped, lpCompletionRoutine );
		continuable("Requires Windows Vista");
#endif
		return iResult;
	}

	
	int WS2::WSASendTo( SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesSent, DWORD dwFlags, const sockaddr* lpTo, int iToLen, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine )
	{
		qor_pp_fcontext;
		CheckReturn< int, TCheckWinsockFailureValue< int, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSASendTo );
		iResult = Library::Call< int, SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, const sockaddr*, int, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE >( pFunc, s, lpBuffers, dwBufferCount, lpNumberOfBytesSent, dwFlags, lpTo, iToLen, lpOverlapped, lpCompletionRoutine );
#else
		qor_pp_unref9( s, lpBuffers, dwBufferCount, lpNumberOfBytesSent, dwFlags, lpTo, iToLen, lpOverlapped, lpCompletionRoutine );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	BOOL WS2::WSASetEvent( WSAEVENT hEvent )
	{
		qor_pp_fcontext;
		CheckReturn< BOOL, CheckNonZeroIsWinsockFailure< INT> >::TType bResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSASetEvent );
		bResult = Library::Call< BOOL, WSAEVENT >( pFunc, hEvent );
#else
		qor_pp_unref( hEvent );
		continuable("Requires Windows 2000 Professional");
#endif
		return bResult;
	}

	
	INT WS2::WSASetServiceA( LPWSAQUERYSET lpqsRegInfo, WSAESETSERVICEOP essOperation, DWORD dwControlFlags )
	{
		qor_pp_fcontext;
		CheckReturn< INT, CheckNonZeroIsWinsockFailure< INT> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSASetServiceA );
		iResult = Library::Call< INT, LPWSAQUERYSET, WSAESETSERVICEOP, DWORD >( pFunc, lpqsRegInfo, essOperation, dwControlFlags );
#else
		qor_pp_unref3( lpqsRegInfo, essOperation, dwControlFlags );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	INT WS2::WSASetServiceW( LPWSAQUERYSET lpqsRegInfo, WSAESETSERVICEOP essOperation, DWORD dwControlFlags )
	{
		qor_pp_fcontext;
		CheckReturn< INT, CheckNonZeroIsWinsockFailure< INT> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSASetServiceW );
		iResult = Library::Call< INT, LPWSAQUERYSET, WSAESETSERVICEOP, DWORD >( pFunc, lpqsRegInfo, essOperation, dwControlFlags );
#else
		qor_pp_unref3( lpqsRegInfo, essOperation, dwControlFlags );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	SOCKET WS2::WSASocketA( int af, int type, int protocol, LPWSAPROTOCOL_INFO lpProtocolInfo, GROUP g, DWORD dwFlags )
	{
		qor_pp_fcontext;
		CheckReturn< SOCKET, TCheckWinsockFailureValue< SOCKET, INVALID_SOCKET> >::TType Result;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSASocketA );
		Result = Library::Call< SOCKET, int, int, int, LPWSAPROTOCOL_INFO, GROUP, DWORD >( pFunc, af, type, protocol, lpProtocolInfo, g, dwFlags );
#else
		qor_pp_unref6( af, type, protocol, lpProtocolInfo, g, dwFlags );
		continuable("Requires Windows 2000 Professional");
#endif
		return Result;
	}

	
	SOCKET WS2::WSASocketW( int af, int type, int protocol, LPWSAPROTOCOL_INFO lpProtocolInfo, GROUP g, DWORD dwFlags )
	{
		qor_pp_fcontext;
		CheckReturn< SOCKET, TCheckWinsockFailureValue< SOCKET, INVALID_SOCKET> >::TType Result;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSASocketW );
		Result = Library::Call< SOCKET, int, int, int, LPWSAPROTOCOL_INFO, GROUP, DWORD >( pFunc, af, type, protocol, lpProtocolInfo, g, dwFlags );
#else
		qor_pp_unref6( af, type, protocol, lpProtocolInfo, g, dwFlags );
		continuable("Requires Windows 2000 Professional");
#endif
		return Result;
	}

	
	int WS2::WSAAsyncSelect( SOCKET s, HWND hWnd, unsigned int wMsg, long lEvent )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAAsyncSelect );
		iResult = Library::Call< int, SOCKET, HWND, unsigned int, long >( pFunc, s, hWnd, wMsg, lEvent );
#else
		qor_pp_unref4( s, hWnd, wMsg, lEvent );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	HANDLE WS2::WSAAsyncGetHostByAddr( HWND hWnd, unsigned int wMsg, const char* addr, int len, int type, char* buf, int buflen )
	{
		qor_pp_fcontext;
		CheckReturn< HANDLE, CheckNullPointerIsWinsockFailure<HANDLE> >::TType Result;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAAsyncGetHostByAddr );
		Result = Library::Call< HANDLE, HWND, unsigned int, const char*, int, int, char*, int >( pFunc, hWnd, wMsg, addr, len, type, buf, buflen );
#else
		qor_pp_unref7( hWnd, wMsg, addr, len, type, buf, buflen );
		continuable("Requires Windows 2000 Professional");
#endif
		return Result;
	}

	
	HANDLE WS2::WSAAsyncGetHostByName( HWND hWnd, unsigned int wMsg, const char* name, char* buf, int buflen )
	{
		qor_pp_fcontext;
		CheckReturn< HANDLE, CheckNullPointerIsWinsockFailure<HANDLE> >::TType Result;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAAsyncGetHostByName );
		Result = Library::Call< HANDLE, HWND, unsigned int, const char*, char*, int >( pFunc, hWnd, wMsg, name, buf, buflen );
#else
		qor_pp_unref5( hWnd, wMsg, name, buf, buflen );
		continuable("Requires Windows 2000 Professional");
#endif
		return Result;
	}

	
	HANDLE WS2::WSAAsyncGetProtoByNumber( HWND hWnd, unsigned int wMsg, int number, char* buf, int buflen )
	{
		qor_pp_fcontext;
		CheckReturn< HANDLE, CheckNullPointerIsWinsockFailure<HANDLE> >::TType Result;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAAsyncGetProtoByNumber );
		Result = Library::Call< HANDLE, HWND, unsigned int, int, char*, int >( pFunc, hWnd, wMsg, number, buf, buflen );
#else
		qor_pp_unref5( hWnd, wMsg, number, buf, buflen );
		continuable("Requires Windows 2000 Professional");
#endif
		return Result;
	}

	
	HANDLE WS2::WSAAsyncGetProtoByName( HWND hWnd, unsigned int wMsg, const char* name, char* buf, int buflen )
	{
		qor_pp_fcontext;
		CheckReturn< HANDLE, CheckNullPointerIsWinsockFailure<HANDLE> >::TType Result;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAAsyncGetProtoByName );
		Result = Library::Call< HANDLE, HWND, unsigned int, const char*, char*, int >( pFunc, hWnd, wMsg, name, buf, buflen );
#else
		qor_pp_unref5( hWnd, wMsg, name, buf, buflen );
		continuable("Requires Windows 2000 Professional");
#endif
		return Result;
	}

	
	HANDLE WS2::WSAAsyncGetServByPort( HWND hWnd, unsigned int wMsg, int port, const char* proto, char* buf, int buflen )
	{
		qor_pp_fcontext;
		CheckReturn< HANDLE, CheckNullPointerIsWinsockFailure<HANDLE> >::TType Result;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAAsyncGetServByPort );
		Result = Library::Call< HANDLE, HWND, unsigned int, int, const char*, char*, int >( pFunc, hWnd, wMsg, port, proto, buf, buflen );
#else
		qor_pp_unref6( hWnd, wMsg, port, proto, buf, buflen );
		continuable("Requires Windows 2000 Professional");
#endif
		return Result;
	}

	
	HANDLE WS2::WSAAsyncGetServByName( HWND hWnd, unsigned int wMsg, const char* name, const char* proto, char* buf, int buflen )
	{
		qor_pp_fcontext;
		CheckReturn< HANDLE, CheckNullPointerIsWinsockFailure<HANDLE> >::TType Result;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAAsyncGetServByName );
		Result = Library::Call< HANDLE, HWND, unsigned int, const char*, const char*, char*, int >( pFunc, hWnd, wMsg, name, proto, buf, buflen );
#else
		qor_pp_unref6( hWnd, wMsg, name, proto, buf, buflen );
		continuable("Requires Windows 2000 Professional");
#endif
		return Result;
	}

	
	int WS2::WSACancelAsyncRequest( HANDLE hAsyncTaskHandle )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSACancelAsyncRequest );
		iResult = Library::Call< int, HANDLE >( pFunc, hAsyncTaskHandle );
#else
		qor_pp_unref( hAsyncTaskHandle );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSAGetLastError( void )
	{
		qor_pp_fcontext;
		int iResult = 0;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAGetLastError );
		iResult = Library::Call< int >( pFunc );
#else
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	void WS2::WSASetLastError( int iError )
	{
		qor_pp_fcontext;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSASetLastError );
		Library::voidCall< int >( pFunc, iError );
#else
		qor_pp_unref( iError );
		continuable("Requires Windows 2000 Professional");
#endif
	}

	
	int WS2::WSAStartup( WORD wVersionRequested, LPWSADATA lpWSAData )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAStartup );
		iResult = Library::Call< int, WORD, LPWSADATA >( pFunc, wVersionRequested, lpWSAData );
		s_winsockInitCount++;
#else
		qor_pp_unref2( wVersionRequested, lpWSAData );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSACleanup( void )
	{
		if(s_winsockInitCount == 0)
		{
			return 0;
		}
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSACleanup );
		iResult = Library::Call< int >( pFunc );
		--s_winsockInitCount;
#else
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	INT WS2::WSAStringToAddressA( LPSTR AddressString, INT AddressFamily, LPWSAPROTOCOL_INFO lpProtocolInfo, LPSOCKADDR lpAddress, LPINT lpAddressLength )
	{
		qor_pp_fcontext;
		CheckReturn< INT, CheckNonZeroIsWinsockFailure< INT> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAStringToAddressA );
		iResult = Library::Call< INT, LPSTR, INT, LPWSAPROTOCOL_INFO, LPSOCKADDR, LPINT >( pFunc, AddressString, AddressFamily, lpProtocolInfo, lpAddress, lpAddressLength );
#else
		qor_pp_unref5( AddressString, AddressFamily, lpProtocolInfo, lpAddress, lpAddressLength );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	INT WS2::WSAStringToAddressW( LPWSTR AddressString, INT AddressFamily, LPWSAPROTOCOL_INFO lpProtocolInfo, LPSOCKADDR lpAddress, LPINT lpAddressLength )
	{
		qor_pp_fcontext;
		CheckReturn< INT, CheckNonZeroIsWinsockFailure< INT> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAStringToAddressW );
		iResult = Library::Call< INT, LPWSTR, INT, LPWSAPROTOCOL_INFO, LPSOCKADDR, LPINT >( pFunc, AddressString, AddressFamily, lpProtocolInfo, lpAddress, lpAddressLength );
#else
		qor_pp_unref5( AddressString, AddressFamily, lpProtocolInfo, lpAddress, lpAddressLength );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	INT WS2::WSAUnadvertiseProvider( const ::GUID* puuidProviderId )
	{
		qor_pp_fcontext;
		CheckReturn< INT, CheckNonZeroIsWinsockFailure< INT> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0600 )
		qor_pp_useswinapi( ws2_32, WSAUnadvertiseProvider );
		iResult = Library::Call< INT, const ::GUID* >( pFunc, puuidProviderId );
#else
		qor_pp_unref( puuidProviderId );
		continuable("Requires Windows Vista");
#endif
		return iResult;
	}

	
	DWORD WS2::WSAWaitForMultipleEvents( DWORD cEvents, const WSAEVENT* lphEvents, BOOL fWaitAll, DWORD dwTimeout, BOOL fAlertable )
	{
		qor_pp_fcontext;
		CheckReturn< DWORD, TCheckWinsockFailureValue< DWORD, WSA_WAIT_FAILED> >::TType dwResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSAWaitForMultipleEvents );
		dwResult = Library::Call< DWORD, DWORD, const WSAEVENT*, BOOL, DWORD, BOOL >( pFunc, cEvents, lphEvents, fWaitAll, dwTimeout, fAlertable );
#else
		qor_pp_unref5( cEvents, lphEvents, fWaitAll, dwTimeout, fAlertable );
		continuable("Requires Windows 2000 Professional");
#endif
		return dwResult;
	}

	
	int WS2::WSCDeinstallProvider( LPGUID lpProviderId, LPINT lpErrno )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSCDeinstallProvider );
		iResult = Library::Call< int, LPGUID, LPINT >( pFunc, lpProviderId, lpErrno );
#else
		qor_pp_unref2( lpProviderId, lpErrno );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSCEnableNSProvider( LPGUID lpProviderId, BOOL fEnable )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSCEnableNSProvider );
		iResult = Library::Call< int, LPGUID, BOOL >( pFunc, lpProviderId, fEnable );
#else
		qor_pp_unref2( lpProviderId, fEnable );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSCEnumProtocols( LPINT lpiProtocols, LPWSAPROTOCOL_INFOW lpProtocolBuffer, LPDWORD lpdwBufferLength, LPINT lpErrno )
	{
		qor_pp_fcontext;
		CheckReturn< int, TCheckWinsockFailureValue< int, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSCEnumProtocols );
		iResult = Library::Call< int, LPINT, LPWSAPROTOCOL_INFOW, LPDWORD, LPINT >( pFunc, lpiProtocols, lpProtocolBuffer, lpdwBufferLength, lpErrno );
#else
		qor_pp_unref4( lpiProtocols, lpProtocolBuffer, lpdwBufferLength, lpErrno );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSCGetApplicationCategory( LPCWSTR Path, DWORD PathLength, LPCWSTR Extra, DWORD ExtraLength, DWORD* pPermittedLspCategories, LPINT lpErrno )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0600 )
		qor_pp_useswinapi( ws2_32, WSCGetApplicationCategory );
		iResult = Library::Call< int, LPCWSTR, DWORD, LPCWSTR, DWORD, DWORD*, LPINT >( pFunc, Path, PathLength, Extra, ExtraLength, pPermittedLspCategories, lpErrno );
#else
		qor_pp_unref6( Path, PathLength, Extra, ExtraLength, pPermittedLspCategories, lpErrno );
		continuable("Requires Windows Vista");
#endif
		return iResult;
	}

	
	int WS2::WSCGetProviderInfo( LPGUID lpProviderId, WSC_PROVIDER_INFO_TYPE InfoType, PBYTE Info, size_t* InfoSize, DWORD Flags, LPINT lpErrno )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0600 )
		qor_pp_useswinapi( ws2_32, WSCGetProviderInfo );
		iResult = Library::Call< int, LPGUID, WSC_PROVIDER_INFO_TYPE, PBYTE, size_t*, DWORD, LPINT >( pFunc, lpProviderId, InfoType, Info, InfoSize, Flags, lpErrno );
#else
		qor_pp_unref6( lpProviderId, InfoType, Info, InfoSize, Flags, lpErrno );
		continuable("Requires Windows Vista");
#endif
		return iResult;
	}

	
	int WS2::WSCGetProviderPath( LPGUID lpProviderId, LPWSTR lpszProviderDllPath, LPINT lpProviderDllPathLen, LPINT lpErrno )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSCGetProviderPath );
		iResult = Library::Call< int, LPGUID, LPWSTR, LPINT, LPINT >( pFunc, lpProviderId, lpszProviderDllPath, lpProviderDllPathLen, lpErrno );
#else
		qor_pp_unref4( lpProviderId, lpszProviderDllPath, lpProviderDllPathLen, lpErrno );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSCInstallNameSpace( LPWSTR lpszIdentifier, LPWSTR lpszPathName, DWORD dwNameSpace, DWORD dwVersion, LPGUID lpProviderId )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSCInstallNameSpace );
		iResult = Library::Call< int, LPWSTR, LPWSTR, DWORD, DWORD, LPGUID >( pFunc, lpszIdentifier, lpszPathName, dwNameSpace, dwVersion, lpProviderId );

#else
		qor_pp_unref5( lpszIdentifier, lpszPathName, dwNameSpace, dwVersion, lpProviderId );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSCInstallNameSpaceEx( LPWSTR lpszIdentifier, LPWSTR lpszPathName, DWORD dwNameSpace, DWORD dwVersion, LPGUID lpProviderId, LPBLOB lpProviderInfo )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0600 )
		qor_pp_useswinapi( ws2_32, WSCInstallNameSpaceEx );
		iResult = Library::Call< int, LPWSTR, LPWSTR, DWORD, DWORD, LPGUID, LPBLOB >( pFunc, lpszIdentifier, lpszPathName, dwNameSpace, dwVersion, lpProviderId, lpProviderInfo );
#else
		qor_pp_unref6( lpszIdentifier, lpszPathName, dwNameSpace, dwVersion, lpProviderId, lpProviderInfo );
		continuable("Requires Windows Vista");
#endif
		return iResult;
	}

	
	int WS2::WSCInstallProvider( const LPGUID lpProviderId, const LPWSTR lpszProviderDllPath, const LPWSAPROTOCOL_INFO lpProtocolInfoList, DWORD dwNumberOfEntries, LPINT lpErrno )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSCInstallProvider );
		iResult = Library::Call< int, const LPGUID, const LPWSTR, const LPWSAPROTOCOL_INFO, DWORD, LPINT >( pFunc, lpProviderId, lpszProviderDllPath, lpProtocolInfoList, dwNumberOfEntries, lpErrno );
#else
		qor_pp_unref5( lpProviderId, lpszProviderDllPath, lpProtocolInfoList, dwNumberOfEntries, lpErrno );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSCInstallProviderAndChains( const LPGUID lpProviderId, const LPWSTR lpszProviderDllPath, const LPWSTR lpszLspName, DWORD dwServiceFlags, const LPWSAPROTOCOL_INFO lpProtocolInfoList, DWORD dwNumberOfEntries, LPDWORD lpdwCatalogEntryId, LPINT lpErrno )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0600 )
		qor_pp_useswinapi( ws2_32, WSCInstallProviderAndChains );
		iResult = Library::Call< int, const LPGUID, const LPWSTR, const LPWSTR, DWORD, const LPWSAPROTOCOL_INFO, DWORD, LPDWORD, LPINT >( pFunc, lpProviderId, lpszProviderDllPath, lpszLspName, dwServiceFlags, lpProtocolInfoList, dwNumberOfEntries, lpdwCatalogEntryId, lpErrno );
#else
		qor_pp_unref8( lpProviderId, lpszProviderDllPath, lpszLspName, dwServiceFlags, lpProtocolInfoList, dwNumberOfEntries, lpdwCatalogEntryId, lpErrno );
		continuable("Requires Windows Vista");
#endif
		return iResult;
	}

	
	int WS2::WSCSetApplicationCategory( LPCWSTR Path, DWORD PathLength, LPCWSTR Extra, DWORD ExtraLength, DWORD PermittedLspCategories, DWORD* pPrevPermLspCat, LPINT lpErrno )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0600 )
		qor_pp_useswinapi( ws2_32, WSCSetApplicationCategory );
		iResult = Library::Call< int, LPCWSTR, DWORD, LPCWSTR, DWORD, DWORD, DWORD*, LPINT >( pFunc, Path, PathLength, Extra, ExtraLength, PermittedLspCategories, pPrevPermLspCat, lpErrno );
#else
		qor_pp_unref7( Path, PathLength, Extra, ExtraLength, PermittedLspCategories, pPrevPermLspCat, lpErrno );
		continuable("Requires Windows Vista");
#endif
		return iResult;
	}

	
	int WS2::WSCSetProviderInfo( LPGUID lpProviderId, WSC_PROVIDER_INFO_TYPE InfoType, PBYTE Info, size_t InfoSize, DWORD Flags, LPINT lpErrno )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0600 )
		qor_pp_useswinapi( ws2_32, WSCSetProviderInfo );
		iResult = Library::Call< int, LPGUID, WSC_PROVIDER_INFO_TYPE, PBYTE, size_t, DWORD, LPINT >( pFunc, lpProviderId, InfoType, Info, InfoSize, Flags, lpErrno );
#else
		qor_pp_unref6( lpProviderId, InfoType, Info, InfoSize, Flags, lpErrno );
		continuable("Requires Windows Vista");
#endif
		return iResult;
	}

	
	int WS2::WSCUnInstallNameSpace( LPGUID lpProviderId )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSCUnInstallNameSpace );
		iResult = Library::Call< int, LPGUID >( pFunc, lpProviderId );
#else
		qor_pp_unref( lpProviderId );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSCUpdateProvider( LPGUID lpProviderId, const WCHAR* lpszProviderDllPath, const LPWSAPROTOCOL_INFO lpProtocolInfoList, DWORD dwNumberOfEntries, LPINT lpErrno )
	{
		qor_pp_fcontext;
		CheckReturn< int, TCheckWinsockFailureValue< int, SOCKET_ERROR> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0502 )
		qor_pp_useswinapi( ws2_32, WSCUpdateProvider );
		iResult = Library::Call< int, LPGUID, const WCHAR*, const LPWSAPROTOCOL_INFO, DWORD, LPINT >( pFunc, lpProviderId, lpszProviderDllPath, lpProtocolInfoList, dwNumberOfEntries, lpErrno );
#else
		qor_pp_unref5( lpProviderId, lpszProviderDllPath, lpProtocolInfoList, dwNumberOfEntries, lpErrno );
		continuable("Requires Windows XP");
#endif
		return iResult;
	}

	
	int WS2::WSCWriteNameSpaceOrder( LPGUID lpProviderId, DWORD dwNumberOfEntries )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSCWriteNameSpaceOrder );
		iResult = Library::Call< int, LPGUID, DWORD >( pFunc, lpProviderId, dwNumberOfEntries );
#else
		qor_pp_unref2( lpProviderId, dwNumberOfEntries );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::WSCWriteProviderOrder( LPDWORD lpwdCatalogEntryId, DWORD dwNumberOfEntries )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, WSCWriteProviderOrder );
		iResult = Library::Call< int, LPDWORD, DWORD >( pFunc, lpwdCatalogEntryId, dwNumberOfEntries );
#else
		qor_pp_unref2( lpwdCatalogEntryId, dwNumberOfEntries );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::__WSAFDIsSet( SOCKET fd, fd_set* set )
	{
		qor_pp_fcontext;
		int iResult = 0;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, __WSAFDIsSet );
		iResult = Library::Call< int, SOCKET, fd_set* >( pFunc, fd, set );
#else
		qor_pp_unref2( fd, set );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	void WS2::freeaddrinfo( addrinfo* ai )
	{
		qor_pp_fcontext;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, freeaddrinfo );
		Library::voidCall< addrinfo* >( pFunc, ai );
#else
		qor_pp_unref( ai );
		continuable("Requires Windows 2000 Professional");
#endif
	}

	
	int WS2::getaddrinfo( PCSTR pNodeName, PCSTR pServiceName, const ADDRINFOA* pHints, PADDRINFOA* ppResult )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, getaddrinfo );
		iResult = Library::Call< int, PCSTR, PCSTR, const ADDRINFOA*, PADDRINFOA* >( pFunc, pNodeName, pServiceName, pHints, ppResult );
#else
		qor_pp_unref4( pNodeName, pServiceName, pHints, ppResult );
		continuable("Requires Windows 2000 Professional");
#endif
		return iResult;
	}

	
	int WS2::getnameinfo( const sockaddr* sa, socklen_t salen, char* host, DWORD hostlen, char* serv, DWORD servlen, int flags )
	{
		qor_pp_fcontext;
		CheckReturn< int, CheckNonZeroIsWinsockFailure< int> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0500 )
		qor_pp_useswinapi( ws2_32, getnameinfo );
		iResult = Library::Call< int, const sockaddr*, socklen_t, char*, DWORD, char*, DWORD, int >( pFunc, sa, salen, host, hostlen, serv, servlen, flags );
#else
		qor_pp_unref7( sa, salen, host, hostlen, serv, servlen, flags );
		continuable("Requires Windows 2000");
#endif
		return iResult;
	}

	
	PCSTR WS2::inet_ntop( INT Family, PVOID pAddr, PSTR pStringBuf, size_t StringBufSize )
	{
		qor_pp_fcontext;
		CheckReturn< PCSTR, CheckNullPointerIsWinsockFailure<PCSTR> >::TType pcResult;
#if		( _WIN32_WINNT >= 0x0600 )
		qor_pp_useswinapi( ws2_32, inet_ntop );
		pcResult = Library::Call< PCSTR, INT, PVOID, PSTR, size_t >( pFunc, Family, pAddr, pStringBuf, StringBufSize );
#else
		qor_pp_unref4( Family, pAddr, pStringBuf, StringBufSize );
		continuable("Requires Windows Vista");
#endif
		return pcResult;
	}

	
	INT WS2::inet_pton( INT Family, PCSTR pszAddrString, PVOID pAddrBuf )
	{
		qor_pp_fcontext;
		CheckReturn< INT, TCheckNotLess< INT, 1> >::TType iResult;
#if		( _WIN32_WINNT >= 0x0600 )
		qor_pp_useswinapi( ws2_32, inet_pton );
		iResult = Library::Call< INT, INT, PCSTR, PVOID >( pFunc, Family, pszAddrString, pAddrBuf );
#else
		qor_pp_unref3( Family, pszAddrString, pAddrBuf );
		continuable("Requires Windows Vista");
#endif
		return iResult;
	}

}}}//qor::nswindows::api
